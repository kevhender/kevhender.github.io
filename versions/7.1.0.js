const data = {
  menu: [
    { text: 'Accordion', href: '/apiReference/[module]', as: '/apiReference/Accordion' },
    { text: 'ActionButton', href: '/apiReference/[module]', as: '/apiReference/ActionButton' },
    { text: 'AppBar', href: '/apiReference/[module]', as: '/apiReference/AppBar' },
    {
      text: 'AutoScrollToNewChildren',
      href: '/apiReference/[module]',
      as: '/apiReference/AutoScrollToNewChildren',
    },
    { text: 'BackToTop', href: '/apiReference/[module]', as: '/apiReference/BackToTop' },
    { text: 'Box', href: '/apiReference/[module]', as: '/apiReference/Box' },
    { text: 'Breadcrumbs', href: '/apiReference/[module]', as: '/apiReference/Breadcrumbs' },
    {
      items: [
        {
          text: 'Carousel',
          href: '/apiReference/[module]',
          as: '/apiReference/carousel%2FCarousel',
        },
        {
          text: 'CarouselArrows',
          href: '/apiReference/[module]',
          as: '/apiReference/carousel%2FCarouselArrows',
        },
        {
          text: 'CarouselDots',
          href: '/apiReference/[module]',
          as: '/apiReference/carousel%2FCarouselDots',
        },
        {
          text: 'CarouselThumbnails',
          href: '/apiReference/[module]',
          as: '/apiReference/carousel%2FCarouselThumbnails',
        },
        {
          text: 'Lightbox',
          href: '/apiReference/[module]',
          as: '/apiReference/carousel%2FLightbox',
        },
        {
          text: 'MagnifyHint',
          href: '/apiReference/[module]',
          as: '/apiReference/carousel%2FMagnifyHint',
        },
        { text: 'Media', href: '/apiReference/[module]', as: '/apiReference/carousel%2FMedia' },
        {
          text: 'MediaCarousel',
          href: '/apiReference/[module]',
          as: '/apiReference/carousel%2FMediaCarousel',
        },
      ],
      text: 'carousel',
    },
    { text: 'CartButton', href: '/apiReference/[module]', as: '/apiReference/CartButton' },
    { text: 'CmsSlot', href: '/apiReference/[module]', as: '/apiReference/CmsSlot' },
    {
      items: [
        { text: 'Drawer', href: '/apiReference/[module]', as: '/apiReference/drawer%2FDrawer' },
        {
          text: 'DrawerCloseButton',
          href: '/apiReference/[module]',
          as: '/apiReference/drawer%2FDrawerCloseButton',
        },
      ],
      text: 'drawer',
    },
    { text: 'ErrorBoundary', href: '/apiReference/[module]', as: '/apiReference/ErrorBoundary' },
    {
      text: 'ExpandableSection',
      href: '/apiReference/[module]',
      as: '/apiReference/ExpandableSection',
    },
    { text: 'Fill', href: '/apiReference/[module]', as: '/apiReference/Fill' },
    {
      text: 'ForwardThumbnail',
      href: '/apiReference/[module]',
      as: '/apiReference/ForwardThumbnail',
    },
    {
      items: [
        {
          text: 'useAppStore',
          href: '/apiReference/[module]',
          as: '/apiReference/hooks%2FuseAppStore',
        },
        {
          text: 'useIntersectionObserver',
          href: '/apiReference/[module]',
          as: '/apiReference/hooks%2FuseIntersectionObserver',
        },
        {
          text: 'useStateFromProp',
          href: '/apiReference/[module]',
          as: '/apiReference/hooks%2FuseStateFromProp',
        },
      ],
      text: 'hooks',
    },
    { text: 'Image', href: '/apiReference/[module]', as: '/apiReference/Image' },
    { text: 'Label', href: '/apiReference/[module]', as: '/apiReference/Label' },
    { text: 'Lazy', href: '/apiReference/[module]', as: '/apiReference/Lazy' },
    {
      items: [
        { text: 'Link', href: '/apiReference/[module]', as: '/apiReference/link%2FLink' },
        {
          text: 'LinkContextProvider',
          href: '/apiReference/[module]',
          as: '/apiReference/link%2FLinkContextProvider',
        },
      ],
      text: 'link',
    },
    { text: 'LoadMask', href: '/apiReference/[module]', as: '/apiReference/LoadMask' },
    {
      items: [
        { text: 'Menu', href: '/apiReference/[module]', as: '/apiReference/menu%2FMenu' },
        { text: 'MenuBack', href: '/apiReference/[module]', as: '/apiReference/menu%2FMenuBack' },
        { text: 'MenuBody', href: '/apiReference/[module]', as: '/apiReference/menu%2FMenuBody' },
        {
          text: 'MenuBranch',
          href: '/apiReference/[module]',
          as: '/apiReference/menu%2FMenuBranch',
        },
        {
          text: 'MenuButton',
          href: '/apiReference/[module]',
          as: '/apiReference/menu%2FMenuButton',
        },
        { text: 'MenuCard', href: '/apiReference/[module]', as: '/apiReference/menu%2FMenuCard' },
        {
          text: 'MenuExpanderIcon',
          href: '/apiReference/[module]',
          as: '/apiReference/menu%2FMenuExpanderIcon',
        },
        {
          text: 'MenuFooter',
          href: '/apiReference/[module]',
          as: '/apiReference/menu%2FMenuFooter',
        },
        {
          text: 'MenuHeader',
          href: '/apiReference/[module]',
          as: '/apiReference/menu%2FMenuHeader',
        },
        { text: 'MenuIcon', href: '/apiReference/[module]', as: '/apiReference/menu%2FMenuIcon' },
        {
          text: 'MenuItemContent',
          href: '/apiReference/[module]',
          as: '/apiReference/menu%2FMenuItemContent',
        },
        { text: 'MenuLeaf', href: '/apiReference/[module]', as: '/apiReference/menu%2FMenuLeaf' },
        { text: 'SEOLinks', href: '/apiReference/[module]', as: '/apiReference/menu%2FSEOLinks' },
      ],
      text: 'menu',
    },
    {
      items: [
        {
          text: 'withAmpFormParser',
          href: '/apiReference/[module]',
          as: '/apiReference/middlewares%2FwithAmpFormParser',
        },
      ],
      text: 'middlewares',
    },
    {
      items: [
        { text: 'NavTab', href: '/apiReference/[module]', as: '/apiReference/nav%2FNavTab' },
        { text: 'NavTabs', href: '/apiReference/[module]', as: '/apiReference/nav%2FNavTabs' },
      ],
      text: 'nav',
    },
    { text: 'NoScript', href: '/apiReference/[module]', as: '/apiReference/NoScript' },
    { text: 'Offline', href: '/apiReference/[module]', as: '/apiReference/Offline' },
    {
      items: [
        {
          text: 'ProductOption',
          href: '/apiReference/[module]',
          as: '/apiReference/option%2FProductOption',
        },
        {
          text: 'ProductOptionSelector',
          href: '/apiReference/[module]',
          as: '/apiReference/option%2FProductOptionSelector',
        },
        {
          text: 'SwatchProductOption',
          href: '/apiReference/[module]',
          as: '/apiReference/option%2FSwatchProductOption',
        },
        {
          text: 'TextProductOption',
          href: '/apiReference/[module]',
          as: '/apiReference/option%2FTextProductOption',
        },
      ],
      text: 'option',
    },
    {
      items: [
        { text: 'Filter', href: '/apiReference/[module]', as: '/apiReference/plp%2FFilter' },
        {
          text: 'FilterButton',
          href: '/apiReference/[module]',
          as: '/apiReference/plp%2FFilterButton',
        },
        {
          text: 'FilterFooter',
          href: '/apiReference/[module]',
          as: '/apiReference/plp%2FFilterFooter',
        },
        {
          text: 'SearchResultsProvider',
          href: '/apiReference/[module]',
          as: '/apiReference/plp%2FSearchResultsProvider',
        },
        { text: 'ShowMore', href: '/apiReference/[module]', as: '/apiReference/plp%2FShowMore' },
        { text: 'Sort', href: '/apiReference/[module]', as: '/apiReference/plp%2FSort' },
        {
          text: 'SortButton',
          href: '/apiReference/[module]',
          as: '/apiReference/plp%2FSortButton',
        },
      ],
      text: 'plp',
    },
    { text: 'profile', href: '/apiReference/[module]', as: '/apiReference/profile' },
    {
      items: [
        {
          text: 'fetchProps',
          href: '/apiReference/[module]',
          as: '/apiReference/props%2FfetchProps',
        },
        {
          text: 'fulfillAPIRequest',
          href: '/apiReference/[module]',
          as: '/apiReference/props%2FfulfillAPIRequest',
        },
      ],
      text: 'props',
    },
    { text: 'PWA', href: '/apiReference/[module]', as: '/apiReference/PWA' },
    {
      text: 'QuantitySelector',
      href: '/apiReference/[module]',
      as: '/apiReference/QuantitySelector',
    },
    { text: 'Rating', href: '/apiReference/[module]', as: '/apiReference/Rating' },
    {
      text: 'ResponsiveTiles',
      href: '/apiReference/[module]',
      as: '/apiReference/ResponsiveTiles',
    },
    {
      items: [
        {
          text: 'replaceState',
          href: '/apiReference/[module]',
          as: '/apiReference/router%2FreplaceState',
        },
        {
          text: 'storeInitialPropsInHistory',
          href: '/apiReference/[module]',
          as: '/apiReference/router%2FstoreInitialPropsInHistory',
        },
      ],
      text: 'router',
    },
    { text: 'Row', href: '/apiReference/[module]', as: '/apiReference/Row' },
    {
      items: [
        {
          text: 'SearchButton',
          href: '/apiReference/[module]',
          as: '/apiReference/search%2FSearchButton',
        },
        {
          text: 'SearchDrawer',
          href: '/apiReference/[module]',
          as: '/apiReference/search%2FSearchDrawer',
        },
        {
          text: 'SearchField',
          href: '/apiReference/[module]',
          as: '/apiReference/search%2FSearchField',
        },
        {
          text: 'SearchForm',
          href: '/apiReference/[module]',
          as: '/apiReference/search%2FSearchForm',
        },
        {
          text: 'SearchHeader',
          href: '/apiReference/[module]',
          as: '/apiReference/search%2FSearchHeader',
        },
        {
          text: 'SearchProvider',
          href: '/apiReference/[module]',
          as: '/apiReference/search%2FSearchProvider',
        },
        {
          text: 'SearchSubmitButton',
          href: '/apiReference/[module]',
          as: '/apiReference/search%2FSearchSubmitButton',
        },
        {
          text: 'SearchSuggestionGroup',
          href: '/apiReference/[module]',
          as: '/apiReference/search%2FSearchSuggestionGroup',
        },
        {
          text: 'SearchSuggestionItem',
          href: '/apiReference/[module]',
          as: '/apiReference/search%2FSearchSuggestionItem',
        },
        {
          text: 'SearchSuggestions',
          href: '/apiReference/[module]',
          as: '/apiReference/search%2FSearchSuggestions',
        },
      ],
      text: 'search',
    },
    {
      text: 'serviceWorker',
      items: [
        { text: 'prefetch', url: 'serviceWorker/prefetch' },
        { text: 'prefetchJsonFor', url: 'serviceWorker/prefetchJsonFor' },
      ],
    },
    {
      items: [
        {
          text: 'SessionProvider',
          href: '/apiReference/[module]',
          as: '/apiReference/session%2FSessionProvider',
        },
      ],
      text: 'session',
    },
    { text: 'Spacer', href: '/apiReference/[module]', as: '/apiReference/Spacer' },
    { text: 'TabPanel', href: '/apiReference/[module]', as: '/apiReference/TabPanel' },
    { text: 'ToolbarButton', href: '/apiReference/[module]', as: '/apiReference/ToolbarButton' },
    {
      items: [
        {
          text: 'fetchLatest',
          items: [
            { text: 'default', url: 'utils/fetchLatest/default' },
            { text: 'StaleResponseError', url: 'utils/fetchLatest/StaleResponseError' },
          ],
        },
        { text: 'format', items: [{ text: 'price', url: 'utils/format/price' }] },
        {
          text: 'lazyLoadImages',
          href: '/apiReference/[module]',
          as: '/apiReference/utils%2FlazyLoadImages',
        },
        { text: 'merge', href: '/apiReference/[module]', as: '/apiReference/utils%2Fmerge' },
        {
          text: 'withDefaultHandler',
          href: '/apiReference/[module]',
          as: '/apiReference/utils%2FwithDefaultHandler',
        },
      ],
      text: 'utils',
    },
  ],
  exports: {
    Accordion: {
      name: 'Accordion',
      filename: 'Accordion',
      importPath: 'Accordion',
      src:
        'import PropTypes from \'prop-types\'\nimport React, { useState } from \'react\'\n\n/**\n * Accordion which only allows one child `ExpandableSection` to be open at a time\n *\n * ```js\n *  <Accordion>\n *    <ExpandableSection title="First">\n *      <div>The first section</div>\n *    </ExpandableSection>\n *    <ExpandableSection title="Second">\n *      <div>The second section</div>\n *    </ExpandableSection>\n *    <ExpandableSection title="Third">\n *      <div>The third section</div>\n *    </ExpandableSection>\n *  </Accordion>\n * ```\n */\nexport default function Accordion({ children }) {\n  if (!children) {\n    return null\n  }\n\n  const [expanded, setExpanded] = useState(() => children.findIndex(child => child.props.expanded))\n\n  return (\n    // wrapped in a Fragment so react-docgen recognizes this as a Component:\n    <>\n      {React.Children.map(children, (child, i) => {\n        return React.cloneElement(child, {\n          expanded: expanded === i,\n          onChange: (e, expanded) => {\n            e.preventDefault()\n            setExpanded(expanded ? i : null)\n          },\n        })\n      })}\n    </>\n  )\n}\n\nAccordion.propTypes = {\n  /**\n   * A list of `ExpandableSection`s that will be controlled.\n   */\n  children: PropTypes.node,\n}\n',
      description:
        'Accordion which only allows one child `ExpandableSection` to be open at a time\n\n```js\n <Accordion>\n   <ExpandableSection title="First">\n     <div>The first section</div>\n   </ExpandableSection>\n   <ExpandableSection title="Second">\n     <div>The second section</div>\n   </ExpandableSection>\n   <ExpandableSection title="Third">\n     <div>The third section</div>\n   </ExpandableSection>\n </Accordion>\n```',
      displayName: 'Accordion',
      methods: [],
      props: [
        {
          name: 'children',
          type: { name: 'node' },
          required: false,
          description: 'A list of `ExpandableSection`s that will be controlled.',
        },
      ],
      styles: { classes: [], name: null },
      type: 'component',
      import: "import Accordion from 'react-storefront/Accordion'",
    },
    ActionButton: {
      name: 'ActionButton',
      filename: 'ActionButton',
      importPath: 'ActionButton',
      src:
        "import React, { forwardRef } from 'react'\nimport { makeStyles } from '@material-ui/core/styles'\nimport { Button, Typography } from '@material-ui/core'\nimport PropTypes from 'prop-types'\n\nexport const styles = theme => ({\n  /**\n   * Styles passed through to the [`Button`](https://material-ui.com/api/button/#css) element's\n   * `label` CSS rule.\n   */\n  label: {\n    justifyContent: 'space-between',\n    alignItems: 'baseline',\n    textTransform: 'none',\n  },\n  /**\n   * Styles applied to the label container.\n   */\n  caption: {\n    textTransform: 'none',\n    fontWeight: 'bold',\n  },\n  /**\n   * Styles passed through to the `.MuiButton-container` class.\n   */\n  button: {\n    boxShadow: 'none',\n    backgroundColor: theme.palette.grey[200],\n  },\n  /**\n   * Styles applied to the values container.\n   */\n  value: {\n    color: theme.palette.text.primary,\n    whiteSpace: 'nowrap',\n    textOverflow: 'ellipses',\n    marginLeft: '10px',\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFActionButton' })\n\n/**\n * This button class displays a label and value.\n *\n * Example:\n *\n * ```js\n *  <ActionButton label=\"Sort\" value=\"Lowest Price\" onClick={openSortMenu} />\n * ```\n */\nconst ActionButton = forwardRef(({ label, value, children, classes = {}, ...props }, ref) => {\n  let { caption, value: valueClasses, button, label: labelClasses, ...otherClasses } = classes\n  classes = useStyles({ classes: { caption, value: valueClasses, button, label: labelClasses } })\n\n  return (\n    <Button\n      ref={ref}\n      variant=\"contained\"\n      classes={{\n        contained: classes.button,\n        label: classes.label,\n        ...otherClasses,\n      }}\n      {...props}\n    >\n      <Typography variant=\"button\" className={classes.caption}>\n        {label}\n      </Typography>\n      <Typography variant=\"caption\" className={classes.value}>\n        {value}\n      </Typography>\n    </Button>\n  )\n})\n\nActionButton.propTypes = {\n  /**\n   * Override or extend the styles applied to the component. See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object,\n\n  /**\n   * The label to display on the left side of the button.\n   */\n  label: PropTypes.oneOfType([PropTypes.string, PropTypes.element]),\n\n  /**\n   * The value to display on the right side of the button.\n   */\n  value: PropTypes.oneOfType([PropTypes.string, PropTypes.element]),\n}\n\nexport default ActionButton\n",
      description:
        'This button class displays a label and value.\n\nExample:\n\n```js\n <ActionButton label="Sort" value="Lowest Price" onClick={openSortMenu} />\n```',
      methods: [],
      props: [
        {
          name: 'classes',
          type: { name: 'object' },
          required: false,
          description:
            'Override or extend the styles applied to the component. See [CSS API](#css) below for more details.',
          defaultValue: { value: '{}', computed: false },
        },
        {
          name: 'label',
          type: { name: 'union', value: [{ name: 'string' }, { name: 'element' }] },
          required: false,
          description: 'The label to display on the left side of the button.',
        },
        {
          name: 'value',
          type: { name: 'union', value: [{ name: 'string' }, { name: 'element' }] },
          required: false,
          description: 'The value to display on the right side of the button.',
        },
      ],
      styles: {
        classes: [
          {
            ruleName: 'label',
            globalClass: '.RSFActionButton-label',
            description:
              "Styles passed through to the [`Button`](https://material-ui.com/api/button/#css) element's\n`label` CSS rule.",
          },
          {
            ruleName: 'caption',
            globalClass: '.RSFActionButton-caption',
            description: 'Styles applied to the label container.',
          },
          {
            ruleName: 'button',
            globalClass: '.RSFActionButton-button',
            description: 'Styles passed through to the `.MuiButton-container` class.',
          },
          {
            ruleName: 'value',
            globalClass: '.RSFActionButton-value',
            description: 'Styles applied to the values container.',
          },
        ],
      },
      type: 'component',
      import: "import ActionButton from 'react-storefront/ActionButton'",
    },
    AppBar: {
      name: 'AppBar',
      filename: 'AppBar',
      importPath: 'AppBar',
      src:
        "import React, { useState, useEffect, useRef, useContext } from 'react'\nimport PropTypes from 'prop-types'\nimport clsx from 'clsx'\nimport { Toolbar } from '@material-ui/core'\nimport { makeStyles } from '@material-ui/core/styles'\nimport { useAmp } from 'next/amp'\nimport PWAContext from './PWAContext'\n\nexport const styles = theme => ({\n  /**\n   * Styles applied to the root element when user is not `offline`.\n   */\n  root: {\n    height: 64,\n    boxSizing: 'content-box',\n    position: 'relative',\n    zIndex: theme.zIndex.modal + 10,\n  },\n\n  /**\n   * Styles applied to the root element when Amp is used.\n   */\n  withAmp: {\n    zIndex: theme.zIndex.amp.modal + 1,\n  },\n\n  /**\n   * Styles applied to the offline warning element.\n   */\n  offline: {\n    textAlign: 'center',\n    backgroundColor: '#f34c4c',\n    color: 'white',\n  },\n\n  /**\n   * Styles applied to the `Toolbar` element.\n   */\n  toolbar: {\n    height: '64px',\n    maxWidth: theme.maxWidth,\n    flex: 1,\n  },\n\n  /**\n   * Styles applied to the element wrapped around the `Toolbar`.\n   */\n  wrap: {\n    borderBottom: `1px solid ${theme.palette.divider}`,\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    backgroundColor: theme.palette.background.paper,\n    zIndex: theme.zIndex.modal + 10,\n    display: 'flex',\n    justifyContent: 'center',\n  },\n\n  /**\n   * Styles applied to the `Toolbar` wrapper when the `AppBar` is unstuck.\n   */\n  unstuck: {\n    transform: 'translateY(-100%)',\n  },\n\n  /**\n   * Styles applied to the `Toolbar` wrapper element when the user has scrolled and the `AppBar`\n   * will animate back into place.\n   */\n  animate: {\n    transition: 'transform .15s ease-in',\n  },\n\n  /**\n   * Styles applied to the `Toolbar` wrapper element the user has scrolled and the `AppBar` is hidden.\n   */\n  hidden: {\n    position: 'fixed',\n    zIndex: theme.zIndex.modal + 10,\n    boxShadow: theme.shadows[2],\n    top: 0,\n    left: 0,\n    right: 0,\n  },\n\n  /**\n   * Styles applied to the `Toolbar` wrapper element when [`fixed`](#prop-fixed) is `true`.\n   */\n  fixed: {\n    position: 'fixed',\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFAppBar' })\n\nexport default function AppBar({ classes, children, fixed, offlineWarning }) {\n  classes = useStyles({ classes })\n\n  const [state, applyState] = useState({\n    stuck: false,\n    hidden: false,\n    animate: false,\n  })\n  const { stuck, hidden, animate } = state\n  const setState = newState => applyState({ ...state, ...newState })\n  const lastScrollY = useRef()\n  const unstickAt = useRef()\n  const stickAt = useRef()\n  const { offline } = useContext(PWAContext)\n  const items = React.Children.toArray(children)\n\n  const onScroll = () => {\n    const height = 64,\n      { scrollY } = window,\n      unstickBufferZone = 30\n\n    if (scrollY === 0) {\n      setState({ hidden: false, stuck: false, animate: false })\n    } else if (scrollY > height && !hidden) {\n      setState({ hidden: true })\n    }\n\n    if (scrollY < stickAt.current && !stuck) {\n      stickAt.current = null\n      unstickAt.current = scrollY + unstickBufferZone\n      setState({ stuck: true })\n    } else if (scrollY > unstickAt.current && stuck) {\n      unstickAt.current = null\n      stickAt.current = scrollY - unstickBufferZone\n      setState({ stuck: false })\n    }\n\n    if (lastScrollY.current > scrollY && stuck) {\n      unstickAt.current = scrollY + unstickBufferZone\n    }\n\n    if (lastScrollY.current < scrollY && !stuck) {\n      stickAt.current = scrollY - unstickBufferZone\n    }\n\n    lastScrollY.current = scrollY\n  }\n\n  useEffect(() => {\n    if (!fixed) {\n      window.addEventListener('scroll', onScroll, { passive: true })\n      return () => window.removeEventListener('scroll', onScroll, { passive: true })\n    }\n  }, [state])\n\n  useEffect(() => {\n    if (hidden && !animate) {\n      setTimeout(() => setState({ animate: true }), 100)\n    }\n  }, [hidden])\n\n  return (\n    <div>\n      {offline && <div className={classes.offline}>{offlineWarning}</div>}\n      <div className={clsx({ [classes.root]: true, [classes.withAmp]: useAmp() })}>\n        <div\n          className={clsx({\n            [classes.wrap]: true,\n            [classes.fixed]: fixed,\n            [classes.hidden]: hidden,\n            [classes.unstuck]: hidden && !stuck,\n            [classes.animate]: animate && window.scrollY > 0,\n          })}\n        >\n          <Toolbar disableGutters classes={{ root: classes.toolbar }}>\n            {items}\n          </Toolbar>\n        </div>\n      </div>\n    </div>\n  )\n}\n\nAppBar.propTypes = {\n  /**\n   * Override or extend the styles applied to the component. See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object,\n\n  /**\n   * Set as `true` if the AppBar should be fixed position.\n   */\n  fixed: PropTypes.bool,\n\n  /**\n   * String or Element to render within the offline warning container at the top of the app.\n   */\n  offlineWarning: PropTypes.oneOfType([PropTypes.string, PropTypes.element]),\n}\n\nAppBar.defaultProps = {\n  offlineWarning: 'Your device lost its internet connection.',\n  fixed: false,\n}\n",
      description: '',
      displayName: 'AppBar',
      methods: [],
      props: [
        {
          name: 'classes',
          type: { name: 'object' },
          required: false,
          description:
            'Override or extend the styles applied to the component. See [CSS API](#css) below for more details.',
        },
        {
          name: 'fixed',
          type: { name: 'bool' },
          required: false,
          description: 'Set as `true` if the AppBar should be fixed position.',
          defaultValue: { value: 'false', computed: false },
        },
        {
          name: 'offlineWarning',
          type: { name: 'union', value: [{ name: 'string' }, { name: 'element' }] },
          required: false,
          description:
            'String or Element to render within the offline warning container at the top of the app.',
          defaultValue: { value: "'Your device lost its internet connection.'", computed: false },
        },
      ],
      styles: {
        classes: [
          {
            ruleName: 'root',
            globalClass: '.RSFAppBar-root',
            description: 'Styles applied to the root element when user is not `offline`.',
          },
          {
            ruleName: 'withAmp',
            globalClass: '.RSFAppBar-withAmp',
            description: 'Styles applied to the root element when Amp is used.',
          },
          {
            ruleName: 'offline',
            globalClass: '.RSFAppBar-offline',
            description: 'Styles applied to the offline warning element.',
          },
          {
            ruleName: 'toolbar',
            globalClass: '.RSFAppBar-toolbar',
            description: 'Styles applied to the `Toolbar` element.',
          },
          {
            ruleName: 'wrap',
            globalClass: '.RSFAppBar-wrap',
            description: 'Styles applied to the element wrapped around the `Toolbar`.',
          },
          {
            ruleName: 'unstuck',
            globalClass: '.RSFAppBar-unstuck',
            description: 'Styles applied to the `Toolbar` wrapper when the `AppBar` is unstuck.',
          },
          {
            ruleName: 'animate',
            globalClass: '.RSFAppBar-animate',
            description:
              'Styles applied to the `Toolbar` wrapper element when the user has scrolled and the `AppBar`\nwill animate back into place.',
          },
          {
            ruleName: 'hidden',
            globalClass: '.RSFAppBar-hidden',
            description:
              'Styles applied to the `Toolbar` wrapper element the user has scrolled and the `AppBar` is hidden.',
          },
          {
            ruleName: 'fixed',
            globalClass: '.RSFAppBar-fixed',
            description:
              'Styles applied to the `Toolbar` wrapper element when [`fixed`](#prop-fixed) is `true`.',
          },
        ],
        name: 'AppBar',
      },
      type: 'component',
      import: "import AppBar from 'react-storefront/AppBar'",
    },
    AutoScrollToNewChildren: {
      name: 'AutoScrollToNewChildren',
      filename: 'AutoScrollToNewChildren',
      importPath: 'AutoScrollToNewChildren',
      src:
        "import React, { useEffect, useState, useRef } from 'react'\n\n/**\n * A wrapper component which scrolls the first new child into view when\n * the number of children increases.\n */\nconst AutoScrollToNewChildren = ({ children }) => {\n  const childCount = React.Children.count(children)\n  const [priorChildCount, setPriorChildCount] = useState(childCount)\n  const firstNewChild = useRef(null)\n\n  useEffect(() => {\n    if (!priorChildCount) {\n      setPriorChildCount(childCount)\n    } else if (childCount > priorChildCount) {\n      firstNewChild.current.scrollIntoView({ behavior: 'smooth' })\n      setPriorChildCount(childCount)\n    }\n  }, [childCount, setPriorChildCount, priorChildCount])\n\n  return (\n    // wrapped in a Fragment so react-docgen recognizes this as a Component:\n    <>\n      {React.Children.map(children, (child, index) => {\n        return (\n          <>\n            {child}\n            {index === priorChildCount ? <div ref={firstNewChild} /> : null}\n          </>\n        )\n      })}\n    </>\n  )\n}\n\nexport default AutoScrollToNewChildren\n",
      description:
        'A wrapper component which scrolls the first new child into view when\nthe number of children increases.',
      displayName: 'AutoScrollToNewChildren',
      methods: [],
      styles: { classes: [], name: null },
      props: [],
      type: 'component',
      import: "import AutoScrollToNewChildren from 'react-storefront/AutoScrollToNewChildren'",
    },
    BackToTop: {
      name: 'BackToTop',
      filename: 'BackToTop',
      importPath: 'BackToTop',
      src:
        "import React, { useRef, useEffect, useState } from 'react'\nimport PropTypes from 'prop-types'\nimport throttle from 'lodash/throttle'\nimport { ArrowUpward } from '@material-ui/icons'\nimport { Fab, Fade } from '@material-ui/core'\nimport { makeStyles } from '@material-ui/core/styles'\n\nconst styles = () => ({\n  /**\n   * Styles applied to the root element.\n   */\n  root: {\n    zIndex: 1,\n    position: 'fixed',\n    bottom: 24,\n    right: 16,\n  },\n  /**\n   * Styles applied to the floating action button element.\n   */\n  fab: {\n    background: 'rgba(0,0,0,.85)',\n    '&:hover': {\n      background: 'rgb(0,0,0)',\n    },\n  },\n  /**\n   * Styles applied to the icon element.\n   */\n  icon: {\n    color: 'white',\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFBackToTop' })\n\n/**\n * A floating action button that appears when the user scrolls down\n * and scrolls to the top of the page when clicked.\n */\nexport default function BackToTop({\n  Icon,\n  showUnderY,\n  instantBehaviorUnderY,\n  classes,\n  fadeTime,\n  size,\n}) {\n  const [visible, setVisible] = useState(false)\n  const el = useRef()\n  classes = useStyles({ classes })\n\n  useEffect(() => {\n    const onScroll = throttle(() => {\n      setVisible(\n        getScrollY() > showUnderY &&\n          el.current.parentElement &&\n          el.current.parentElement.offsetParent != null,\n      )\n    }, 200)\n\n    window.addEventListener('scroll', onScroll, { passive: true })\n    return () => window.removeEventListener('scroll', onScroll)\n  }, [])\n\n  const scrollToTop = () => {\n    const behavior = getScrollY() > instantBehaviorUnderY ? 'auto' : 'smooth'\n    window.scrollTo({ top: 0, left: 0, behavior })\n  }\n\n  Icon = Icon || ArrowUpward\n\n  return (\n    <div className={classes.root} ref={el}>\n      <Fade in={visible} timeout={fadeTime}>\n        <Fab className={classes.fab} size={size} onClick={scrollToTop} title=\"back to top\">\n          <Icon className={classes.icon} />\n        </Fab>\n      </Fade>\n    </div>\n  )\n}\n\nBackToTop.propTypes = {\n  /**\n   * Override or extend the styles applied to the component. See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object,\n  /**\n   * The icon to use within the `Fab` component.\n   */\n  Icon: PropTypes.node,\n  /**\n   * Value which controls where along the Y position the `BackToTop` component is shown.\n   */\n  showUnderY: PropTypes.number,\n  /**\n   * When the scroll position is less than this value, the page will smoothly scroll back up. If\n   * the scroll position is more than this value, the page will immediately scroll back up.\n   */\n  instantBehaviorUnderY: PropTypes.number,\n  /**\n   * Duration of the fade in/out animation for the icon.\n   */\n  fadeTime: PropTypes.number,\n  /**\n   * Controls size of component.\n   */\n  size: PropTypes.oneOf(['small', 'medium', 'large']),\n}\n\nBackToTop.defaultProps = {\n  showUnderY: 250,\n  instantBehaviorUnderY: 3000,\n  fadeTime: 320,\n  size: 'medium',\n}\n\nfunction getScrollY() {\n  return window.scrollY || window.pageYOffset\n}\n",
      description:
        'A floating action button that appears when the user scrolls down\nand scrolls to the top of the page when clicked.',
      displayName: 'BackToTop',
      methods: [],
      props: [
        {
          name: 'classes',
          type: { name: 'object' },
          required: false,
          description:
            'Override or extend the styles applied to the component. See [CSS API](#css) below for more details.',
        },
        {
          name: 'Icon',
          type: { name: 'node' },
          required: false,
          description: 'The icon to use within the `Fab` component.',
        },
        {
          name: 'showUnderY',
          type: { name: 'number' },
          required: false,
          description:
            'Value which controls where along the Y position the `BackToTop` component is shown.',
          defaultValue: { value: '250', computed: false },
        },
        {
          name: 'instantBehaviorUnderY',
          type: { name: 'number' },
          required: false,
          description:
            'When the scroll position is less than this value, the page will smoothly scroll back up. If\nthe scroll position is more than this value, the page will immediately scroll back up.',
          defaultValue: { value: '3000', computed: false },
        },
        {
          name: 'fadeTime',
          type: { name: 'number' },
          required: false,
          description: 'Duration of the fade in/out animation for the icon.',
          defaultValue: { value: '320', computed: false },
        },
        {
          name: 'size',
          type: {
            name: 'enum',
            value: [
              { value: "'small'", computed: false },
              { value: "'medium'", computed: false },
              { value: "'large'", computed: false },
            ],
          },
          required: false,
          description: 'Controls size of component.',
          defaultValue: { value: "'medium'", computed: false },
        },
      ],
      styles: { classes: [], name: null },
      type: 'component',
      import: "import BackToTop from 'react-storefront/BackToTop'",
    },
    Box: {
      name: 'Box',
      filename: 'Box',
      importPath: 'Box',
      src:
        "import React from 'react'\nimport clsx from 'clsx'\nimport PropTypes from 'prop-types'\nimport { makeStyles } from '@material-ui/core/styles'\n\n/**\n * A flex container.  All additional props are spread to the style of the underlying div.\n */\nexport const styles = theme => ({\n  /**\n   * Styles applied to the root element.\n   */\n  root: {\n    display: 'flex',\n  },\n  /**\n   * Styles applied to the root element if [`split`](#prop-split) is `true`.\n   */\n  split: {\n    justifyContent: 'space-between',\n    alignItems: 'center',\n  },\n})\n\nconst useStyles = makeStyles(styles, 'RSFBox')\n\nexport default function Box({\n  className,\n  classes,\n  split = false,\n  children,\n  style,\n  align,\n  justify,\n  ...other\n}) {\n  classes = useStyles({ classes })\n\n  return (\n    <div\n      className={clsx(classes.root, className, { [classes.split]: split })}\n      style={{ alignItems: align, justifyContent: justify, ...other, ...style }}\n    >\n      {children}\n    </div>\n  )\n}\n\nBox.propTypes = {\n  /**\n   * Override or extend the styles applied to the component. See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object,\n\n  /**\n   * If `true`, split items on opposite sides of the box by applying justify-content: 'space-between'\n   */\n  split: PropTypes.bool,\n\n  /**\n   * CSS value for align-items\n   */\n  align: PropTypes.oneOf(['flex-start', 'flex-end', 'center', 'stretch', 'baseline']),\n\n  /**\n   * CSS value for justify-content\n   */\n  justify: PropTypes.oneOf([\n    'flex-start',\n    'flex-end',\n    'center',\n    'space-around',\n    'space-between',\n    'initial',\n    'inherit',\n    'stretch',\n    'baseline',\n  ]),\n}\n\nBox.defaultProps = {\n  align: 'center',\n  justify: 'flex-start',\n}\n\n/**\n * A flex container with horizontal layout. All additional props are spread to the style\n * of the underlying div.\n */\nexport function Hbox(props) {\n  props = { ...props, flexDirection: 'row' }\n  return <Box {...props} />\n}\n\nHbox.propTypes = {\n  /**\n   * Override or extend the styles applied to the component. See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object,\n\n  /**\n   * True to split items on opposite sides of the box by applying `justify-content: 'space-between'`.\n   */\n  split: PropTypes.bool,\n\n  /**\n   * CSS value for `align-items` style.\n   */\n  align: PropTypes.oneOf(['flex-start', 'flex-end', 'center', 'stretch', 'baseline']),\n\n  /**\n   * CSS value for `justify-content` style\n   */\n  justify: PropTypes.oneOf([\n    'flex-start',\n    'flex-end',\n    'center',\n    'space-around',\n    'space-between',\n    'initial',\n    'inherit',\n    'stretch',\n    'baseline',\n  ]),\n}\n\nHbox.defaultProps = {\n  align: 'center',\n  justify: 'flex-start',\n}\n\n/**\n * A flex container with vertical layout. All additional props are spread to\n * the style of the underlying div.\n */\nexport function Vbox(props) {\n  props = { ...props, flexDirection: 'column' }\n  return <Box {...props} />\n}\n\nVbox.propTypes = {\n  /**\n   * Override or extend the styles applied to the component. See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object,\n\n  /**\n   * CSS value for `align-items` style.\n   */\n  align: PropTypes.oneOf(['flex-start', 'flex-end', 'center', 'stretch', 'baseline']),\n\n  /**\n   * CSS value for `justify-content` style.\n   */\n  justify: PropTypes.oneOf([\n    'flex-start',\n    'flex-end',\n    'center',\n    'space-around',\n    'space-between',\n    'initial',\n    'inherit',\n    'stretch',\n    'baseline',\n  ]),\n}\n\nVbox.defaultProps = {\n  align: 'center',\n  justify: 'flex-start',\n}\n",
      description: '',
      displayName: 'Box',
      methods: [],
      props: [
        {
          name: 'classes',
          type: { name: 'object' },
          required: false,
          description:
            'Override or extend the styles applied to the component. See [CSS API](#css) below for more details.',
        },
        {
          name: 'split',
          type: { name: 'bool' },
          required: false,
          description:
            "If `true`, split items on opposite sides of the box by applying justify-content: 'space-between'",
          defaultValue: { value: 'false', computed: false },
        },
        {
          name: 'align',
          type: {
            name: 'enum',
            value: [
              { value: "'flex-start'", computed: false },
              { value: "'flex-end'", computed: false },
              { value: "'center'", computed: false },
              { value: "'stretch'", computed: false },
              { value: "'baseline'", computed: false },
            ],
          },
          required: false,
          description: 'CSS value for align-items',
          defaultValue: { value: "'center'", computed: false },
        },
        {
          name: 'justify',
          type: {
            name: 'enum',
            value: [
              { value: "'flex-start'", computed: false },
              { value: "'flex-end'", computed: false },
              { value: "'center'", computed: false },
              { value: "'space-around'", computed: false },
              { value: "'space-between'", computed: false },
              { value: "'initial'", computed: false },
              { value: "'inherit'", computed: false },
              { value: "'stretch'", computed: false },
              { value: "'baseline'", computed: false },
            ],
          },
          required: false,
          description: 'CSS value for justify-content',
          defaultValue: { value: "'flex-start'", computed: false },
        },
      ],
      styles: {
        classes: [
          { ruleName: 'root', globalClass: '', description: '' },
          { ruleName: 'split', globalClass: '', description: '' },
        ],
        name: 'Box',
      },
      type: 'component',
      import: "import Box from 'react-storefront/Box'",
    },
    Breadcrumbs: {
      name: 'Breadcrumbs',
      filename: 'Breadcrumbs',
      importPath: 'Breadcrumbs',
      src:
        "import React from 'react'\nimport { KeyboardArrowRight as ArrowRight } from '@material-ui/icons'\nimport Link from './link/Link'\nimport clsx from 'clsx'\nimport { Typography, Container } from '@material-ui/core'\nimport { makeStyles } from '@material-ui/core/styles'\nimport PropTypes from 'prop-types'\n\nexport const styles = theme => ({\n  /**\n   * Styles applied to the root element.\n   */\n  breadcrumbs: {\n    backgroundColor: '#F4F2F1',\n    padding: '12px 0',\n\n    '& a': {\n      color: theme.palette.text.primary,\n      textDecoration: 'none',\n    },\n  },\n\n  /**\n   * Styles applied to the separators.\n   */\n  separator: {\n    height: '12px',\n    position: 'relative',\n    top: '2px',\n    width: '16px',\n  },\n\n  /**\n   * Styles applied to the currently active breadcrumb's element.\n   */\n  current: {\n    fontWeight: 'bold',\n    color: theme.palette.text.primary,\n  },\n})\n\nconst useStyles = makeStyles(styles, 'RSFBreadcrumbs')\n\nexport default function Breadcrumbs({ items, classes }) {\n  classes = useStyles({ classes })\n\n  return (\n    <Typography display=\"block\" className={classes.breadcrumbs} variant=\"caption\">\n      <Container>\n        {items &&\n          items.map((item, i) => {\n            const arrow = i > 0 ? <ArrowRight className={classes.separator} /> : null\n            const isLastItem = items.length - 1 === i\n\n            if (item.href) {\n              return (\n                <span key={i} className={clsx(isLastItem && classes.current)}>\n                  {arrow}\n                  <Link href={item.href} as={item.as}>\n                    {item.text}\n                  </Link>\n                </span>\n              )\n            } else {\n              return (\n                <span key={i} className={clsx(isLastItem && classes.current)}>\n                  {arrow}\n                  {item.text}\n                </span>\n              )\n            }\n          })}\n        <span>&nbsp;</span>\n      </Container>\n    </Typography>\n  )\n}\n\nBreadcrumbs.propTypes = {\n  /**\n   * Override or extend the styles applied to the component. See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object,\n\n  /**\n   * The items to display, each with text, [`href`](/apiReference/link%2fLink#prop-href), and\n   * [`as`](/apiReference/link%2fLink#props-as) values.\n   */\n  items: PropTypes.arrayOf(\n    PropTypes.shape({\n      text: PropTypes.string,\n      as: PropTypes.string,\n      href: PropTypes.string,\n    }),\n  ),\n}\n",
      description: '',
      displayName: 'Breadcrumbs',
      methods: [],
      props: [
        {
          name: 'classes',
          type: { name: 'object' },
          required: false,
          description:
            'Override or extend the styles applied to the component. See [CSS API](#css) below for more details.',
        },
        {
          name: 'items',
          type: {
            name: 'arrayOf',
            value: {
              name: 'shape',
              value: {
                text: { name: 'string', required: false },
                as: { name: 'string', required: false },
                href: { name: 'string', required: false },
              },
            },
          },
          required: false,
          description:
            'The items to display, each with text, [`href`](/apiReference/link%2fLink#prop-href), and\n[`as`](/apiReference/link%2fLink#props-as) values.',
        },
      ],
      styles: {
        classes: [
          {
            ruleName: 'breadcrumbs',
            globalClass: '',
            description: 'Styles applied to the root element.',
          },
          {
            ruleName: 'separator',
            globalClass: '',
            description: 'Styles applied to the separators.',
          },
          {
            ruleName: 'current',
            globalClass: '',
            description: "Styles applied to the currently active breadcrumb's element.",
          },
        ],
        name: 'Breadcrumbs',
      },
      type: 'component',
      import: "import Breadcrumbs from 'react-storefront/Breadcrumbs'",
    },
    CartButton: {
      name: 'CartButton',
      filename: 'CartButton',
      importPath: 'CartButton',
      src:
        "import React from 'react'\nimport PropTypes from 'prop-types'\nimport Link from './link/Link'\nimport ToolbarButton from './ToolbarButton'\nimport { ShoppingCart as Cart } from '@material-ui/icons'\nimport { makeStyles } from '@material-ui/core/styles'\nimport { Badge } from '@material-ui/core'\nimport clsx from 'clsx'\n\nexport const styles = theme => ({\n  /**\n   * Styles applied to the [`Link`](/apiReference/link%2fLink) element used as the root.\n   */\n  link: {\n    color: 'inherit',\n  },\n  /**\n   * Styles passed through to the [`Badge`](https://material-ui.com/api/badge/#css) element's\n   * `badge` CSS rule.\n   */\n  badge: {\n    border: '2px solid white',\n    padding: '0 4px',\n  },\n  /**\n   * Styles applied to the button icon.\n   */\n  icon: {},\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFCartButton' })\n\n/**\n * A cart header button that display the number of items in the cart using a badge.\n *\n * Example:\n *\n * ```js\n * <CartButton href=\"/cart\" quantity={1} />\n * ```\n */\nexport default function CartButton({\n  classes,\n  href,\n  as,\n  server,\n  onClick,\n  icon,\n  quantity,\n  linkProps,\n  badgeProps,\n  buttonProps,\n}) {\n  classes = useStyles({ classes })\n  const cartIcon = icon || <Cart className={classes.icon} />\n\n  return (\n    <Link\n      {...linkProps.anchorProps}\n      className={clsx(classes.link, linkProps.className)}\n      href={href}\n      as={as}\n      server={server}\n      onClick={onClick}\n    >\n      <ToolbarButton {...buttonProps}>\n        <Badge\n          badgeContent={quantity}\n          {...badgeProps}\n          classes={{ ...badgeProps.classes, badge: classes.badge }}\n        >\n          {cartIcon}\n        </Badge>\n      </ToolbarButton>\n    </Link>\n  )\n}\n\nCartButton.propTypes = {\n  /**\n   * The url path to the cart page.\n   */\n  href: PropTypes.string,\n\n  /**\n   * Set to `true` to force server-side navigation.\n   */\n  server: PropTypes.bool,\n\n  /**\n   * Override or extend the styles applied to the component. See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object,\n\n  /**\n   * Optional custom cart icon.\n   */\n  icon: PropTypes.node,\n\n  /**\n   * Props passed through to the [`ToolbarButton`](/apiReference/ToolbarButton#props) element.\n   */\n  buttonProps: PropTypes.object,\n\n  /**\n   * Props passed through to the [`Badge`](https://material-ui.com/api/badge/#props) element.\n   */\n  badgeProps: PropTypes.object,\n\n  /**\n   * Props passed through to the [`Link`](/apiReference/link%2fLink#props) element.\n   */\n  linkProps: PropTypes.object,\n}\n\nCartButton.defaultProps = {\n  href: '/cart',\n  server: false,\n  badgeProps: {\n    color: 'primary',\n  },\n  buttonProps: {\n    ['aria-label']: 'Cart',\n    color: 'inherit',\n  },\n  linkProps: {\n    anchorProps: { 'data-th': 'cart-link' },\n  },\n}\n",
      description:
        'A cart header button that display the number of items in the cart using a badge.\n\nExample:\n\n```js\n<CartButton href="/cart" quantity={1} />\n```',
      displayName: 'CartButton',
      methods: [],
      props: [
        {
          name: 'href',
          type: { name: 'string' },
          required: false,
          description: 'The url path to the cart page.',
          defaultValue: { value: "'/cart'", computed: false },
        },
        {
          name: 'server',
          type: { name: 'bool' },
          required: false,
          description: 'Set to `true` to force server-side navigation.',
          defaultValue: { value: 'false', computed: false },
        },
        {
          name: 'classes',
          type: { name: 'object' },
          required: false,
          description:
            'Override or extend the styles applied to the component. See [CSS API](#css) below for more details.',
        },
        {
          name: 'icon',
          type: { name: 'node' },
          required: false,
          description: 'Optional custom cart icon.',
        },
        {
          name: 'buttonProps',
          type: { name: 'object' },
          required: false,
          description:
            'Props passed through to the [`ToolbarButton`](/apiReference/ToolbarButton#props) element.',
          defaultValue: {
            value: "{\n  ['aria-label']: 'Cart',\n  color: 'inherit',\n}",
            computed: false,
          },
        },
        {
          name: 'badgeProps',
          type: { name: 'object' },
          required: false,
          description:
            'Props passed through to the [`Badge`](https://material-ui.com/api/badge/#props) element.',
          defaultValue: { value: "{\n  color: 'primary',\n}", computed: false },
        },
        {
          name: 'linkProps',
          type: { name: 'object' },
          required: false,
          description:
            'Props passed through to the [`Link`](/apiReference/link%2fLink#props) element.',
          defaultValue: {
            value: "{\n  anchorProps: { 'data-th': 'cart-link' },\n}",
            computed: false,
          },
        },
      ],
      styles: {
        classes: [
          {
            ruleName: 'link',
            globalClass: '.RSFCartButton-link',
            description:
              'Styles applied to the [`Link`](/apiReference/link%2fLink) element used as the root.',
          },
          {
            ruleName: 'badge',
            globalClass: '.RSFCartButton-badge',
            description:
              "Styles passed through to the [`Badge`](https://material-ui.com/api/badge/#css) element's\n`badge` CSS rule.",
          },
          {
            ruleName: 'icon',
            globalClass: '.RSFCartButton-icon',
            description: 'Styles applied to the button icon.',
          },
        ],
        name: 'CartButton',
      },
      type: 'component',
      import: "import CartButton from 'react-storefront/CartButton'",
    },
    CmsSlot: {
      name: 'CmsSlot',
      filename: 'CmsSlot',
      importPath: 'CmsSlot',
      src:
        "import React, { useEffect, useRef } from 'react'\nimport clsx from 'clsx'\nimport PropTypes from 'prop-types'\nimport { makeStyles } from '@material-ui/core/styles'\nimport doLazyLoadImages from './utils/lazyLoadImages'\nimport { prefetchJsonFor } from './serviceWorker'\n\nexport const styles = theme => ({\n  inline: {\n    display: 'inline',\n  },\n  block: {\n    display: 'block',\n  },\n  root: {\n    '& .rsf-presized-img': {\n      position: 'relative',\n\n      '& img': {\n        position: 'absolute',\n        height: '100%',\n        width: '100%',\n        top: 0,\n        left: 0,\n      },\n    },\n    '& img[data-rsf-lazy]': {\n      visibility: 'hidden',\n    },\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFCmsSlot' })\n\n/**\n * A container for HTML blob content from a CMS.  Content is dangerously inserted into the DOM.\n * Pass the html as a string as the child of this component. Additional props are spread to the\n * rendered span element.\n */\nexport default function CmsSlot({\n  children,\n  className,\n  inline,\n  lazyLoadImages,\n  prefetchLinks,\n  ...others\n}) {\n  const classes = useStyles(others)\n  const el = useRef()\n\n  useEffect(() => {\n    try {\n      if (!el.current) return\n\n      if (lazyLoadImages) {\n        doLazyLoadImages(el.current)\n      }\n\n      if (prefetchLinks) {\n        const links = Array.from(el.current.querySelectorAll('a[data-rsf-prefetch=\"always\"]'))\n\n        for (let link of links) {\n          prefetchJsonFor(link.getAttribute('href'))\n        }\n      }\n    } catch (e) {\n      console.warn('error running side effects on CmsSlot', e)\n    }\n  }, [children])\n\n  return children ? (\n    <span\n      {...others}\n      ref={el}\n      className={clsx(className, classes.root, {\n        [classes.inline]: inline,\n        [classes.block]: !inline,\n      })}\n      dangerouslySetInnerHTML={{ __html: children }}\n    />\n  ) : null\n}\nCmsSlot.proptypes = {\n  /**\n   * If `true`, will use `display: inline` style.\n   */\n  inline: PropTypes.boolean,\n\n  /**\n   * If `true` to lazy load images that have been preprocessed with `$.lazyLoadImages()`.\n   */\n  lazyLoadImages: PropTypes.boolean,\n\n  /**\n   * If `true`, prefetch links that have a `data-rsf-prefetch` attribute.\n   */\n  prefetchLinks: false,\n}\n\nCmsSlot.defaultProps = {\n  lazyLoadImages: false,\n}\n",
      description:
        'A container for HTML blob content from a CMS.  Content is dangerously inserted into the DOM.\nPass the html as a string as the child of this component. Additional props are spread to the\nrendered span element.',
      displayName: 'CmsSlot',
      methods: [],
      props: [
        {
          name: 'lazyLoadImages',
          defaultValue: { value: 'false', computed: false },
          required: false,
        },
      ],
      styles: {
        classes: [
          {
            ruleName: 'inline',
            globalClass: '.RSFCmsSlot-inline',
            description: 'If `true`, will use `display: inline` style.',
          },
          { ruleName: 'block', globalClass: '.RSFCmsSlot-block', description: '' },
          { ruleName: 'root', globalClass: '.RSFCmsSlot-root', description: '' },
        ],
        name: 'CmsSlot',
      },
      type: 'component',
      import: "import CmsSlot from 'react-storefront/CmsSlot'",
    },
    ErrorBoundary: {
      name: 'ErrorBoundary',
      filename: 'ErrorBoundary',
      importPath: 'ErrorBoundary',
      src:
        "import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n\n/**\n * An internal component that catches errors durring rendering, sets the\n * error, stack, and page properties of the app state accordingly, and calls\n * the registered error reporter if one is configured.\n */\nexport default class ErrorBoundary extends Component {\n  static propTypes = {\n    /**\n     * A function to call whenever an error occurs.  The function is passed an\n     * object with `error` (the error message) and `stack` (the stack trace as a string).\n     */\n    onError: PropTypes.func,\n  }\n\n  static defaultProps = {\n    onError: Function.prototype,\n  }\n\n  static getDerivedStateFromError(error) {\n    return { error }\n  }\n\n  state = {\n    error: null,\n  }\n\n  componentDidMount() {\n    const { onError } = this.props\n\n    this.windowErrorEvent = window.addEventListener('error', event => {\n      onError({ error: event.error })\n    })\n\n    this.windowUnhandledRejectionEvent = window.addEventListener('unhandledrejection', event => {\n      onError({ error: event.reason })\n    })\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('error', this.windowErrorEvent)\n    window.removeEventListener('unhandledrejection', this.windowUnhandledRejectionEvent)\n  }\n\n  /**\n   * When an error is caught, call the error reporter and update the app state\n   * @param {Error} error\n   * @param {Object} info\n   */\n  componentDidCatch(error, info) {\n    const { onError } = this.props\n\n    // report the error\n    onError({ error })\n  }\n\n  render() {\n    if (this.state.error) {\n      return <div>{this.state.error.message}</div>\n    }\n\n    return this.props.children\n  }\n}\n",
      description:
        'An internal component that catches errors durring rendering, sets the\nerror, stack, and page properties of the app state accordingly, and calls\nthe registered error reporter if one is configured.',
      displayName: 'ErrorBoundary',
      methods: [],
      props: [
        {
          name: 'onError',
          type: { name: 'func' },
          required: false,
          description:
            'A function to call whenever an error occurs.  The function is passed an\nobject with `error` (the error message) and `stack` (the stack trace as a string).',
          defaultValue: { value: 'Function.prototype', computed: true },
        },
      ],
      styles: { classes: [], name: null },
      type: 'component',
      import: "import ErrorBoundary from 'react-storefront/ErrorBoundary'",
    },
    ExpandableSection: {
      name: 'ExpandableSection',
      filename: 'ExpandableSection',
      importPath: 'ExpandableSection',
      src:
        "import React from 'react'\nimport PropTypes from 'prop-types'\nimport clsx from 'clsx'\nimport {\n  ExpansionPanel,\n  ExpansionPanelDetails,\n  ExpansionPanelSummary,\n  Typography,\n} from '@material-ui/core'\nimport { ExpandMore as ExpandMoreIcon } from '@material-ui/icons'\nimport { makeStyles } from '@material-ui/core/styles'\nimport useStateFromProp from './hooks/useStateFromProp'\nimport withDefaultHandler from './utils/withDefaultHandler'\n\nexport const styles = theme => ({\n  /**\n   * Styles applied to the root element.\n   */\n  root: {\n    boxShadow: 'none',\n    borderBottom: `1px solid ${theme.palette.divider}`,\n    background: 'transparent',\n\n    '&::before': {\n      display: 'none',\n    },\n\n    '& > *:first-child': {\n      padding: '0',\n      minHeight: '0',\n    },\n  },\n\n  /**\n   * Styles applied to the root element if [`margins`](#prop-margins) is `true`.\n   */\n  margins: {\n    padding: `0 ${theme.spacing(2)}px`,\n  },\n\n  /**\n   * Styles applied to the caption element.\n   */\n  caption: {\n    transition: 'opacity .2s linear',\n  },\n\n  /**\n   * Styles applied to the caption element when the section is expanded.\n   */\n  expandedCaption: {\n    opacity: 0,\n  },\n\n  /**\n   * Styles applied to the body element of the expansion panel.\n   */\n  details: {\n    padding: theme.spacing(0, 0, 2, 0),\n    display: 'flex',\n    flexDirection: 'column',\n  },\n\n  /**\n   * Styles applied to the summary element of the expansion panel.\n   */\n  summary: {\n    '&:first-child': {\n      padding: theme.spacing(1, 0),\n    },\n  },\n\n  /**\n   * Styles applied to the content of the summary element of the expansion panel.\n   */\n  summaryContent: {\n    display: 'flex',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    margin: 0,\n    '[aria-expanded=true] > &': {\n      margin: '0 !important',\n    },\n  },\n\n  /**\n   * Styles applied to the summary element of the expansion panel when the section is expanded.\n   */\n  summaryExpanded: {},\n\n  /**\n   * Styles applied to the expand icon of the expansion panel when the section is expanded if the\n   * [`ExpandIcon`](#prop-ExpandIcon) is different than the [`CollapseIcon`](#prop-CollapseIcon).\n   */\n  expandIconExpanded: {},\n\n  /**\n   * Styles applied to the expand icon of the expansion panel when the [`ExpandIcon`](#prop-ExpandIcon)\n   * is different than the [`CollapseIcon`](#prop-CollapseIcon).\n   */\n  summaryIconWrap: {\n    right: 0,\n    padding: theme.spacing(0, 1),\n  },\n\n  /**\n   * Styles applied to the summary element of the expansion panel.\n   */\n  withCollapseIcon: {\n    transform: 'rotate(0deg) !important',\n  },\n\n  /**\n   * Styles applied to the root element when the section is expanded.\n   */\n  expandedPanel: {\n    '&$root': {\n      margin: 0,\n    },\n  },\n\n  /**\n   * Styles applied to the title element.\n   */\n  title: {},\n\n  /**\n   * Styles applied to the expand icon element.\n   */\n  expandIcon: {},\n  /**\n   * Styles applied to the collapse icon element.\n   */\n  collapseIcon: {},\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFExpandableSection' })\n\n/**\n * An expandable info section.  Example:\n *\n * ```js\n *  <ExpandableSection title=\"Help\" caption=\"Click here for more info\">\n *    <Typography>This is a help section</Typography>\n *  </ExpandableSection>\n * ```\n */\nexport default function ExpandableSection(props) {\n  let {\n    classes,\n    children = [],\n    title,\n    caption,\n    expanded,\n    defaultExpanded,\n    ExpandIcon,\n    CollapseIcon,\n    margins,\n    onChange,\n    ...others\n  } = props\n\n  classes = useStyles({ classes })\n\n  const [expandedState, setExpandedState] = useStateFromProp(expanded || defaultExpanded || false)\n\n  /**\n   * Gets the classes for the ExpansionPanelSummary\n   * Here we add a class to remove the rotate transform if we're using a\n   * separate icon for the collapse state.\n   */\n  function getSummaryClasses() {\n    const result = {\n      root: clsx({ [classes.summary]: true, [classes.summaryExpanded]: expandedState }),\n      content: classes.summaryContent,\n      expandIcon: clsx({\n        [classes.summaryIconWrap]: true,\n        [classes.expandIconExpanded]: expandedState,\n      }),\n    }\n\n    if (CollapseIcon !== ExpandIcon) {\n      result.expandIcon = classes.withCollapseIcon\n    }\n\n    return result\n  }\n\n  const handleChange = withDefaultHandler(onChange, (e, expanded) => {\n    if (props.expanded == null) {\n      setExpandedState(expanded)\n    }\n  })\n\n  return (\n    <ExpansionPanel\n      classes={{\n        root: clsx({\n          [classes.root]: true,\n          [classes.margins]: margins,\n        }),\n        expanded: classes.expandedPanel,\n      }}\n      expanded={expandedState}\n      defaultExpanded={defaultExpanded}\n      {...others}\n      onChange={handleChange}\n    >\n      <ExpansionPanelSummary\n        expandIcon={\n          expandedState ? (\n            <CollapseIcon className={classes.collapseIcon} />\n          ) : (\n            <ExpandIcon className={classes.expandIcon} />\n          )\n        }\n        classes={getSummaryClasses()}\n      >\n        <Typography variant=\"subtitle1\" className={classes.title}>\n          {title}\n        </Typography>\n        {caption && (\n          <Typography\n            variant=\"caption\"\n            className={clsx({\n              [classes.caption]: true,\n              [classes.expandedCaption]: expandedState,\n            })}\n          >\n            {caption}\n          </Typography>\n        )}\n      </ExpansionPanelSummary>\n      <ExpansionPanelDetails classes={{ root: classes.details }}>{children}</ExpansionPanelDetails>\n    </ExpansionPanel>\n  )\n}\n\nExpandableSection.propTypes = {\n  /**\n   * The title for the header of the expandable section.\n   */\n  title: PropTypes.oneOfType([PropTypes.string, PropTypes.element]),\n\n  /**\n   * Text to display to the right of the heading.\n   */\n  caption: PropTypes.oneOfType([PropTypes.string, PropTypes.element]),\n\n  /**\n   * The icon to use for collapsed groups.\n   */\n  ExpandIcon: PropTypes.object,\n\n  /**\n   * The icon to use for expanded groups.\n   */\n  CollapseIcon: PropTypes.object,\n\n  /**\n   * If `false`, the default left and right margins are removed.\n   */\n  margins: PropTypes.bool,\n\n  /**\n   * Controls the expanded state.\n   */\n  expanded: PropTypes.bool,\n\n  /**\n   * Defaults the panel to being expanded, without controlling the state.\n   */\n  defaultExpanded: PropTypes.bool,\n}\n\nExpandableSection.defaultProps = {\n  margins: true,\n  expanded: false,\n  defaultExpanded: false,\n  ExpandIcon: ExpandMoreIcon,\n  CollapseIcon: ExpandMoreIcon,\n}\n",
      description:
        'An expandable info section.  Example:\n\n```js\n <ExpandableSection title="Help" caption="Click here for more info">\n   <Typography>This is a help section</Typography>\n </ExpandableSection>\n```',
      displayName: 'ExpandableSection',
      methods: [],
      props: [
        {
          name: 'title',
          type: { name: 'union', value: [{ name: 'string' }, { name: 'element' }] },
          required: false,
          description: 'The title for the header of the expandable section.',
        },
        {
          name: 'caption',
          type: { name: 'union', value: [{ name: 'string' }, { name: 'element' }] },
          required: false,
          description: 'Text to display to the right of the heading.',
        },
        {
          name: 'ExpandIcon',
          type: { name: 'object' },
          required: false,
          description: 'The icon to use for collapsed groups.',
          defaultValue: { value: 'ExpandMoreIcon', computed: true },
        },
        {
          name: 'CollapseIcon',
          type: { name: 'object' },
          required: false,
          description: 'The icon to use for expanded groups.',
          defaultValue: { value: 'ExpandMoreIcon', computed: true },
        },
        {
          name: 'margins',
          type: { name: 'bool' },
          required: false,
          description: 'If `false`, the default left and right margins are removed.',
          defaultValue: { value: 'true', computed: false },
        },
        {
          name: 'expanded',
          type: { name: 'bool' },
          required: false,
          description: 'Controls the expanded state.',
          defaultValue: { value: 'false', computed: false },
        },
        {
          name: 'defaultExpanded',
          type: { name: 'bool' },
          required: false,
          description: 'Defaults the panel to being expanded, without controlling the state.',
          defaultValue: { value: 'false', computed: false },
        },
      ],
      styles: {
        classes: [
          {
            ruleName: 'root',
            globalClass: '.RSFExpandableSection-root',
            description: 'Styles applied to the root element.',
          },
          {
            ruleName: 'margins',
            globalClass: '.RSFExpandableSection-margins',
            description:
              'Styles applied to the root element if [`margins`](#prop-margins) is `true`.',
          },
          {
            ruleName: 'caption',
            globalClass: '.RSFExpandableSection-caption',
            description: 'Styles applied to the caption element.',
          },
          {
            ruleName: 'expandedCaption',
            globalClass: '.RSFExpandableSection-expandedCaption',
            description: 'Styles applied to the caption element when the section is expanded.',
          },
          {
            ruleName: 'details',
            globalClass: '.RSFExpandableSection-details',
            description: 'Styles applied to the body element of the expansion panel.',
          },
          {
            ruleName: 'summary',
            globalClass: '.RSFExpandableSection-summary',
            description: 'Styles applied to the summary element of the expansion panel.',
          },
          {
            ruleName: 'summaryContent',
            globalClass: '.RSFExpandableSection-summaryContent',
            description:
              'Styles applied to the content of the summary element of the expansion panel.',
          },
          {
            ruleName: 'summaryExpanded',
            globalClass: '.RSFExpandableSection-summaryExpanded',
            description:
              'Styles applied to the summary element of the expansion panel when the section is expanded.',
          },
          {
            ruleName: 'expandIconExpanded',
            globalClass: '.RSFExpandableSection-expandIconExpanded',
            description:
              'Styles applied to the expand icon of the expansion panel when the section is expanded if the\n[`ExpandIcon`](#prop-ExpandIcon) is different than the [`CollapseIcon`](#prop-CollapseIcon).',
          },
          {
            ruleName: 'summaryIconWrap',
            globalClass: '.RSFExpandableSection-summaryIconWrap',
            description:
              'Styles applied to the expand icon of the expansion panel when the [`ExpandIcon`](#prop-ExpandIcon)\nis different than the [`CollapseIcon`](#prop-CollapseIcon).',
          },
          {
            ruleName: 'withCollapseIcon',
            globalClass: '.RSFExpandableSection-withCollapseIcon',
            description: 'Styles applied to the summary element of the expansion panel.',
          },
          {
            ruleName: 'expandedPanel',
            globalClass: '.RSFExpandableSection-expandedPanel',
            description: 'Styles applied to the root element when the section is expanded.',
          },
          {
            ruleName: 'title',
            globalClass: '.RSFExpandableSection-title',
            description: 'Styles applied to the title element.',
          },
          {
            ruleName: 'expandIcon',
            globalClass: '.RSFExpandableSection-expandIcon',
            description: 'Styles applied to the expand icon element.',
          },
          {
            ruleName: 'collapseIcon',
            globalClass: '.RSFExpandableSection-collapseIcon',
            description: 'Styles applied to the collapse icon element.',
          },
        ],
        name: 'ExpandableSection',
      },
      type: 'component',
      import: "import ExpandableSection from 'react-storefront/ExpandableSection'",
    },
    Fill: {
      name: 'Fill',
      filename: 'Fill',
      importPath: 'Fill',
      src:
        "import React, { Children } from 'react'\nimport { makeStyles } from '@material-ui/core/styles'\nimport clsx from 'clsx'\nimport PropTypes from 'prop-types'\n\nconst useStyles = makeStyles(theme => ({\n  /**\n   * Styles applied to the root element.\n   */\n  root: {\n    position: 'relative',\n    width: '100%',\n  },\n  /**\n   * Styles applied to the wrapper element for the children.\n   */\n  child: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: '100%',\n    '& > *': {\n      width: '100%',\n      height: '100%',\n    },\n  },\n}))\n\n/**\n * This component sizes the height of the child element as a percentage of its width.  It expects\n * only a single child.\n *\n * Example:\n *\n * ```js\n *  <Fill height=\"100%\">\n *    <div>this element's height will be the same as its width.</div>\n *  </Fill>\n * ```\n */\nexport default function Fill({ height, children, className, ...props }) {\n  children = Children.only(children)\n\n  if (height == null) {\n    return children\n  }\n\n  const classes = useStyles()\n\n  return (\n    <div className={clsx(classes.root, className)} {...props}>\n      <div style={{ paddingTop: height }} />\n      <div className={classes.child}>{children}</div>\n    </div>\n  )\n}\n\nFill.propTypes = {\n  /**\n   * The height as a percentage of the width in a css compatible expression.  For example:\n   * \"100%\" or \"calc(100% + 50px)\", etc...  If omitted, this component does nothing except render\n   * the provided child.\n   */\n  height: PropTypes.string,\n}\n",
      description:
        'This component sizes the height of the child element as a percentage of its width.  It expects\nonly a single child.\n\nExample:\n\n```js\n <Fill height="100%">\n   <div>this element\'s height will be the same as its width.</div>\n </Fill>\n```',
      displayName: 'Fill',
      methods: [],
      props: [
        {
          name: 'height',
          type: { name: 'string' },
          required: false,
          description:
            'The height as a percentage of the width in a css compatible expression.  For example:\n"100%" or "calc(100% + 50px)", etc...  If omitted, this component does nothing except render\nthe provided child.',
        },
      ],
      styles: { classes: [], name: null },
      type: 'component',
      import: "import Fill from 'react-storefront/Fill'",
    },
    ForwardThumbnail: {
      name: 'ForwardThumbnail',
      filename: 'ForwardThumbnail',
      importPath: 'ForwardThumbnail',
      src:
        "import React, { useCallback, useRef, useContext, useEffect } from 'react'\nimport PWAContext from './PWAContext'\n\n/**\n * Wrap product links in this component to reuse the thumbnail as the main image in the product\n * skeleton when transitioning to the PDP to make the transition feel instance. This component\n * sets the `thumbnail` ref on the provided `PWAContext` to the `src` prop of the first `img`\n * element found amongst the descendant elements in the tree.\n *\n * Example:\n *\n * ```js\n *  <ForwardThumbnail>\n *    <Link href=\"/p/[productId]\" as={product.url}>\n *      <a>\n *        <Image src={product.media.thumbnail.src} alt={product.media.thumbnail.alt} />\n *        <div>{product.name}</div>\n *      </a>\n *    </Link>\n *  </ForwardThumbnail>\n * ```\n */\nexport default function ForwardThumbnail({ children }) {\n  const ref = useRef(null)\n  const context = useContext(PWAContext)\n  const srcRef = useRef(null)\n\n  useEffect(() => {\n    srcRef.current = ref.current.querySelector('img').getAttribute('src')\n  }, [children])\n\n  const handleClick = useCallback(() => {\n    context.thumbnail.current = { src: srcRef.current }\n  }, [])\n\n  return (\n    <div ref={ref} onClick={handleClick}>\n      {children}\n    </div>\n  )\n}\n",
      description:
        'Wrap product links in this component to reuse the thumbnail as the main image in the product\nskeleton when transitioning to the PDP to make the transition feel instance. This component\nsets the `thumbnail` ref on the provided `PWAContext` to the `src` prop of the first `img`\nelement found amongst the descendant elements in the tree.\n\nExample:\n\n```js\n <ForwardThumbnail>\n   <Link href="/p/[productId]" as={product.url}>\n     <a>\n       <Image src={product.media.thumbnail.src} alt={product.media.thumbnail.alt} />\n       <div>{product.name}</div>\n     </a>\n   </Link>\n </ForwardThumbnail>\n```',
      displayName: 'ForwardThumbnail',
      methods: [],
      styles: { classes: [], name: null },
      props: [],
      type: 'component',
      import: "import ForwardThumbnail from 'react-storefront/ForwardThumbnail'",
    },
    Image: {
      name: 'Image',
      filename: 'Image',
      importPath: 'Image',
      src:
        "import React, { useState, useRef, useEffect, useContext } from 'react'\nimport PropTypes from 'prop-types'\nimport clsx from 'clsx'\nimport VisibilitySensor from 'react-visibility-sensor'\nimport { makeStyles } from '@material-ui/core/styles'\nimport PWAContext from './PWAContext'\n\nexport const styles = theme => ({\n  /**\n   * Styles applied to the root element.\n   */\n  root: {\n    position: 'relative',\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'center',\n    // Without a minimum height and width, the container will not fire\n    // the visibility change\n    minHeight: 1,\n    minWidth: 1,\n  },\n  /**\n   * Styles applied to the image element.\n   */\n  image: {},\n  /**\n   * Styles applied to the image element when [`aspectRatio`](#prop-aspectRatio) is defined.\n   */\n  fit: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n    display: 'block',\n    width: '100%',\n    height: '100%',\n  },\n  /**\n   * Styles applied to the root element when [`contain`](#prop-contain) is `true`.\n   */\n  contain: {\n    '& img': {\n      objectFit: 'contain',\n      maxHeight: '100%',\n      maxWidth: '100%',\n    },\n  },\n  /**\n   * Styles applied to the root element when [`fill`](#prop-fill) is `true`.\n   */\n  fill: {\n    width: '100%',\n    height: '100%',\n    '& img': {\n      display: 'block',\n      objectFit: 'contain',\n      maxHeight: '100%',\n      maxWidth: '100%',\n      width: '100%',\n      height: '100%',\n    },\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFImage' })\n\n/**\n * Displays an image that can be lazy loaded and made to auto-scale to fit the parent element\n * by setting the `fill` prop, or grow/shrink while maintaining a given aspect ratio\n * by setting the `aspectRatio` prop.\n */\nexport default function Image({\n  lazy,\n  lazyOffset,\n  notFoundSrc,\n  height,\n  width,\n  fill,\n  bind,\n  contain,\n  classes,\n  className,\n  aspectRatio,\n  alt,\n  src,\n  amp,\n  optimize,\n  onChange,\n  onSrcChange,\n  onAltChange,\n  value,\n  ImgElement,\n  ...imgAttributes\n}) {\n  function lazyLoad(visible) {\n    if (!loaded && visible) {\n      setLoaded(true)\n    }\n  }\n\n  classes = useStyles({ classes })\n\n  const { hydrating } = useContext(PWAContext) || {}\n  const [loaded, setLoaded] = useState(lazy === false || (lazy === 'ssr' && !hydrating))\n  const [primaryNotFound, setPrimaryNotFound] = useState(false)\n  const ref = useRef()\n\n  useEffect(() => {\n    const img = ref.current\n    if (img && img.complete && img.naturalWidth === 0) {\n      setPrimaryNotFound(true)\n    }\n  }, [])\n\n  if (src == null) return null\n\n  contain = contain || aspectRatio\n\n  if (primaryNotFound && notFoundSrc) {\n    src = notFoundSrc\n  }\n\n  let result = (\n    <div\n      className={clsx(className, {\n        [classes.root]: true,\n        [classes.contain]: contain,\n        [classes.fill]: fill,\n      })}\n    >\n      {aspectRatio && <div style={{ paddingTop: `${aspectRatio * 100}%` }} />}\n      {loaded && (\n        <ImgElement\n          ref={ref}\n          src={src}\n          key={src}\n          height={height}\n          width={width}\n          alt={alt}\n          className={clsx({\n            [classes.image]: true,\n            [classes.fit]: aspectRatio != null,\n          })}\n          {...imgAttributes}\n          onError={() => setPrimaryNotFound(true)}\n        />\n      )}\n    </div>\n  )\n\n  result = (\n    <VisibilitySensor\n      active={!loaded}\n      onChange={lazyLoad}\n      partialVisibility\n      offset={{ top: -lazyOffset, bottom: -lazyOffset }}\n    >\n      {result}\n    </VisibilitySensor>\n  )\n\n  return result\n}\n\nImage.propTypes = {\n  /**\n   * The URL for the image.\n   */\n  src: PropTypes.string,\n\n  /**\n   * The URL of the image to use in case the primary image fails to load.\n   */\n  notFoundSrc: PropTypes.string,\n\n  /**\n   * The ratio of height/width as a float.  For example: `1` when the height and width match,\n   * `0.5` when height is half of the width.\n   */\n  aspectRatio: PropTypes.number,\n\n  /**\n   * Set to `true` to apply object-fit:contain to the image so that it automatically\n   * fits within the element's height and width.\n   */\n  contain: PropTypes.bool,\n\n  /**\n   * The same as `contain`, except images are stretched to fill the element's height and width.\n   */\n  fill: PropTypes.bool,\n\n  /**\n   * Set to `true` to wait until the image enters the viewport before loading it. Set to `\"ssr\"` to\n   * only lazy load images during server side rendering.\n   */\n  lazy: PropTypes.oneOf(['ssr', true, false]),\n\n  /**\n   * Sets the minimum amount of pixels the image can be scrolled out of view before it\n   * is lazy loaded.  You must set `lazy` in order for this setting to take effect.\n   */\n  lazyOffset: PropTypes.number,\n}\n\nImage.defaultProps = {\n  contain: false,\n  fill: false,\n  lazy: false,\n  lazyOffset: 100,\n  ImgElement: 'img',\n}\n",
      description:
        'Displays an image that can be lazy loaded and made to auto-scale to fit the parent element\nby setting the `fill` prop, or grow/shrink while maintaining a given aspect ratio\nby setting the `aspectRatio` prop.',
      displayName: 'Image',
      methods: [],
      props: [
        {
          name: 'notFoundSrc',
          type: { name: 'string' },
          required: false,
          description: 'The URL of the image to use in case the primary image fails to load.',
        },
        {
          name: 'aspectRatio',
          type: { name: 'number' },
          required: false,
          description:
            'The ratio of height/width as a float.  For example: `1` when the height and width match,\n`0.5` when height is half of the width.',
        },
        {
          name: 'contain',
          type: { name: 'bool' },
          required: false,
          description:
            "Set to `true` to apply object-fit:contain to the image so that it automatically\nfits within the element's height and width.",
          defaultValue: { value: 'false', computed: false },
        },
        {
          name: 'fill',
          type: { name: 'bool' },
          required: false,
          description:
            "The same as `contain`, except images are stretched to fill the element's height and width.",
          defaultValue: { value: 'false', computed: false },
        },
        {
          name: 'lazy',
          type: {
            name: 'enum',
            value: [
              { value: "'ssr'", computed: false },
              { value: 'true', computed: false },
              { value: 'false', computed: false },
            ],
          },
          required: false,
          description:
            'Set to `true` to wait until the image enters the viewport before loading it. Set to `"ssr"` to\nonly lazy load images during server side rendering.',
          defaultValue: { value: 'false', computed: false },
        },
        {
          name: 'lazyOffset',
          type: { name: 'number' },
          required: false,
          description:
            'Sets the minimum amount of pixels the image can be scrolled out of view before it\nis lazy loaded.  You must set `lazy` in order for this setting to take effect.',
          defaultValue: { value: '100', computed: false },
        },
        { name: 'ImgElement', defaultValue: { value: "'img'", computed: false }, required: false },
      ],
      styles: {
        classes: [
          {
            ruleName: 'root',
            globalClass: '.RSFImage-root',
            description: 'Styles applied to the root element.',
          },
          {
            ruleName: 'image',
            globalClass: '.RSFImage-image',
            description: 'Styles applied to the image element.',
          },
          {
            ruleName: 'fit',
            globalClass: '.RSFImage-fit',
            description:
              'Styles applied to the image element when [`aspectRatio`](#prop-aspectRatio) is defined.',
          },
          {
            ruleName: 'contain',
            globalClass: '.RSFImage-contain',
            description:
              'Styles applied to the root element when [`contain`](#prop-contain) is `true`.',
          },
          {
            ruleName: 'fill',
            globalClass: '.RSFImage-fill',
            description: 'Styles applied to the root element when [`fill`](#prop-fill) is `true`.',
          },
        ],
        name: 'Image',
      },
      type: 'component',
      import: "import Image from 'react-storefront/Image'",
    },
    Label: {
      name: 'Label',
      filename: 'Label',
      importPath: 'Label',
      src:
        "import PropTypes from 'prop-types'\nimport React from 'react'\nimport clsx from 'clsx'\nimport { Typography } from '@material-ui/core'\nimport { makeStyles } from '@material-ui/core/styles'\n\nconst styles = theme => ({\n  /**\n   * Styles applied to the root element\\.\n   */\n  root: {\n    fontWeight: 500,\n    marginRight: 10,\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFLabel' })\n\nexport default function Label({ classes, className, ...props }) {\n  classes = useStyles({ classes })\n  return <Typography {...props} className={clsx(className, classes.root)} />\n}\n\nLabel.propTypes = {\n  /**\n   * Override or extend the styles applied to the component. See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object,\n  /**\n   * CSS class to apply to the root element\n   */\n  className: PropTypes.string,\n}\n",
      description: '',
      displayName: 'Label',
      methods: [],
      props: [
        {
          name: 'classes',
          type: { name: 'object' },
          required: false,
          description:
            'Override or extend the styles applied to the component. See [CSS API](#css) below for more details.',
        },
        {
          name: 'className',
          type: { name: 'string' },
          required: false,
          description: 'CSS class to apply to the root element',
        },
      ],
      styles: { classes: [], name: null },
      type: 'component',
      import: "import Label from 'react-storefront/Label'",
    },
    Lazy: {
      name: 'Lazy',
      filename: 'Lazy',
      importPath: 'Lazy',
      src:
        "import React, { useContext, useState } from 'react'\nimport ReactVisibilitySensor from 'react-visibility-sensor'\nimport clsx from 'clsx'\nimport { makeStyles } from '@material-ui/core/styles'\nimport PWAContext from './PWAContext'\nimport PropTypes from 'prop-types'\nimport { useAmp } from 'next/amp'\n\nexport const styles = () => ({\n  /**\n   * Styles applied to the root element.\n   */\n  root: {\n    minHeight: 1,\n    minWidth: 1,\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFLazy' })\n\n/**\n * Defers the rendering of children until the component is visible in the viewport. When\n * using Lazy we recommend assigning a CSS class that defines minHeight and minWidth to prevent\n * layout instability when children are lazy loaded.\n *\n * You can use `<Lazy ssrOnly>` to only implement lazy behavior during server side rendering.\n *\n * Example:\n *\n * ```js\n * <Lazy style={{ minHeight: 200 }}>\n *   <SomeExpensiveComponent/>\n * </Lazy>\n * ```\n */\nexport default function Lazy({ ssrOnly, className, classes, children, ...otherProps }) {\n  const amp = useAmp()\n  const { hydrating } = useContext(PWAContext)\n  const [visible, setVisible] = useState(amp || (ssrOnly && !hydrating))\n  classes = useStyles({ classes })\n\n  function onChange(v) {\n    if (!visible && v) {\n      setVisible(true)\n    }\n  }\n\n  return (\n    <ReactVisibilitySensor onChange={onChange} active={!visible} partialVisibility>\n      <div className={clsx(classes.root, className)} {...otherProps}>\n        {visible && children}\n      </div>\n    </ReactVisibilitySensor>\n  )\n}\n\nLazy.propTypes = {\n  /**\n   * Override or extend the styles applied to the component. See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object,\n  /**\n   * CSS class to apply to the root element\n   */\n  className: PropTypes.string,\n  /**\n   * Set to `true` to render children immediately when this component is mounted after initial hydration.\n   */\n  ssrOnly: PropTypes.bool,\n}\n\nLazy.defaultProps = {\n  ssrOnly: false,\n}\n",
      description:
        'Defers the rendering of children until the component is visible in the viewport. When\nusing Lazy we recommend assigning a CSS class that defines minHeight and minWidth to prevent\nlayout instability when children are lazy loaded.\n\nYou can use `<Lazy ssrOnly>` to only implement lazy behavior during server side rendering.\n\nExample:\n\n```js\n<Lazy style={{ minHeight: 200 }}>\n  <SomeExpensiveComponent/>\n</Lazy>\n```',
      displayName: 'Lazy',
      methods: [],
      props: [
        {
          name: 'classes',
          type: { name: 'object' },
          required: false,
          description:
            'Override or extend the styles applied to the component. See [CSS API](#css) below for more details.',
        },
        {
          name: 'className',
          type: { name: 'string' },
          required: false,
          description: 'CSS class to apply to the root element',
        },
        {
          name: 'ssrOnly',
          type: { name: 'bool' },
          required: false,
          description:
            'Set to `true` to render children immediately when this component is mounted after initial hydration.',
          defaultValue: { value: 'false', computed: false },
        },
      ],
      styles: {
        classes: [
          {
            ruleName: 'root',
            globalClass: '.RSFLazy-root',
            description: 'Styles applied to the root element.',
          },
        ],
        name: 'Lazy',
      },
      type: 'component',
      import: "import Lazy from 'react-storefront/Lazy'",
    },
    LoadMask: {
      name: 'LoadMask',
      filename: 'LoadMask',
      importPath: 'LoadMask',
      src:
        "import React, { useEffect } from 'react'\nimport clsx from 'clsx'\nimport PropTypes from 'prop-types'\nimport { makeStyles } from '@material-ui/core/styles'\nimport { CircularProgress } from '@material-ui/core'\n\nexport const styles = theme => ({\n  /**\n   * Styles applied to the root element.\n   */\n  root: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    height: '100%',\n    width: '100%',\n    display: 'none',\n    justifyContent: 'center',\n    alignItems: 'center',\n    background: theme.palette.background.default,\n    zIndex: 1,\n  },\n  /**\n   * Styles applied to the root element when [`fullscreen`](#prop-fullscreen) is `true`.\n   */\n  fullscreen: {\n    height: `calc(100vh - ${theme.loadMaskOffsetTop}px)`,\n    bottom: 'initial',\n    zIndex: theme.zIndex.modal - 20,\n    'body.moov-amp &': {\n      position: 'fixed',\n      marginTop: 0,\n      opacity: 0.8,\n    },\n  },\n  /**\n   * Styles applied to the root element when [`transparent`](#prop-transparent) is `true`.\n   */\n  transparent: {\n    backgroundColor: 'rgba(255,255,255,0.5)',\n  },\n  /**\n   * Styles applied to the root element when [`align`](#prop-align) is `'top'`.\n   */\n  alignTop: {\n    alignItems: 'flex-start',\n    paddingTop: '200px',\n  },\n  /**\n   * Styles applied to the root element when [`show`](#prop-show) is `true`.\n   */\n  show: {\n    display: 'flex',\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFLoadMask' })\n\n/**\n * A load mask to display when fetching data from the server.\n */\nexport default function LoadMask({\n  classes,\n  show,\n  style,\n  className,\n  children,\n  fullscreen,\n  transparent,\n  align,\n}) {\n  classes = useStyles({ classes })\n\n  useEffect(() => {\n    if (fullscreen) {\n      document.body.style.overflow = show ? 'hidden' : 'visible'\n    }\n  }, [show, fullscreen])\n\n  useEffect(() => () => {\n    if (fullscreen) {\n      document.body.style.overflow = 'visible'\n    }\n  })\n\n  return (\n    <div\n      style={style}\n      className={clsx({\n        [classes.root]: true,\n        [className]: className != null,\n        [classes.show]: show !== false,\n        [classes.fullscreen]: fullscreen,\n        [classes.transparent]: transparent,\n        [classes.alignTop]: align === 'top',\n      })}\n    >\n      {children || <CircularProgress className={classes.progress} color=\"secondary\" />}\n    </div>\n  )\n}\n\nLoadMask.propTypes = {\n  /**\n   * Override or extend the styles applied to the component. See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object,\n\n  /**\n   * Set to `true` to display the load mask, otherwise it will be hidden.\n   */\n  show: PropTypes.bool,\n\n  /**\n   * Set to `true` to toggle the overflow style on the body when showing.\n   */\n  fullscreen: PropTypes.bool,\n\n  /**\n   * Set to `true` to show partially background through the load mask\n   */\n  transparent: PropTypes.bool,\n\n  /**\n   * Set to `'top'` to show the spinner near the top.\n   */\n  align: PropTypes.oneOf(['center', 'top']),\n}\n\nLoadMask.defaultProps = {\n  show: false,\n  fullscreen: false,\n  transparent: false,\n  align: 'center',\n}\n",
      description: 'A load mask to display when fetching data from the server.',
      displayName: 'LoadMask',
      methods: [],
      props: [
        {
          name: 'classes',
          type: { name: 'object' },
          required: false,
          description:
            'Override or extend the styles applied to the component. See [CSS API](#css) below for more details.',
        },
        {
          name: 'show',
          type: { name: 'bool' },
          required: false,
          description: 'Set to `true` to display the load mask, otherwise it will be hidden.',
          defaultValue: { value: 'false', computed: false },
        },
        {
          name: 'fullscreen',
          type: { name: 'bool' },
          required: false,
          description: 'Set to `true` to toggle the overflow style on the body when showing.',
          defaultValue: { value: 'false', computed: false },
        },
        {
          name: 'transparent',
          type: { name: 'bool' },
          required: false,
          description: 'Set to `true` to show partially background through the load mask',
          defaultValue: { value: 'false', computed: false },
        },
        {
          name: 'align',
          type: {
            name: 'enum',
            value: [
              { value: "'center'", computed: false },
              { value: "'top'", computed: false },
            ],
          },
          required: false,
          description: "Set to `'top'` to show the spinner near the top.",
          defaultValue: { value: "'center'", computed: false },
        },
      ],
      styles: {
        classes: [
          {
            ruleName: 'root',
            globalClass: '.RSFLoadMask-root',
            description: 'Styles applied to the root element.',
          },
          {
            ruleName: 'fullscreen',
            globalClass: '.RSFLoadMask-fullscreen',
            description:
              'Styles applied to the root element when [`fullscreen`](#prop-fullscreen) is `true`.',
          },
          {
            ruleName: 'transparent',
            globalClass: '.RSFLoadMask-transparent',
            description:
              'Styles applied to the root element when [`transparent`](#prop-transparent) is `true`.',
          },
          {
            ruleName: 'alignTop',
            globalClass: '.RSFLoadMask-alignTop',
            description:
              "Styles applied to the root element when [`align`](#prop-align) is `'top'`.",
          },
          {
            ruleName: 'show',
            globalClass: '.RSFLoadMask-show',
            description: 'Styles applied to the root element when [`show`](#prop-show) is `true`.',
          },
        ],
        name: 'LoadMask',
      },
      type: 'component',
      import: "import LoadMask from 'react-storefront/LoadMask'",
    },
    NoScript: {
      name: 'NoScript',
      filename: 'NoScript',
      importPath: 'NoScript',
      src:
        "import React from 'react'\n\n/**\n * A simple wrapper for HTML noscript that is testable in enzyme.  This is\n * needed since enzyme won't render the contents of a noscript element.\n * @param {*} props\n */\nexport default function NoScript(props) {\n  if (process.env.NODE_ENV === 'test') {\n    return <div {...props} />\n  } else {\n    return <noscript {...props} />\n  }\n}\n",
      description:
        "A simple wrapper for HTML noscript that is testable in enzyme.  This is\nneeded since enzyme won't render the contents of a noscript element.\n@param {*} props",
      displayName: 'NoScript',
      methods: [],
      styles: { classes: [], name: null },
      props: [],
      type: 'component',
      import: "import NoScript from 'react-storefront/NoScript'",
    },
    Offline: {
      name: 'Offline',
      filename: 'Offline',
      importPath: 'Offline',
      src:
        "import React from 'react'\nimport { makeStyles } from '@material-ui/core/styles'\nimport { Typography } from '@material-ui/core'\nimport { CloudOff as CloseOffIcon } from '@material-ui/icons'\nimport PropTypes from 'prop-types'\n\nconst styles = theme => ({\n  /**\n   * Styles applied to the root element.\n   */\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n    width: '100%',\n    alignItems: 'center',\n    marginTop: '40px',\n    color: '#999',\n  },\n  /**\n   * Styles applied to the icon element.\n   */\n  icon: {\n    fontSize: 60,\n    color: '#999',\n  },\n  /**\n   * Styles applied to the heading element.\n   */\n  heading: {},\n  /**\n   * Styles applied to the message element.\n   */\n  message: {},\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFOffline' })\n\n/**\n * A page to display when in Offline mode\n */\nexport default function Offline({ classes, heading, message, Icon }) {\n  classes = useStyles({ classes })\n\n  return (\n    <div className={classes.root}>\n      <Icon className={classes.icon} />\n      <Typography variant=\"h6\" component=\"h1\" className={classes.heading}>\n        {heading}\n      </Typography>\n      <Typography variant=\"caption\" className={classes.message}>\n        {message}\n      </Typography>\n    </div>\n  )\n}\n\nOffline.propTypes = {\n  /**\n   * Override or extend the styles applied to the component. See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object,\n\n  /**\n   * Text (or an element) to display as the heading.\n   */\n  heading: PropTypes.oneOfType([PropTypes.string, PropTypes.element]),\n\n  /**\n   * Text (or an element) to display as the message.\n   */\n  message: PropTypes.oneOfType([PropTypes.string, PropTypes.element]),\n\n  /**\n   * An icon to display.\n   */\n  Icon: PropTypes.func,\n}\n\nOffline.defaultProps = {\n  heading: \"You're offline\",\n  message: 'Please check your internet connection',\n  Icon: () => <CloseOffIcon />,\n}\n",
      description: 'A page to display when in Offline mode',
      displayName: 'Offline',
      methods: [],
      props: [
        {
          name: 'classes',
          type: { name: 'object' },
          required: false,
          description:
            'Override or extend the styles applied to the component. See [CSS API](#css) below for more details.',
        },
        {
          name: 'heading',
          type: { name: 'union', value: [{ name: 'string' }, { name: 'element' }] },
          required: false,
          description: 'Text (or an element) to display as the heading.',
          defaultValue: { value: '"You\'re offline"', computed: false },
        },
        {
          name: 'message',
          type: { name: 'union', value: [{ name: 'string' }, { name: 'element' }] },
          required: false,
          description: 'Text (or an element) to display as the message.',
          defaultValue: { value: "'Please check your internet connection'", computed: false },
        },
        {
          name: 'Icon',
          type: { name: 'func' },
          required: false,
          description: 'An icon to display.',
          defaultValue: { value: '() => <CloseOffIcon />', computed: false },
        },
      ],
      styles: { classes: [], name: null },
      type: 'component',
      import: "import Offline from 'react-storefront/Offline'",
    },
    PWA: {
      name: 'PWA',
      filename: 'PWA',
      importPath: 'PWA',
      src:
        "import React, { useEffect, useMemo, useRef } from 'react'\nimport PWAContext from './PWAContext'\nimport PropTypes from 'prop-types'\nimport ErrorBoundary from './ErrorBoundary'\nimport { makeStyles } from '@material-ui/core/styles'\nimport LinkContextProvider from './link/LinkContextProvider'\nimport useSimpleNavigation from './router/useSimpleNavigation'\nimport './hooks/useTraceUpdate'\nimport './profile'\n\nexport const styles = theme => ({\n  '@global': {\n    body: {\n      '-webkit-tap-highlight-color': 'transparent',\n    },\n    a: {\n      color: theme.palette.primary.main,\n      textDecoration: 'underline',\n    },\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFPWA' })\n\nexport default function PWA({ children, errorReporter, sessionUrl }) {\n  useStyles()\n  const thumbnail = useRef(null)\n\n  const context = useMemo(\n    () => ({\n      thumbnail,\n    }),\n    [],\n  )\n\n  // enable client-side navigation when the user clicks a simple HTML anchor element\n  useSimpleNavigation()\n\n  useEffect(() => {\n    context.hydrating = false\n\n    // const handleOnline = () => (app.offline = false)\n    // const handleOffline = () => (app.offline = true)\n\n    // app.offline = !navigator.onLine\n    // window.addEventListener('online', handleOnline)\n    // window.addEventListener('offline', handleOffline)\n\n    // return () => {\n    //   window.removeEventListener('online', handleOnline)\n    //   window.removeEventListener('offline', handleOffline)\n    // }\n  }, [])\n\n  return (\n    <PWAContext.Provider value={context}>\n      <LinkContextProvider>\n        <ErrorBoundary onError={errorReporter}>{children}</ErrorBoundary>\n      </LinkContextProvider>\n    </PWAContext.Provider>\n  )\n}\n\nPWA.propTypes = {\n  /**\n   * A function to be called whenever an error occurs.  Use this to report errors\n   * to a service like Airbrake or Rollbar.\n   */\n  errorReporter: PropTypes.func,\n}\n",
      description: '',
      displayName: 'PWA',
      methods: [],
      props: [
        {
          name: 'errorReporter',
          type: { name: 'func' },
          required: false,
          description:
            'A function to be called whenever an error occurs.  Use this to report errors\nto a service like Airbrake or Rollbar.',
        },
      ],
      styles: {
        classes: [{ ruleName: '@global', globalClass: '.RSFPWA-@global', description: '' }],
        name: 'PWA',
      },
      type: 'component',
      import: "import PWA from 'react-storefront/PWA'",
    },
    QuantitySelector: {
      name: 'QuantitySelector',
      filename: 'QuantitySelector',
      importPath: 'QuantitySelector',
      src:
        "import React from 'react'\nimport { Add, Remove } from '@material-ui/icons'\nimport { IconButton } from '@material-ui/core'\nimport { makeStyles } from '@material-ui/core/styles'\nimport PropTypes from 'prop-types'\nimport clsx from 'clsx'\n\nexport const styles = theme => ({\n  /**\n   * Styles applied to the root element.\n   */\n  root: {\n    backgroundColor: theme.palette.divider,\n    border: 'none',\n    width: '110px',\n    padding: 0,\n  },\n  /**\n   * Styles applied to the icon elements.\n   */\n  icon: {\n    fontSize: '1.3125rem',\n    position: 'relative',\n  },\n  /**\n   * Styles applied to the icon button elements.\n   */\n  button: {\n    height: '36px',\n    width: '36px',\n    padding: 0,\n  },\n  /**\n   * Styles applied to the subtract icon button element.\n   */\n  subtract: { marginRight: theme.spacing(-4.5) },\n  /**\n   * Styles applied to the add icon button element.\n   */\n  add: { marginLeft: theme.spacing(-4.5) },\n  /**\n   * Styles applied to the text input element.\n   */\n  input: {\n    width: 100,\n    color: theme.palette.text.primary,\n    backgroundColor: theme.palette.grey[200],\n    textAlign: 'center',\n    padding: theme.spacing(1, 0, 1, 0),\n    border: 'none',\n    fontSize: theme.spacing(2),\n    outline: 'none',\n    '&::before': {\n      display: 'none',\n    },\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFQuantitySelector' })\n\n/**\n * A quantity selector with plus and minus buttons.\n */\nexport default function QuantitySelector({\n  name,\n  classes,\n  addIcon,\n  addButtonProps,\n  subtractIcon,\n  subtractButtonProps,\n  value,\n  minValue,\n  maxValue,\n  onChange,\n  inputProps,\n  ariaLabel,\n}) {\n  classes = useStyles({ classes })\n  const { quantitySelector, icon, button, ...inputClasses } = classes\n\n  if (!value) value = 1\n\n  function handleChange(value) {\n    if (value >= minValue && value <= maxValue) {\n      onChange(value)\n    }\n  }\n\n  return (\n    <>\n      <IconButton\n        size=\"small\"\n        classes={{ root: button }}\n        className={classes.subtract}\n        onClick={() => handleChange(value - 1)}\n        aria-label={`add one ${ariaLabel}`}\n        {...subtractButtonProps}\n      >\n        {subtractIcon || <Remove classes={{ root: icon }} />}\n      </IconButton>\n      <input\n        onChange={handleChange}\n        value={value}\n        name={name}\n        {...{ 'aria-label': ariaLabel }}\n        className={clsx([classes.input, inputClasses])}\n        {...inputProps}\n        readOnly\n      />\n      <IconButton\n        size=\"small\"\n        classes={{ root: button }}\n        className={classes.add}\n        onClick={() => handleChange(value + 1)}\n        aria-label={`subtract one ${ariaLabel}`}\n        {...addButtonProps}\n      >\n        {addIcon || <Add classes={{ root: icon }} />}\n      </IconButton>\n    </>\n  )\n}\n\nQuantitySelector.propTypes = {\n  /**\n   * The name to apply to the input when rendering AMP.\n   */\n  name: PropTypes.string,\n\n  /**\n   * Override or extend the styles applied to the component. See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object,\n\n  /**\n   * The plus icon.\n   */\n  addIcon: PropTypes.element,\n\n  /**\n   * The minus icon.\n   */\n  subtractIcon: PropTypes.element,\n\n  /**\n   * The current value.\n   */\n  value: PropTypes.number,\n\n  /**\n   * The minimum value.\n   */\n  minValue: PropTypes.number,\n\n  /**\n   * The maximum value.\n   */\n  maxValue: PropTypes.number,\n\n  /**\n   * Called when the value is changed.  The new value is passed as the only argument\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * The accessibility label.  Add and subtract button `aria-label` values are derived from this as\n   * `\"add one {ariaLabel}\"` and `\"subtract one {ariaLabel}\"`.\n   */\n  ariaLabel: PropTypes.string,\n}\n\nQuantitySelector.defaultProps = {\n  name: 'quantity',\n  onChange: Function.prototype,\n  addButtonProps: {},\n  subtractButtonProps: {},\n  inputProps: {},\n  minValue: 1,\n  maxValue: 100,\n  ariaLabel: 'quantity',\n}\n",
      description: 'A quantity selector with plus and minus buttons.',
      displayName: 'QuantitySelector',
      methods: [],
      props: [
        {
          name: 'name',
          type: { name: 'string' },
          required: false,
          description: 'The name to apply to the input when rendering AMP.',
          defaultValue: { value: "'quantity'", computed: false },
        },
        {
          name: 'classes',
          type: { name: 'object' },
          required: false,
          description:
            'Override or extend the styles applied to the component. See [CSS API](#css) below for more details.',
        },
        {
          name: 'addIcon',
          type: { name: 'element' },
          required: false,
          description: 'The plus icon.',
        },
        {
          name: 'subtractIcon',
          type: { name: 'element' },
          required: false,
          description: 'The minus icon.',
        },
        {
          name: 'value',
          type: { name: 'number' },
          required: false,
          description: 'The current value.',
        },
        {
          name: 'minValue',
          type: { name: 'number' },
          required: false,
          description: 'The minimum value.',
          defaultValue: { value: '1', computed: false },
        },
        {
          name: 'maxValue',
          type: { name: 'number' },
          required: false,
          description: 'The maximum value.',
          defaultValue: { value: '100', computed: false },
        },
        {
          name: 'onChange',
          type: { name: 'func' },
          required: false,
          description:
            'Called when the value is changed.  The new value is passed as the only argument',
          defaultValue: { value: 'Function.prototype', computed: true },
        },
        {
          name: 'ariaLabel',
          type: { name: 'string' },
          required: false,
          description:
            'The accessibility label.  Add and subtract button `aria-label` values are derived from this as\n`"add one {ariaLabel}"` and `"subtract one {ariaLabel}"`.',
          defaultValue: { value: "'quantity'", computed: false },
        },
        { name: 'addButtonProps', defaultValue: { value: '{}', computed: false }, required: false },
        {
          name: 'subtractButtonProps',
          defaultValue: { value: '{}', computed: false },
          required: false,
        },
        { name: 'inputProps', defaultValue: { value: '{}', computed: false }, required: false },
      ],
      styles: {
        classes: [
          {
            ruleName: 'root',
            globalClass: '.RSFQuantitySelector-root',
            description: 'Styles applied to the root element.',
          },
          {
            ruleName: 'icon',
            globalClass: '.RSFQuantitySelector-icon',
            description: 'Styles applied to the icon elements.',
          },
          {
            ruleName: 'button',
            globalClass: '.RSFQuantitySelector-button',
            description: 'Styles applied to the icon button elements.',
          },
          {
            ruleName: 'subtract',
            globalClass: '.RSFQuantitySelector-subtract',
            description: 'Styles applied to the subtract icon button element.',
          },
          {
            ruleName: 'add',
            globalClass: '.RSFQuantitySelector-add',
            description: 'Styles applied to the add icon button element.',
          },
          {
            ruleName: 'input',
            globalClass: '.RSFQuantitySelector-input',
            description: 'Styles applied to the text input element.',
          },
        ],
        name: 'QuantitySelector',
      },
      type: 'component',
      import: "import QuantitySelector from 'react-storefront/QuantitySelector'",
    },
    Rating: {
      name: 'Rating',
      filename: 'Rating',
      importPath: 'Rating',
      src:
        "import React from 'react'\nimport { Star, StarBorder, StarHalf } from '@material-ui/icons'\nimport { makeStyles } from '@material-ui/core/styles'\nimport PropTypes from 'prop-types'\nimport clsx from 'clsx'\nimport { Hbox } from './Box'\n\n/**\n * Displays a star rating corresponding to the provided value\n */\nexport const styles = theme => ({\n  /**\n   * Styles applied to the root element.\n   */\n  root: {\n    display: 'flex',\n    '& svg': {\n      color: theme.palette.rating,\n      height: '16px',\n      width: '16px',\n      display: 'block',\n    },\n  },\n  /**\n   * Styles applied to an empty rating icon.\n   */\n  filledEmpty: {\n    fill: theme.palette.divider,\n  },\n  /**\n   * Styles applied to the root element when [`value`](#prop-value) is `0`.\n   */\n  blank: {\n    '& svg': {\n      color: theme.palette.divider,\n    },\n  },\n  /**\n   * Styles applied to the label element.\n   */\n  reviewsLabel: {\n    marginLeft: '3px',\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFRating' })\n\nexport default function Rating({\n  iconFull,\n  iconHalf,\n  iconEmpty,\n  classes,\n  value,\n  label,\n  reviewCount,\n  className,\n  product,\n  fillEmpty,\n}) {\n  let stars = []\n\n  if (product) {\n    reviewCount = product.reviewCount\n    value = product.rating\n  }\n\n  classes = useStyles({ classes })\n\n  const IconFull = iconFull || Star\n  const IconHalf = iconHalf || StarHalf\n  const IconEmpty = iconEmpty || StarBorder\n\n  for (let i = 1; i <= 5; i++) {\n    if (value == null || value >= i) {\n      stars.push(<IconFull key={i} />)\n    } else if (value >= i - 0.5) {\n      stars.push(<IconHalf key={i} />)\n    } else if (fillEmpty) {\n      stars.push(<IconFull className={classes.filledEmpty} key={i} />)\n    } else {\n      stars.push(<IconEmpty key={i} />)\n    }\n  }\n\n  return (\n    <Hbox>\n      <div className={clsx(classes.root, className, { [classes.blank]: value == null })}>\n        {stars}\n      </div>\n      {reviewCount ? (\n        <div className={classes.reviewsLabel}>\n          ({reviewCount}\n          {label(reviewCount)})\n        </div>\n      ) : null}\n    </Hbox>\n  )\n}\n\nRating.propTypes = {\n  /**\n   * Override or extend the styles applied to the component. See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object,\n\n  /**\n   * The number of stars to display.  Can be an integer or a float ending in .5.\n   */\n  value: PropTypes.number,\n\n  /**\n   * The number of reviews.\n   */\n  reviewCount: PropTypes.number,\n\n  /**\n   * A function that returns the label displayed to the right of the review count.\n   * For example: `<Rating label={reviewCount => <span> {reviewCount == 1 ? 'review' : 'reviews'}</span>}/>`.\n   * This value used in this example is the default.\n   */\n  label: PropTypes.func,\n\n  /**\n   * Can be used to as an alternative to setting `value` and `reviewCount` individually.\n   */\n  product: PropTypes.object,\n\n  /**\n   * Custom full point icon.\n   */\n  iconFull: PropTypes.func,\n\n  /**\n   * Custom half point icon.\n   */\n  iconHalf: PropTypes.func,\n\n  /**\n   * Custom empty icon; will override `fillEmpty` icon.\n   */\n  iconEmpty: PropTypes.func,\n\n  /**\n   * If `true`, use a filled icon with light gray background for empty icon\n   */\n  fillEmpty: PropTypes.bool,\n}\n\nRating.defaultProps = {\n  label: reviewCount => <span> {reviewCount == 1 ? 'review' : 'reviews'}</span>,\n  fillEmpty: false,\n}\n",
      description: '',
      displayName: 'Rating',
      methods: [],
      props: [
        {
          name: 'classes',
          type: { name: 'object' },
          required: false,
          description:
            'Override or extend the styles applied to the component. See [CSS API](#css) below for more details.',
        },
        {
          name: 'value',
          type: { name: 'number' },
          required: false,
          description:
            'The number of stars to display.  Can be an integer or a float ending in .5.',
        },
        {
          name: 'reviewCount',
          type: { name: 'number' },
          required: false,
          description: 'The number of reviews.',
        },
        {
          name: 'label',
          type: { name: 'func' },
          required: false,
          description:
            "A function that returns the label displayed to the right of the review count.\nFor example: `<Rating label={reviewCount => <span> {reviewCount == 1 ? 'review' : 'reviews'}</span>}/>`.\nThis value used in this example is the default.",
          defaultValue: {
            value: "reviewCount => <span> {reviewCount == 1 ? 'review' : 'reviews'}</span>",
            computed: false,
          },
        },
        {
          name: 'product',
          type: { name: 'object' },
          required: false,
          description:
            'Can be used to as an alternative to setting `value` and `reviewCount` individually.',
        },
        {
          name: 'iconFull',
          type: { name: 'func' },
          required: false,
          description: 'Custom full point icon.',
        },
        {
          name: 'iconHalf',
          type: { name: 'func' },
          required: false,
          description: 'Custom half point icon.',
        },
        {
          name: 'iconEmpty',
          type: { name: 'func' },
          required: false,
          description: 'Custom empty icon; will override `fillEmpty` icon.',
        },
        {
          name: 'fillEmpty',
          type: { name: 'bool' },
          required: false,
          description: 'If `true`, use a filled icon with light gray background for empty icon',
          defaultValue: { value: 'false', computed: false },
        },
      ],
      styles: {
        classes: [
          { ruleName: 'root', globalClass: '.RSFRating-root', description: '' },
          { ruleName: 'filledEmpty', globalClass: '.RSFRating-filledEmpty', description: '' },
          { ruleName: 'blank', globalClass: '.RSFRating-blank', description: '' },
          { ruleName: 'reviewsLabel', globalClass: '.RSFRating-reviewsLabel', description: '' },
        ],
        name: 'Rating',
      },
      type: 'component',
      import: "import Rating from 'react-storefront/Rating'",
    },
    ResponsiveTiles: {
      name: 'ResponsiveTiles',
      filename: 'ResponsiveTiles',
      importPath: 'ResponsiveTiles',
      src:
        "import React, { useRef } from 'react'\nimport { GridListTile } from '@material-ui/core'\nimport { makeStyles } from '@material-ui/core/styles'\nimport clsx from 'clsx'\nimport PropTypes from 'prop-types'\nimport AutoScrollToNewChildren from './AutoScrollToNewChildren'\n\n/**\n * A responsive grid of tiles that changes the number of columns based on the viewport size.\n * This component commonly used in product listings and search results.\n */\nexport default function ResponsiveTiles(props) {\n  const Tiles = useRef(createTiles(props))\n  const { cols, spacing, ...others } = props\n  return <Tiles.current {...others} />\n}\n\nResponsiveTiles.propTypes = {\n  /**\n   * If `true`, automatically scroll to the first new tile when the\n   * number of tiles is increased.\n   */\n  autoScrollToNewTiles: PropTypes.bool,\n\n  /**\n   * A map of viewport widths to number of columns.  For example:\n   * ```\n   *  cols={{\n   *    xs: 2,\n   *    sm: 3,\n   *    md: 4,\n   *    lg: 5,\n   *    xl: 5\n   *  }}\n   * ```\n   */\n  cols: PropTypes.shape({\n    xs: PropTypes.number,\n    sm: PropTypes.number,\n    md: PropTypes.number,\n    lg: PropTypes.number,\n    xl: PropTypes.number,\n  }),\n\n  /**\n   * The spacing between the tiles in theme spacing units.\n   */\n  spacing: PropTypes.number,\n}\n\nResponsiveTiles.defaultProps = {\n  autoScrollToNewTiles: false,\n  cols: {\n    xs: 2,\n    sm: 3,\n    md: 4,\n    lg: 5,\n    xl: 5,\n  },\n  spacing: 1,\n}\n\nfunction createTiles({ cols, spacing }) {\n  const useStyles = makeStyles(theme => {\n    let breakpoints = {}\n\n    // Breakpoints MUST be set in order from smallest to largest\n    Object.keys(cols)\n      .map(width => {\n        return {\n          key: width,\n          value: cols[width],\n          width: `${100 / cols[width]}%`,\n        }\n      })\n      .sort((a, b) => a.value - b.value)\n      .forEach(({ key, width }) => {\n        breakpoints[theme.breakpoints.up(key)] = { width }\n      })\n\n    return {\n      root: {\n        display: 'flex',\n        flexWrap: 'wrap',\n        overflowY: 'auto',\n        listStyle: 'none',\n        padding: 0,\n        margin: `-${theme.spacing(spacing)}px`,\n        WebkitOverflowScrolling: 'touch', // Add iOS momentum scrolling.\n      },\n      tile: {\n        ...breakpoints,\n        padding: `${theme.spacing(spacing)}px`,\n        height: 'auto',\n      },\n    }\n  }, 'RSFResponsiveTiles')\n\n  function maybeWrapInAutoScroll(doWrap) {\n    return function(elements) {\n      if (doWrap) {\n        return <AutoScrollToNewChildren>{elements}</AutoScrollToNewChildren>\n      } else {\n        return elements\n      }\n    }\n  }\n\n  return function Tiles({ className, classes, autoScrollToNewTiles, children, ...other }) {\n    classes = useStyles({ classes })\n\n    return (\n      <ul className={clsx(className, classes.root)} {...other}>\n        {maybeWrapInAutoScroll(autoScrollToNewTiles)(\n          React.Children.map(children, (child, i) => {\n            if (!React.isValidElement(child)) {\n              return null\n            }\n            return (\n              <GridListTile key={i} classes={{ root: classes.tile }}>\n                {child}\n              </GridListTile>\n            )\n          }),\n        )}\n      </ul>\n    )\n  }\n}\n",
      description:
        'A responsive grid of tiles that changes the number of columns based on the viewport size.\nThis component commonly used in product listings and search results.',
      displayName: 'ResponsiveTiles',
      methods: [],
      props: [
        {
          name: 'autoScrollToNewTiles',
          type: { name: 'bool' },
          required: false,
          description:
            'If `true`, automatically scroll to the first new tile when the\nnumber of tiles is increased.',
          defaultValue: { value: 'false', computed: false },
        },
        {
          name: 'cols',
          type: {
            name: 'shape',
            value: {
              xs: { name: 'number', required: false },
              sm: { name: 'number', required: false },
              md: { name: 'number', required: false },
              lg: { name: 'number', required: false },
              xl: { name: 'number', required: false },
            },
          },
          required: false,
          description:
            'A map of viewport widths to number of columns.  For example:\n```\n cols={{\n   xs: 2,\n   sm: 3,\n   md: 4,\n   lg: 5,\n   xl: 5\n }}\n```',
          defaultValue: {
            value: '{\n  xs: 2,\n  sm: 3,\n  md: 4,\n  lg: 5,\n  xl: 5,\n}',
            computed: false,
          },
        },
        {
          name: 'spacing',
          type: { name: 'number' },
          required: false,
          description: 'The spacing between the tiles in theme spacing units.',
          defaultValue: { value: '1', computed: false },
        },
      ],
      styles: { classes: [], name: null },
      type: 'component',
      import: "import ResponsiveTiles from 'react-storefront/ResponsiveTiles'",
    },
    Row: {
      name: 'Row',
      filename: 'Row',
      importPath: 'Row',
      src:
        "import PropTypes from 'prop-types'\nimport React from 'react'\nimport { makeStyles } from '@material-ui/core/styles'\n\nconst useStyles = makeStyles(theme => ({\n  /**\n   * Styles applied to the root element.\n   */\n  root: {\n    margin: `0 0 ${theme.spacing(2)}px 0`,\n  },\n}))\n\n/**\n * A grid item that takes up the full viewport.  Provided for backwards compatibility with\n * React Storefront 6.\n */\nexport default function Row({ children, classes, ...others }) {\n  classes = useStyles({ classes })\n\n  return (\n    <div className={classes.root} {...others}>\n      {children}\n    </div>\n  )\n}\n\nRow.propTypes = {\n  /**\n   * Override or extend the styles applied to the component. See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object,\n}\n",
      description:
        'A grid item that takes up the full viewport.  Provided for backwards compatibility with\nReact Storefront 6.',
      displayName: 'Row',
      methods: [],
      props: [
        {
          name: 'classes',
          type: { name: 'object' },
          required: false,
          description:
            'Override or extend the styles applied to the component. See [CSS API](#css) below for more details.',
        },
      ],
      styles: { classes: [], name: null },
      type: 'component',
      import: "import Row from 'react-storefront/Row'",
    },
    Spacer: {
      name: 'Spacer',
      filename: 'Spacer',
      importPath: 'Spacer',
      src:
        "import PropTypes from 'prop-types'\nimport React from 'react'\nimport { makeStyles } from '@material-ui/core/styles'\n\n/**\n * Renders a simple div with flex: 1 to be used as a spacer.  Since this is a\n * common case, the main purposed of this class is to minimize the amount of\n * css generated for an app.\n */\nexport const styles = theme => ({\n  /**\n   * Styles applied to the root element.\n   */\n  root: {\n    flex: 1,\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFSpacer' })\n\n/**\n * Renders a simple div with flex: 1 to be used as a spacer.  Since this is a\n * common case, the main purposed of this class is to minimize the amount of\n * css generated for an app.\n */\nexport default function Spacer(props) {\n  const classes = useStyles(props)\n  return <div className={classes.root} />\n}\n\nSpacer.propTypes = {\n  /**\n   * Override or extend the styles applied to the component. See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object,\n}\n",
      description:
        'Renders a simple div with flex: 1 to be used as a spacer.  Since this is a\ncommon case, the main purposed of this class is to minimize the amount of\ncss generated for an app.',
      displayName: 'Spacer',
      methods: [],
      props: [
        {
          name: 'classes',
          type: { name: 'object' },
          required: false,
          description:
            'Override or extend the styles applied to the component. See [CSS API](#css) below for more details.',
        },
      ],
      styles: {
        classes: [{ ruleName: 'root', globalClass: '.RSFSpacer-root', description: '' }],
        name: 'Spacer',
      },
      type: 'component',
      import: "import Spacer from 'react-storefront/Spacer'",
    },
    TabPanel: {
      name: 'TabPanel',
      filename: 'TabPanel',
      importPath: 'TabPanel',
      src:
        "import React, { useState } from 'react'\nimport { Tabs, Tab } from '@material-ui/core'\nimport { makeStyles } from '@material-ui/core/styles'\nimport PropTypes from 'prop-types'\nimport clsx from 'clsx'\n\nconst styles = theme => ({\n  /**\n   * Styles applied to the root element.\n   */\n  root: {},\n  /**\n   * Styles applied to the wrapper around each panel element.\n   */\n  panel: {\n    margin: `${theme.spacing(2)}px 0`,\n  },\n  /**\n   * Styles applied to the wrapper around each panel element when that panel is hidden.\n   */\n  hidden: {\n    display: 'none',\n  },\n})\n\nexport const useStyles = makeStyles(styles, { name: 'RSFTabPanel' })\n\n/**\n * A simple tab panel that is AMP-compatible.  Tab names are pull from the label prop of the child elements.\n * Any type of element can be a child.\n *\n * Example:\n *\n * ```js\n *  <TabPanel>\n *    <div label=\"Description\">\n *      Description here\n *    </div>\n *    <CmsSlot label=\"Instructions\">\n *      { instructionsFromCms }\n *    </CmsSlot>\n *  </TabPanel>\n * ```\n */\nexport default function TabPanel({\n  children,\n  classes,\n  scrollable,\n  selected: selectedProp,\n  onChange,\n  tabsProps,\n  tabProps,\n  panelProps,\n  renderPanels,\n}) {\n  classes = useStyles({ classes })\n\n  const [selected, setSelected] = useState(selectedProp)\n  const tabs = []\n\n  let panels = []\n\n  const onChangeHandler = (event, selected) => {\n    setSelected(selected)\n\n    if (onChange) {\n      onChange(selected)\n    }\n  }\n\n  React.Children.forEach(children, (child, index) => {\n    tabs.push(\n      <Tab key={index} label={child.props.label} {...tabProps({ child, index, selected })} />,\n    )\n\n    const { className, ...others } = panelProps({ child, index, selected }) || {}\n\n    panels.push(\n      <div\n        key={index}\n        role=\"tabpanel\"\n        className={clsx(classes.panel, {\n          [classes.hidden]: index !== selected,\n          [className]: true,\n        })}\n        {...others}\n      >\n        {React.cloneElement(child, { label: null })}\n      </div>,\n    )\n  })\n\n  return (\n    <div className={classes.root}>\n      <Tabs\n        variant={scrollable ? 'scrollable' : null}\n        value={selected}\n        onChange={onChangeHandler}\n        {...tabsProps}\n      >\n        {tabs}\n      </Tabs>\n      {renderPanels(panels)}\n    </div>\n  )\n}\n\nTabPanel.propTypes = {\n  /**\n   * Override or extend the styles applied to the component. See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object,\n\n  /**\n   * Set to false to prevent the tabs from scrolling.\n   */\n  scrollable: PropTypes.bool,\n\n  /**\n   * Selected tab index.\n   */\n  selected: PropTypes.number,\n  /**\n   * Called when the selected tab is changed.\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * A function that takes an object containing:\n   *\n   * - child: The child element\n   * - index: The index of the child\n   * - selected: The index of the currently selected element\n   *\n   * ... and returns props for the corresponding Material UI `Tab` element.\n   */\n  tabProps: PropTypes.func,\n\n  /**\n   * A function that takes an object containing:\n   *\n   * - child: The child element\n   * - index: The index of the child\n   * - selected: The index of the currently selected element\n   *\n   * ... and returns props for the corresponding panel `div` element.\n   */\n  panelProps: PropTypes.func,\n\n  /**\n   * Props for the Material UI `Tabs` element.\n   */\n  tabsProps: PropTypes.object,\n\n  /**\n   * A function that takes the panels as an argument and returns a react element to render.\n   */\n  renderPanels: PropTypes.func,\n}\n\nTabPanel.defaultProps = {\n  scrollable: true,\n  selected: 0,\n  tabProps: Function.prototype,\n  panelProps: Function.prototype,\n  renderPanels: panels => panels,\n}\n",
      description:
        'A simple tab panel that is AMP-compatible.  Tab names are pull from the label prop of the child elements.\nAny type of element can be a child.\n\nExample:\n\n```js\n <TabPanel>\n   <div label="Description">\n     Description here\n   </div>\n   <CmsSlot label="Instructions">\n     { instructionsFromCms }\n   </CmsSlot>\n </TabPanel>\n```',
      displayName: 'TabPanel',
      methods: [],
      props: [
        {
          name: 'classes',
          type: { name: 'object' },
          required: false,
          description:
            'Override or extend the styles applied to the component. See [CSS API](#css) below for more details.',
        },
        {
          name: 'scrollable',
          type: { name: 'bool' },
          required: false,
          description: 'Set to false to prevent the tabs from scrolling.',
          defaultValue: { value: 'true', computed: false },
        },
        {
          name: 'selected',
          type: { name: 'number' },
          required: false,
          description: 'Selected tab index.',
          defaultValue: { value: '0', computed: false },
        },
        {
          name: 'onChange',
          type: { name: 'func' },
          required: false,
          description: 'Called when the selected tab is changed.',
        },
        {
          name: 'tabProps',
          type: { name: 'func' },
          required: false,
          description:
            'A function that takes an object containing:\n\n- child: The child element\n- index: The index of the child\n- selected: The index of the currently selected element\n\n... and returns props for the corresponding Material UI `Tab` element.',
          defaultValue: { value: 'Function.prototype', computed: true },
        },
        {
          name: 'panelProps',
          type: { name: 'func' },
          required: false,
          description:
            'A function that takes an object containing:\n\n- child: The child element\n- index: The index of the child\n- selected: The index of the currently selected element\n\n... and returns props for the corresponding panel `div` element.',
          defaultValue: { value: 'Function.prototype', computed: true },
        },
        {
          name: 'tabsProps',
          type: { name: 'object' },
          required: false,
          description: 'Props for the Material UI `Tabs` element.',
        },
        {
          name: 'renderPanels',
          type: { name: 'func' },
          required: false,
          description:
            'A function that takes the panels as an argument and returns a react element to render.',
          defaultValue: { value: 'panels => panels', computed: false },
        },
      ],
      styles: { classes: [], name: null },
      type: 'component',
      import: "import TabPanel from 'react-storefront/TabPanel'",
    },
    ToolbarButton: {
      name: 'ToolbarButton',
      filename: 'ToolbarButton',
      importPath: 'ToolbarButton',
      src:
        "import React, { forwardRef } from 'react'\nimport { makeStyles } from '@material-ui/core/styles'\nimport { IconButton } from '@material-ui/core'\nimport PropTypes from 'prop-types'\n\nexport const styles = theme => ({\n  /**\n   * Styles applied to the content wrapper element inside the button\n   */\n  wrap: {\n    display: 'flex',\n    flexDirection: 'column',\n    justifyContent: 'center',\n    alignItems: 'center',\n    ...theme.typography.caption,\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFToolbarButton' })\n\n/**\n * A toolbar button with optional label.  Use these in your AppBar. All additional\n * props are spread to the underlying material-ui IconButton.\n */\nconst ToolbarButton = forwardRef(({ icon, label, classes = {}, children, ...others }, ref) => {\n  let { wrap, ...buttonClasses } = classes\n  classes = useStyles({ classes: { wrap } })\n\n  return (\n    <IconButton ref={ref} classes={buttonClasses} {...others}>\n      <div className={classes.wrap}>\n        {icon}\n        <div>{label}</div>\n      </div>\n      {children}\n    </IconButton>\n  )\n})\n\nToolbarButton.propTypes = {\n  /**\n   * Override or extend the styles applied to the component. See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object,\n\n  /**\n   * The icon to use for the button.\n   */\n  icon: PropTypes.element,\n\n  /**\n   * The label text for the button.\n   */\n  label: PropTypes.oneOfType([PropTypes.string, PropTypes.element]),\n}\n\nexport default ToolbarButton\n",
      description:
        'A toolbar button with optional label.  Use these in your AppBar. All additional\nprops are spread to the underlying material-ui IconButton.',
      methods: [],
      props: [
        {
          name: 'classes',
          type: { name: 'object' },
          required: false,
          description:
            'Override or extend the styles applied to the component. See [CSS API](#css) below for more details.',
          defaultValue: { value: '{}', computed: false },
        },
        {
          name: 'icon',
          type: { name: 'element' },
          required: false,
          description: 'The icon to use for the button.',
        },
        {
          name: 'label',
          type: { name: 'union', value: [{ name: 'string' }, { name: 'element' }] },
          required: false,
          description: 'The label text for the button.',
        },
      ],
      styles: {
        classes: [
          {
            ruleName: 'wrap',
            globalClass: '.RSFToolbarButton-wrap',
            description: 'Styles applied to the content wrapper element inside the button',
          },
        ],
      },
      type: 'component',
      import: "import ToolbarButton from 'react-storefront/ToolbarButton'",
    },
    'carousel/Carousel': {
      name: 'Carousel',
      filename: 'Carousel',
      importPath: 'carousel/Carousel',
      src:
        "import React, { useState } from 'react'\nimport clsx from 'clsx'\nimport { makeStyles } from '@material-ui/core/styles'\nimport SwipeableViews from 'react-swipeable-views'\nimport { autoPlay } from 'react-swipeable-views-utils'\nimport PropTypes from 'prop-types'\nimport CarouselDots from './CarouselDots'\nimport CarouselArrows from './CarouselArrows'\nimport Fill from '../Fill'\n\nconst styles = theme => ({\n  /**\n   * Styles applied to the root element.\n   */\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n    alignItems: 'stretch',\n    position: 'relative',\n    '& img': {\n      display: 'block',\n    },\n  },\n\n  /**\n   * Styles applied to wrapper element of the swipe container.\n   */\n  swipeWrap: {\n    position: 'relative',\n    overflow: 'hidden',\n    flex: 1,\n\n    '& .react-swipeable-view-container, & > div:first-child': {\n      height: '100%',\n    },\n  },\n\n  '@media (hover:none)': {\n    hideTouchArrows: {\n      display: 'none',\n    },\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFCarousel' })\nconst AutoPlaySwipeableViews = autoPlay(SwipeableViews)\n\nfunction useSelected(props) {\n  if (props.setSelected) {\n    return props\n  } else {\n    const [selected, setSelected] = useState(0)\n    return { selected, setSelected }\n  }\n}\n\nconst Carousel = React.forwardRef((props, ref) => {\n  let {\n    height,\n    children,\n    classes,\n    className,\n    style,\n    swipeStyle,\n    slideStyle,\n    arrows,\n    aboveAdornments,\n    belowAdornments,\n    onMouseEnter,\n    onMouseLeave,\n    onClick,\n    indicators,\n    autoplay,\n    interval,\n  } = props\n\n  classes = useStyles({ classes })\n\n  const { selected, setSelected } = useSelected(props)\n  const count = children && children.length\n\n  return (\n    <div\n      ref={ref}\n      className={clsx(className, classes.root)}\n      style={style}\n      onMouseEnter={onMouseEnter}\n      onMouseLeave={onMouseLeave}\n      onClick={onClick}\n    >\n      {aboveAdornments}\n      <Fill height={height}>\n        <div className={classes.swipeWrap}>\n          <AutoPlaySwipeableViews\n            index={selected}\n            onChangeIndex={i => setSelected(i)}\n            style={swipeStyle}\n            slideStyle={slideStyle}\n            autoplay={autoplay}\n            interval={interval}\n          >\n            {children}\n          </AutoPlaySwipeableViews>\n          {arrows !== false && (\n            <CarouselArrows\n              className={arrows === 'desktop' ? classes.hideTouchArrows : null}\n              selected={selected}\n              setSelected={setSelected}\n              count={count}\n            />\n          )}\n          {indicators && <CarouselDots count={count} selected={selected} />}\n        </div>\n      </Fill>\n      {belowAdornments}\n    </div>\n  )\n})\n\nCarousel.propTypes = {\n  /**\n   * Override or extend the styles applied to the component. See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object,\n\n  /**\n   * Set to `false` to hide arrows, `'desktop'` to only show them\n   * on non-touch devices, `'all'` to always show arrows.\n   */\n  arrows: PropTypes.oneOf([false, 'desktop', 'all']),\n\n  /**\n   * Nodes to render above the Carousel.\n   */\n  aboveAdornments: PropTypes.arrayOf(PropTypes.element),\n\n  /**\n   * Nodes to render below the Carousel.\n   */\n  belowAdornments: PropTypes.arrayOf(PropTypes.element),\n\n  /**\n   * If `true`, the Carousel will automatically cycle through the media elements.\n   */\n  autoplay: PropTypes.bool,\n\n  /**\n   * The interval time (in milliseconds) for [`autoplay`](#prop-autoplay).\n   */\n  interval: PropTypes.number,\n}\n\nCarousel.defaultProps = {\n  inset: 0,\n  indicators: true,\n  arrows: 'desktop',\n  autoplay: false,\n  interval: 3000,\n}\n\nexport default Carousel\n",
      description: '',
      methods: [],
      props: [
        {
          name: 'classes',
          type: { name: 'object' },
          required: false,
          description:
            'Override or extend the styles applied to the component. See [CSS API](#css) below for more details.',
        },
        {
          name: 'arrows',
          type: {
            name: 'enum',
            value: [
              { value: 'false', computed: false },
              { value: "'desktop'", computed: false },
              { value: "'all'", computed: false },
            ],
          },
          required: false,
          description:
            "Set to `false` to hide arrows, `'desktop'` to only show them\non non-touch devices, `'all'` to always show arrows.",
          defaultValue: { value: "'desktop'", computed: false },
        },
        {
          name: 'aboveAdornments',
          type: { name: 'arrayOf', value: { name: 'element' } },
          required: false,
          description: 'Nodes to render above the Carousel.',
        },
        {
          name: 'belowAdornments',
          type: { name: 'arrayOf', value: { name: 'element' } },
          required: false,
          description: 'Nodes to render below the Carousel.',
        },
        {
          name: 'autoplay',
          type: { name: 'bool' },
          required: false,
          description:
            'If `true`, the Carousel will automatically cycle through the media elements.',
          defaultValue: { value: 'false', computed: false },
        },
        {
          name: 'interval',
          type: { name: 'number' },
          required: false,
          description: 'The interval time (in milliseconds) for [`autoplay`](#prop-autoplay).',
          defaultValue: { value: '3000', computed: false },
        },
        { name: 'inset', defaultValue: { value: '0', computed: false }, required: false },
        { name: 'indicators', defaultValue: { value: 'true', computed: false }, required: false },
      ],
      styles: { classes: [], name: null },
      type: 'component',
      import: "import Carousel from 'react-storefront/carousel/Carousel'",
    },
    'carousel/CarouselArrows': {
      name: 'CarouselArrows',
      filename: 'CarouselArrows',
      importPath: 'carousel/CarouselArrows',
      src:
        "import React, { useCallback } from 'react'\nimport clsx from 'clsx'\nimport makeStyles from '@material-ui/core/styles/makeStyles'\nimport { IconButton } from '@material-ui/core'\nimport { ChevronLeft, ChevronRight } from '@material-ui/icons'\n\nexport const styles = theme => ({\n  arrow: {\n    position: 'absolute',\n    top: '50%',\n    marginTop: '-24px',\n  },\n\n  leftArrow: {\n    left: 0,\n  },\n\n  rightArrow: {\n    right: 0,\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFCarouselArrows' })\n\nexport default function CarouselArrows({ className, classes, selected, count, setSelected }) {\n  classes = useStyles({ classes })\n\n  const createOnClickArrow = useCallback(\n    idxChange => evt => {\n      evt.preventDefault()\n      setSelected(selected + idxChange)\n    },\n    [selected, setSelected],\n  )\n\n  return (\n    <div className={clsx(classes.arrows, className)}>\n      {selected !== 0 && (\n        <IconButton\n          className={clsx(classes.arrow, classes.leftArrow)}\n          onClick={createOnClickArrow(-1)}\n        >\n          <ChevronLeft classes={{ root: classes.icon }} />\n        </IconButton>\n      )}\n      {selected !== count - 1 && (\n        <IconButton\n          className={clsx(classes.arrow, classes.rightArrow)}\n          onClick={createOnClickArrow(1)}\n        >\n          <ChevronRight classes={{ root: classes.icon }} />\n        </IconButton>\n      )}\n    </div>\n  )\n}\n\nCarouselArrows.propTypes = {}\n\nCarouselArrows.defaultProps = {}\n",
      description: '',
      displayName: 'CarouselArrows',
      methods: [],
      styles: {
        classes: [
          { ruleName: 'arrow', globalClass: '.RSFCarouselArrows-arrow', description: '' },
          { ruleName: 'leftArrow', globalClass: '.RSFCarouselArrows-leftArrow', description: '' },
          { ruleName: 'rightArrow', globalClass: '.RSFCarouselArrows-rightArrow', description: '' },
        ],
        name: 'CarouselArrows',
      },
      props: [],
      type: 'component',
      import: "import CarouselArrows from 'react-storefront/carousel/CarouselArrows'",
    },
    'carousel/CarouselDots': {
      name: 'CarouselDots',
      filename: 'CarouselDots',
      importPath: 'carousel/CarouselDots',
      src:
        "import React from 'react'\nimport clsx from 'clsx'\nimport { makeStyles } from '@material-ui/core/styles'\nimport PropTypes from 'prop-types'\nimport { fade } from '@material-ui/core/styles/colorManipulator'\n\nconst styles = theme => ({\n  dot: {\n    backgroundColor: fade(theme.palette.text.primary, 0.25),\n    width: 8,\n    height: 8,\n    borderWidth: '1px',\n    borderStyle: 'solid',\n    borderColor: theme.palette.background.paper,\n    borderRadius: '50%',\n    display: 'inline-block',\n    margin: '0 2px',\n    // Same duration as SwipeableViews animation\n    transitionDuration: '0.35s',\n  },\n\n  dotSelected: {\n    backgroundColor: theme.palette.text.primary,\n  },\n\n  dots: {\n    position: 'absolute',\n    bottom: '5px',\n    textAlign: 'center',\n    width: '100%',\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFCarouselDots' })\n\nfunction CarouselDots({ selected, count, classes }) {\n  const dots = []\n  classes = useStyles({ classes })\n\n  for (let i = 0; i < count; i++) {\n    dots.push(\n      <div\n        key={i}\n        className={clsx({\n          [classes.dot]: true,\n          [classes.dotSelected]: selected === i,\n        })}\n      />,\n    )\n  }\n\n  return <div className={classes.dots}>{dots}</div>\n}\n\nCarouselDots.propTypes = {\n  count: PropTypes.number.isRequired,\n  selected: PropTypes.number.isRequired,\n}\n\nexport default React.memo(CarouselDots)\n",
      description: '',
      displayName: 'CarouselDots',
      methods: [],
      props: [
        { name: 'count', type: { name: 'number' }, required: true, description: '' },
        { name: 'selected', type: { name: 'number' }, required: true, description: '' },
      ],
      styles: { classes: [], name: null },
      type: 'component',
      import: "import CarouselDots from 'react-storefront/carousel/CarouselDots'",
    },
    'carousel/CarouselThumbnails': {
      name: 'CarouselThumbnails',
      filename: 'CarouselThumbnails',
      importPath: 'carousel/CarouselThumbnails',
      src:
        "import React from 'react'\nimport clsx from 'clsx'\nimport Tabs from '@material-ui/core/Tabs'\nimport Tab from '@material-ui/core/Tab'\nimport { makeStyles } from '@material-ui/core/styles'\nimport Image from '../Image'\n\nexport const styles = theme => ({\n  thumb: {\n    width: 50,\n    height: 50,\n    boxSizing: 'content-box',\n  },\n  thumbs: {\n    display: 'flex',\n    justifyContent: 'center',\n  },\n  hidden: { display: 'none' },\n  tabsIndicator: {\n    display: 'none',\n    backgroundColor: theme.palette.primary.main,\n    height: '3px',\n    transition: 'left 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms',\n  },\n  tabsRoot: {\n    marginTop: theme.spacing(2),\n  },\n  noSelection: {\n    visibility: 'hidden',\n  },\n  tabRoot: {\n    minWidth: 'auto',\n    padding: 0,\n    outline: 'none',\n    opacity: 0.7,\n    transition: 'opacity linear 100ms',\n    '&:hover': {\n      opacity: 0.9,\n    },\n  },\n  selectedTab: {\n    opacity: 1,\n  },\n  tabWrapper: {\n    margin: '0 2px',\n    border: '1px solid transparent',\n    '$selectedTab &': {\n      border: `1px solid rgba(0,0,0,0.3)`,\n    },\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFCarouselThumbnails' })\n\nfunction CarouselThumbnails(props) {\n  const { thumbnails, selected, setSelected, classes, className } = props\n  const styles = useStyles({ classes })\n\n  return (\n    <div className={clsx(className, styles.thumbs)}>\n      <Tabs\n        value={selected}\n        variant=\"scrollable\"\n        onChange={(_, index) => setSelected(index)}\n        classes={{\n          root: styles.tabsRoot,\n          indicator: styles.tabsIndicator,\n        }}\n      >\n        {thumbnails.map(({ src, alt }, i) => {\n          const icon = <Image contain className={styles.thumb} src={src} alt={alt} />\n          return (\n            <Tab\n              classes={{\n                root: styles.tabRoot,\n                wrapper: styles.tabWrapper,\n                selected: styles.selectedTab,\n              }}\n              key={i}\n              icon={icon}\n            />\n          )\n        })}\n      </Tabs>\n    </div>\n  )\n}\n\nexport default React.memo(CarouselThumbnails)\n",
      description: '',
      displayName: 'CarouselThumbnails',
      methods: [],
      styles: {
        classes: [
          { ruleName: 'thumb', globalClass: '.RSFCarouselThumbnails-thumb', description: '' },
          { ruleName: 'thumbs', globalClass: '.RSFCarouselThumbnails-thumbs', description: '' },
          { ruleName: 'hidden', globalClass: '.RSFCarouselThumbnails-hidden', description: '' },
          {
            ruleName: 'tabsIndicator',
            globalClass: '.RSFCarouselThumbnails-tabsIndicator',
            description: '',
          },
          { ruleName: 'tabsRoot', globalClass: '.RSFCarouselThumbnails-tabsRoot', description: '' },
          {
            ruleName: 'noSelection',
            globalClass: '.RSFCarouselThumbnails-noSelection',
            description: '',
          },
          { ruleName: 'tabRoot', globalClass: '.RSFCarouselThumbnails-tabRoot', description: '' },
          {
            ruleName: 'selectedTab',
            globalClass: '.RSFCarouselThumbnails-selectedTab',
            description: '',
          },
          {
            ruleName: 'tabWrapper',
            globalClass: '.RSFCarouselThumbnails-tabWrapper',
            description: '',
          },
        ],
      },
      props: [],
      type: 'component',
      import: "import CarouselThumbnails from 'react-storefront/carousel/CarouselThumbnails'",
    },
    'carousel/Lightbox': {
      name: 'Lightbox',
      filename: 'Lightbox',
      importPath: 'carousel/Lightbox',
      src:
        "import useTheme from '@material-ui/core/styles/useTheme'\nimport React from 'react'\nimport { makeStyles } from '@material-ui/core/styles'\nimport Close from '@material-ui/icons/Close'\nimport { Dialog, DialogActions, DialogContent, IconButton, Zoom } from '@material-ui/core'\n\nconst Transition = React.forwardRef((props, ref) => {\n  return <Zoom duration={500} ref={ref} {...props} />\n})\n\nconst styles = theme => ({\n  root: {},\n  content: {\n    padding: 0,\n    display: 'flex',\n    flexDirection: 'column',\n  },\n  paper: {\n    flex: 1,\n    background: 'rgba(255,255,255,0.9)',\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFLightbox' })\n\nfunction Lightbox(props) {\n  let { classes, children, onClose, open, TransitionComponent } = props\n  classes = useStyles({ classes })\n  const theme = useTheme()\n\n  return (\n    <Dialog\n      open={open}\n      fullScreen\n      classes={{\n        paper: classes.paper,\n      }}\n      TransitionComponent={TransitionComponent}\n      className={classes.root}\n      style={{ zIndex: theme.zIndex.modal + 10 }}\n    >\n      <DialogActions>\n        <IconButton onClick={onClose}>\n          <Close />\n        </IconButton>\n      </DialogActions>\n      <DialogContent className={classes.content}>{children}</DialogContent>\n    </Dialog>\n  )\n}\n\nLightbox.defaultProps = {\n  TransitionComponent: Transition,\n}\n\nexport default React.memo(Lightbox)\n",
      description: '',
      methods: [],
      styles: { classes: [], name: null },
      props: [],
      type: 'component',
      import: "import Lightbox from 'react-storefront/carousel/Lightbox'",
    },
    'carousel/MagnifyHint': {
      name: 'MagnifyHint',
      filename: 'MagnifyHint',
      importPath: 'carousel/MagnifyHint',
      src:
        "import { useAmp } from 'next/amp'\nimport React from 'react'\nimport PropTypes from 'prop-types'\nimport { makeStyles } from '@material-ui/core/styles'\nimport { Typography } from '@material-ui/core'\nimport { AddCircleOutline as Icon } from '@material-ui/icons'\nimport clsx from 'clsx'\n\nconst styles = theme => ({\n  root: {\n    position: 'absolute',\n    bottom: 30,\n    display: 'flex',\n    flexDirection: 'row',\n    justifyContent: 'center',\n    width: '100%',\n  },\n  wrap: {\n    borderRadius: 25,\n    backgroundColor: 'rgba(0, 0, 0, 0.3)',\n    lineHeight: 14,\n    padding: '5px 10px',\n    display: 'flex',\n    flexDirection: 'row',\n    alignItems: 'center',\n  },\n  icon: {\n    height: 16,\n    width: 16,\n    color: theme.palette.grey[300],\n  },\n  text: {\n    marginLeft: 5,\n    color: theme.palette.grey[300],\n    position: 'relative',\n    top: 1,\n  },\n  over: {},\n  zoomDisabled: {},\n  expandDisabled: {\n    // hide the whole component when:\n    // - both zoom and expand are disabled\n    // - expand is disabled and user is mobile\n    '$zoomDisabled&': {\n      display: 'none',\n    },\n    '@media (hover:none)': {\n      display: 'none',\n    },\n  },\n  zoomTextDesktop: {\n    display: 'block',\n    // hide zoom text when:\n    // - hovering + expand is enabled\n    // - zoom is disabled\n    // - mobile user\n    '$over:not($expandDisabled) &, $zoomDisabled &': {\n      display: 'none',\n    },\n    '@media (hover:none)': {\n      display: 'none',\n    },\n  },\n  expandTextMobile: {\n    display: 'none',\n    '@media (hover:none)': {\n      display: 'block',\n    },\n  },\n  expandTextDesktop: {\n    display: 'none',\n\n    '$over:not($expandDisabled) &, $zoomDisabled &': {\n      display: 'block',\n      '@media (hover:none)': {\n        display: 'none',\n      },\n    },\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFMagnifyHint' })\n\nexport default function MagnifyHint({\n  zoomTextDesktop,\n  expandTextMobile,\n  expandTextDesktop,\n  over,\n  className,\n  disableZoom,\n  disableExpand,\n}) {\n  const classes = useStyles()\n  disableZoom = disableZoom || useAmp()\n\n  return (\n    <div\n      className={clsx(className, {\n        [classes.root]: true,\n        [classes.over]: over,\n        [classes.zoomDisabled]: disableZoom,\n        [classes.expandDisabled]: disableExpand,\n      })}\n    >\n      <div className={classes.wrap}>\n        <Icon className={classes.icon} alt=\"magnify-icon\" />\n        <Typography variant=\"caption\" className={clsx(classes.text, classes.zoomTextDesktop)}>\n          {zoomTextDesktop}\n        </Typography>\n        <Typography variant=\"caption\" className={clsx(classes.text, classes.expandTextMobile)}>\n          {expandTextMobile}\n        </Typography>\n        <Typography variant=\"caption\" className={clsx(classes.text, classes.expandTextDesktop)}>\n          {expandTextDesktop}\n        </Typography>\n      </div>\n    </div>\n  )\n}\n\nMagnifyHint.propTypes = {\n  zoomTextDesktop: PropTypes.string,\n  expandTextMobile: PropTypes.string,\n  expandTextDesktop: PropTypes.string,\n  className: PropTypes.string,\n  open: PropTypes.bool,\n  disableZoom: PropTypes.bool,\n  disableExpand: PropTypes.bool,\n}\n\nMagnifyHint.defaultProps = {\n  zoomTextDesktop: 'Hover to Zoom',\n  expandTextMobile: 'Tap to Expand',\n  expandTextDesktop: 'Click to Expand',\n}\n",
      description: '',
      displayName: 'MagnifyHint',
      methods: [],
      props: [
        {
          name: 'zoomTextDesktop',
          type: { name: 'string' },
          required: false,
          description: '',
          defaultValue: { value: "'Hover to Zoom'", computed: false },
        },
        {
          name: 'expandTextMobile',
          type: { name: 'string' },
          required: false,
          description: '',
          defaultValue: { value: "'Tap to Expand'", computed: false },
        },
        {
          name: 'expandTextDesktop',
          type: { name: 'string' },
          required: false,
          description: '',
          defaultValue: { value: "'Click to Expand'", computed: false },
        },
        { name: 'className', type: { name: 'string' }, required: false, description: '' },
        { name: 'open', type: { name: 'bool' }, required: false, description: '' },
        { name: 'disableZoom', type: { name: 'bool' }, required: false, description: '' },
        { name: 'disableExpand', type: { name: 'bool' }, required: false, description: '' },
      ],
      styles: { classes: [], name: null },
      type: 'component',
      import: "import MagnifyHint from 'react-storefront/carousel/MagnifyHint'",
    },
    'carousel/Media': {
      name: 'Media',
      filename: 'Media',
      importPath: 'carousel/Media',
      src:
        "import React from 'react'\nimport Image from '../Image'\nimport ReactImageMagnify from 'react-image-magnify'\n\nexport default function Media({ magnifyProps, imageProps, src, alt, magnify, type = 'image' }) {\n  if (type === 'video') {\n    return <video src={src} alt={alt} />\n  } else if (magnify) {\n    return (\n      <ReactImageMagnify\n        enlargedImagePosition=\"over\"\n        {...magnifyProps}\n        smallImage={{\n          src: src,\n          alt: alt,\n          isFluidWidth: true,\n        }}\n        largeImage={magnify}\n      />\n    )\n  } else {\n    return <Image key={src} src={src} alt={alt} fill {...imageProps} />\n  }\n}\n",
      description: '',
      displayName: 'Media',
      methods: [],
      props: [
        { name: 'type', defaultValue: { value: "'image'", computed: false }, required: false },
      ],
      styles: { classes: [], name: null },
      type: 'component',
      import: "import Media from 'react-storefront/carousel/Media'",
    },
    'carousel/MediaCarousel': {
      name: 'MediaCarousel',
      filename: 'MediaCarousel',
      importPath: 'carousel/MediaCarousel',
      src:
        "import React, { useCallback, useEffect, useState, useRef } from 'react'\nimport clsx from 'clsx'\nimport { makeStyles, useTheme } from '@material-ui/core/styles'\nimport useMediaQuery from '@material-ui/core/useMediaQuery'\nimport Carousel from './Carousel'\nimport Image from '../Image'\nimport Lightbox from './Lightbox'\nimport Media from './Media'\nimport MagnifyHint from './MagnifyHint'\nimport CarouselThumbnails from './CarouselThumbnails'\nimport get from 'lodash/get'\n\nexport const styles = theme => ({\n  imageWrap: {\n    height: '100%',\n    width: '100%',\n    display: 'flex',\n    justifyContent: 'center',\n    alignItems: 'stretch',\n    '& img': {\n      maxHeight: '100%',\n      maxWidth: '100%',\n      objectFit: 'contain',\n    },\n  },\n  thumbnail: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    height: '100%',\n    width: '100%',\n  },\n  lightboxCarousel: {\n    flex: 1,\n    justifyContent: 'center',\n    overflow: 'hidden',\n    [theme.breakpoints.down('xs')]: {\n      margin: '0 !important',\n    },\n  },\n  lightboxThumbs: {\n    paddingBottom: theme.spacing(2),\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFMediaCarousel' })\n\n/**\n * A carousel that displays images and videos for a product.  Specify\n * images and videos via the media prop, which should be of the form:\n *\n * ```js\n *  <MediaCarousel\n *    media={[\n *      { src: 'https://domain.com/path/to/image.jpg', alt: 'Red Shirt', type: 'image' },\n *      { src: 'https://domain.com/path/to/image.mpeg', alt: 'Demonstration', type: 'video' },\n *    ]}\n *    thumbnail={{\n *      src: 'https://domain.com/path/to/thumbnail.jpg', alt: 'thumbnail'\n *    }}\n *  />\n * ```\n *\n * To display a low-res thumbnail while high res images are loading, specify a `thumbnail` prop with `src` and `alt`\n *\n * Alternatively, you can provide a `product` prop as an object with `media` and `thumbnail` values that\n * adhere to the formats described above.\n *\n * ```js\n *  <MediaCarousel\n *    product={{\n *      media: [\n *        { src: 'https://domain.com/path/to/image.jpg', alt: 'Red Shirt', type: 'image' },\n *        { src: 'https://domain.com/path/to/image.mpeg', alt: 'Demonstration', type: 'video' },\n *      ],\n *      thumbnail: {\n *        src: 'https://domain.com/path/to/thumbnail.jpg', alt: 'thumbnail'\n *      }\n *    }}\n *  />\n * ```\n */\nfunction MediaCarousel(props) {\n  let {\n    thumbnails,\n    thumbnail,\n    thumbsClassName,\n    magnifyHintClassName,\n    imageProps,\n    lightboxProps,\n    classes,\n    media,\n    magnifyProps,\n    id,\n    CarouselComponent,\n    MediaComponent,\n    CarouselThumbnailsComponent,\n    ...others\n  } = props\n\n  const [imagesLoaded, setImagesLoaded] = useState(false)\n  const styles = useStyles({ classes })\n  const ref = useRef(null)\n  const [over, setOver] = useState(false)\n  const [selected, setSelected] = useState(0)\n  const [lightboxActive, setLightboxActive] = useState()\n  const theme = useTheme()\n  const isSmall = useMediaQuery(theme.breakpoints.down('xs'))\n\n  useEffect(() => {\n    // Reset selection index when media changes\n    setSelected(0)\n  }, [media])\n\n  const timeout = useRef(null)\n\n  const handleMouseEnter = useCallback(() => {\n    timeout.current = window.setTimeout(() => {\n      setOver(true)\n      timeout.current = null\n    }, 250)\n  }, [])\n\n  const handleMouseLeave = useCallback(() => {\n    setOver(false)\n\n    if (timeout.current) {\n      window.clearTimeout(timeout.current)\n    }\n  }, [])\n\n  const onFullSizeImagesLoaded = useCallback(() => {\n    setImagesLoaded(true)\n  }, [])\n\n  const onClickCarousel = useCallback(evt => {\n    if (!evt.defaultPrevented) {\n      setLightboxActive(true)\n    }\n  })\n\n  useEffect(() => {\n    const firstImage = ref.current.querySelector('img')\n\n    if (firstImage) {\n      firstImage.addEventListener('load', onFullSizeImagesLoaded)\n      return () => firstImage.removeEventListener('load', onFullSizeImagesLoaded)\n    }\n  }, [])\n\n  const belowAdornments = []\n\n  if (thumbnail && !imagesLoaded) {\n    belowAdornments.push(<Image key=\"thumbnail\" className={styles.thumbnail} fill {...thumbnail} />)\n  }\n\n  if (media && media.full && media.full.some(item => item.magnify)) {\n    belowAdornments.push(\n      <MagnifyHint\n        key=\"magnify-hint\"\n        over={over}\n        disableExpand={lightboxActive}\n        className={magnifyHintClassName}\n      />,\n    )\n  }\n\n  if (lightboxActive) {\n    Object.assign(others, {\n      autoplay: false,\n      className: clsx(others.className, styles.lightboxCarousel),\n      height: isSmall ? '100%' : null,\n      slideStyle: { ...(others.slideStyle || {}), display: 'flex', justifyContent: 'center' },\n    })\n  }\n\n  const handleLightboxClose = useCallback(() => {\n    setLightboxActive(false)\n  }, [])\n\n  const body = (\n    <>\n      <CarouselComponent\n        id={id}\n        ref={ref}\n        belowAdornments={belowAdornments}\n        classes={classes}\n        onMouseEnter={handleMouseEnter}\n        onMouseLeave={handleMouseLeave}\n        onClick={onClickCarousel}\n        selected={selected}\n        setSelected={setSelected}\n        {...others}\n      >\n        {media &&\n          media.full &&\n          media.full.map((item, i) => (\n            <MediaComponent\n              key={i}\n              onLoad={i === 0 ? onFullSizeImagesLoaded : null}\n              magnifyProps={magnifyProps}\n              {...item}\n              magnify={lightboxActive && !isSmall ? false : item.magnify}\n              imageProps={\n                lightboxActive && !isSmall\n                  ? {\n                      fill: false,\n                      contain: true,\n                      src: get(item, 'magnify.src', item.src),\n                    }\n                  : item.imageProps\n              }\n            />\n          ))}\n      </CarouselComponent>\n      {thumbnails && media && (\n        <CarouselThumbnailsComponent\n          className={clsx(thumbsClassName, lightboxActive && styles.lightboxThumbs)}\n          bind={`${id}.index`}\n          carouselId={id}\n          selected={selected}\n          setSelected={setSelected}\n          thumbnails={media.thumbnails}\n        />\n      )}\n    </>\n  )\n\n  return (\n    <>\n      {body}\n      <Lightbox {...lightboxProps} open={!!lightboxActive} onClose={handleLightboxClose}>\n        {body}\n      </Lightbox>\n    </>\n  )\n}\n\nMediaCarousel.defaultProps = {\n  lightboxProps: {},\n  magnifyProps: {},\n  thumbnails: true,\n  MediaComponent: Media,\n  CarouselComponent: Carousel,\n  CarouselThumbnailsComponent: CarouselThumbnails,\n}\n\nexport default React.memo(MediaCarousel)\n",
      description:
        "A carousel that displays images and videos for a product.  Specify\nimages and videos via the media prop, which should be of the form:\n\n```js\n <MediaCarousel\n   media={[\n     { src: 'https://domain.com/path/to/image.jpg', alt: 'Red Shirt', type: 'image' },\n     { src: 'https://domain.com/path/to/image.mpeg', alt: 'Demonstration', type: 'video' },\n   ]}\n   thumbnail={{\n     src: 'https://domain.com/path/to/thumbnail.jpg', alt: 'thumbnail'\n   }}\n />\n```\n\nTo display a low-res thumbnail while high res images are loading, specify a `thumbnail` prop with `src` and `alt`\n\nAlternatively, you can provide a `product` prop as an object with `media` and `thumbnail` values that\nadhere to the formats described above.\n\n```js\n <MediaCarousel\n   product={{\n     media: [\n       { src: 'https://domain.com/path/to/image.jpg', alt: 'Red Shirt', type: 'image' },\n       { src: 'https://domain.com/path/to/image.mpeg', alt: 'Demonstration', type: 'video' },\n     ],\n     thumbnail: {\n       src: 'https://domain.com/path/to/thumbnail.jpg', alt: 'thumbnail'\n     }\n   }}\n />\n```",
      displayName: 'MediaCarousel',
      methods: [],
      props: [
        { name: 'lightboxProps', defaultValue: { value: '{}', computed: false }, required: false },
        { name: 'magnifyProps', defaultValue: { value: '{}', computed: false }, required: false },
        { name: 'thumbnails', defaultValue: { value: 'true', computed: false }, required: false },
        {
          name: 'MediaComponent',
          defaultValue: { value: 'Media', computed: true },
          required: false,
        },
        {
          name: 'CarouselComponent',
          defaultValue: { value: 'Carousel', computed: true },
          required: false,
        },
        {
          name: 'CarouselThumbnailsComponent',
          defaultValue: { value: 'CarouselThumbnails', computed: true },
          required: false,
        },
      ],
      styles: {
        classes: [
          { ruleName: 'imageWrap', globalClass: '.RSFMediaCarousel-imageWrap', description: '' },
          { ruleName: 'thumbnail', globalClass: '.RSFMediaCarousel-thumbnail', description: '' },
          {
            ruleName: 'lightboxCarousel',
            globalClass: '.RSFMediaCarousel-lightboxCarousel',
            description: '',
          },
          {
            ruleName: 'lightboxThumbs',
            globalClass: '.RSFMediaCarousel-lightboxThumbs',
            description: '',
          },
        ],
      },
      type: 'component',
      import: "import MediaCarousel from 'react-storefront/carousel/MediaCarousel'",
    },
    'drawer/Drawer': {
      name: 'Drawer',
      filename: 'Drawer',
      importPath: 'drawer/Drawer',
      src:
        "import React, { useRef, useEffect, useCallback } from 'react'\nimport ResizeObserver from 'resize-observer-polyfill'\nimport { Drawer as MUIDrawer, Typography } from '@material-ui/core'\nimport { makeStyles, useTheme } from '@material-ui/core/styles'\nimport PropTypes from 'prop-types'\nimport clsx from 'clsx'\nimport DrawerCloseButton from './DrawerCloseButton'\n\n/**\n * A slide-in drawer with fab close button.\n */\nexport const styles = theme => ({\n  root: {},\n\n  closeButton: {},\n\n  fullscreen: {\n    height: '100vh',\n  },\n\n  header: {\n    position: 'relative',\n  },\n\n  container: {\n    height: '100%',\n    boxSizing: 'border-box',\n    flexWrap: 'nowrap',\n    display: 'flex',\n    flexDirection: 'column',\n  },\n\n  content: {\n    flexBasis: '100%',\n    overflow: 'auto',\n  },\n\n  paper: {\n    overflowY: 'visible',\n  },\n\n  title: {\n    flexBasis: 'auto',\n    flexGrow: 0,\n    flexShrink: 1,\n    width: '100%',\n    height: '72px',\n    lineHeight: '72px',\n    textAlign: 'center',\n    borderBottom: `1px solid ${theme.palette.divider}`,\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFDrawer' })\n\nexport default function Drawer({\n  variant,\n  closeButtonProps,\n  showCloseButton,\n  open,\n  onClose,\n  title,\n  children,\n  className,\n  classes,\n  autoAdjustBodyPadding,\n  anchor,\n  fullscreen,\n  ...rest\n}) {\n  classes = useStyles({ classes })\n\n  const theme = useTheme()\n  const drawer = useRef(null)\n  const drawerResize = useRef(null)\n\n  const setPadding = useCallback(() => {\n    if (autoAdjustBodyPadding) {\n      requestAnimationFrame(() => {\n        const el = drawer.current\n        document.body.style.paddingBottom = el && el.clientHeight + 'px'\n      })\n    }\n  }, [autoAdjustBodyPadding])\n\n  const closeDrawer = useCallback(() => {\n    if (onClose) {\n      onClose()\n    }\n\n    document.body.style.paddingBottom = 0\n  }, [onClose])\n\n  useEffect(() => {\n    const el = drawer.current\n\n    setPadding()\n\n    if (autoAdjustBodyPadding && el) {\n      drawerResize.current = new ResizeObserver(() => {\n        document.body.style.paddingBottom = el && el.clientHeight + 'px'\n      })\n      drawerResize.observe(el)\n    }\n\n    return () => {\n      if (drawerResize.current && el) {\n        drawerResize.current.unobserve(el)\n      }\n    }\n  }, [])\n\n  // useEffect(() => {\n  //   if (open) {\n  //     setPadding()\n  //   } else {\n  //     closeDrawer()\n  //   }\n  // }, [open])\n\n  return (\n    <MUIDrawer\n      elevation={2}\n      anchor={anchor}\n      style={{\n        zIndex: theme.zIndex.modal + 20,\n      }}\n      classes={{\n        root: clsx({\n          className,\n          [classes.root]: true,\n        }),\n        paper: clsx({\n          [classes.paper]: true,\n          [classes.fullscreen]: fullscreen,\n        }),\n      }}\n      open={open}\n      variant={variant}\n      onClose={onClose}\n      {...rest}\n    >\n      <div className={classes.container} ref={drawer}>\n        <div className={classes.header}>\n          {title && (\n            <Typography className={classes.title} variant=\"h6\" component=\"div\">\n              {title}\n            </Typography>\n          )}\n          {showCloseButton && (\n            <DrawerCloseButton\n              onClick={closeDrawer}\n              fullscreen={fullscreen}\n              open={open}\n              className={clsx(classes.closeButton)}\n            />\n          )}\n        </div>\n        <div className={classes.content}>{children}</div>\n      </div>\n    </MUIDrawer>\n  )\n}\nDrawer.propTypes = {\n  /**\n   * Set to false to hide the close button. Defaults to true\n   */\n  showCloseButton: PropTypes.bool,\n\n  /**\n   * Called when the user closes the drawer\n   */\n  onClose: PropTypes.func.isRequired,\n\n  /**\n   * The title to display at the top of the drawer\n   */\n  title: PropTypes.oneOfType([PropTypes.string, PropTypes.element]),\n\n  /**\n   * Set to true to automatically add padding to the body when the drawer\n   * is open so that the user is able to scroll and see all of the body content.\n   * Defaults to false.\n   */\n  autoAdjustBodyPadding: PropTypes.bool,\n\n  /**\n   * Props to apply to the closeButton\n   */\n  closeButtonProps: PropTypes.object,\n\n  /**\n   * Side from which the drawer will appear (top, left, right, bottom). Defaults to 'bottom'\n   */\n  anchor: PropTypes.string,\n}\n\nDrawer.defaultProps = {\n  showCloseButton: true,\n  autoAdjustBodyPadding: false,\n  closeButtonProps: {},\n  variant: 'temporary',\n  anchor: 'bottom',\n}\n",
      description: '',
      displayName: 'Drawer',
      methods: [],
      props: [
        {
          name: 'showCloseButton',
          type: { name: 'bool' },
          required: false,
          description: 'Set to false to hide the close button. Defaults to true',
          defaultValue: { value: 'true', computed: false },
        },
        {
          name: 'onClose',
          type: { name: 'func' },
          required: true,
          description: 'Called when the user closes the drawer',
        },
        {
          name: 'title',
          type: { name: 'union', value: [{ name: 'string' }, { name: 'element' }] },
          required: false,
          description: 'The title to display at the top of the drawer',
        },
        {
          name: 'autoAdjustBodyPadding',
          type: { name: 'bool' },
          required: false,
          description:
            'Set to true to automatically add padding to the body when the drawer\nis open so that the user is able to scroll and see all of the body content.\nDefaults to false.',
          defaultValue: { value: 'false', computed: false },
        },
        {
          name: 'closeButtonProps',
          type: { name: 'object' },
          required: false,
          description: 'Props to apply to the closeButton',
          defaultValue: { value: '{}', computed: false },
        },
        {
          name: 'anchor',
          type: { name: 'string' },
          required: false,
          description:
            "Side from which the drawer will appear (top, left, right, bottom). Defaults to 'bottom'",
          defaultValue: { value: "'bottom'", computed: false },
        },
        {
          name: 'variant',
          defaultValue: { value: "'temporary'", computed: false },
          required: false,
        },
      ],
      styles: {
        classes: [
          { ruleName: 'root', globalClass: '.RSFDrawer-root', description: '' },
          { ruleName: 'closeButton', globalClass: '.RSFDrawer-closeButton', description: '' },
          { ruleName: 'fullscreen', globalClass: '.RSFDrawer-fullscreen', description: '' },
          { ruleName: 'header', globalClass: '.RSFDrawer-header', description: '' },
          { ruleName: 'container', globalClass: '.RSFDrawer-container', description: '' },
          { ruleName: 'content', globalClass: '.RSFDrawer-content', description: '' },
          { ruleName: 'paper', globalClass: '.RSFDrawer-paper', description: '' },
          { ruleName: 'title', globalClass: '.RSFDrawer-title', description: '' },
        ],
        name: 'Drawer',
      },
      type: 'component',
      import: "import Drawer from 'react-storefront/drawer/Drawer'",
    },
    'drawer/DrawerCloseButton': {
      name: 'DrawerCloseButton',
      filename: 'DrawerCloseButton',
      importPath: 'drawer/DrawerCloseButton',
      src:
        "import React from 'react'\nimport { makeStyles } from '@material-ui/core/styles'\nimport PropTypes from 'prop-types'\nimport clsx from 'clsx'\nimport { Clear as ClearIcon } from '@material-ui/icons'\nimport { Fab, IconButton, Button } from '@material-ui/core'\n\nexport const styles = theme => ({\n  button: {\n    color: '#999',\n    alignSelf: 'flex-end',\n    position: 'absolute',\n    top: 0,\n    right: 0,\n    zIndex: 1,\n    '& span': {\n      textTransform: 'uppercase',\n      fontWeight: 'bold',\n    },\n  },\n  buttonText: {\n    border: `1px solid #999`,\n    margin: '0 0 10px 0',\n  },\n  buttonFab: {\n    position: 'absolute',\n    right: '10px',\n    top: '-28px',\n    zIndex: 1,\n  },\n  hidden: {\n    display: 'none',\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFDrawerCloseButton' })\n\n/**\n * A close button for drawers that can display text or an icon.\n */\nexport default function DrawerCloseButton({\n  classes,\n  className,\n  ampState,\n  onClick,\n  text,\n  Icon,\n  fullscreen,\n  open,\n  contrast,\n  ...others\n}) {\n  classes = useStyles({ classes })\n\n  let ButtonElement\n\n  if (text) {\n    ButtonElement = Button\n  } else if (fullscreen) {\n    ButtonElement = IconButton\n  } else {\n    ButtonElement = props => (\n      <Fab color=\"primary\" className={clsx(!open && classes.hidden)} {...props}>\n        <Icon />\n      </Fab>\n    )\n  }\n\n  return (\n    <ButtonElement\n      color=\"primary\"\n      on={`tap:AMP.setState({ ${ampState}: { open: false } })`}\n      className={clsx(className, {\n        [classes.button]: true,\n        [classes.buttonText]: text != null,\n        [classes.buttonFab]: text == null && !fullscreen,\n      })}\n      onClick={onClick}\n      {...others}\n    >\n      {text || <Icon />}\n    </ButtonElement>\n  )\n}\n\nDrawerCloseButton.propTypes = {\n  /**\n   * The name of the amp state corresponding to the drawer\n   */\n  ampState: PropTypes.string,\n\n  /**\n   * Fired when the button is clicked.  Call `e.preventDefault()` on the\n   * provided event to prevent the drawer from closing.\n   */\n  onClick: PropTypes.func,\n\n  /**\n   * When set, this text will be displayed instead of an icon.\n   */\n  text: PropTypes.string,\n\n  /**\n   * Overrides the default icon\n   */\n  Icon: PropTypes.elementType,\n\n  /**\n   * Set to `true` when the drawer is open\n   */\n  open: PropTypes.bool,\n}\n\nDrawerCloseButton.defaultProps = {\n  Icon: ClearIcon,\n  open: false,\n}\n",
      description: 'A close button for drawers that can display text or an icon.',
      displayName: 'DrawerCloseButton',
      methods: [],
      props: [
        {
          name: 'ampState',
          type: { name: 'string' },
          required: false,
          description: 'The name of the amp state corresponding to the drawer',
        },
        {
          name: 'onClick',
          type: { name: 'func' },
          required: false,
          description:
            'Fired when the button is clicked.  Call `e.preventDefault()` on the\nprovided event to prevent the drawer from closing.',
        },
        {
          name: 'text',
          type: { name: 'string' },
          required: false,
          description: 'When set, this text will be displayed instead of an icon.',
        },
        {
          name: 'Icon',
          type: { name: 'elementType' },
          required: false,
          description: 'Overrides the default icon',
          defaultValue: { value: 'ClearIcon', computed: true },
        },
        {
          name: 'open',
          type: { name: 'bool' },
          required: false,
          description: 'Set to `true` when the drawer is open',
          defaultValue: { value: 'false', computed: false },
        },
      ],
      styles: {
        classes: [
          { ruleName: 'button', globalClass: '.RSFDrawerCloseButton-button', description: '' },
          {
            ruleName: 'buttonText',
            globalClass: '.RSFDrawerCloseButton-buttonText',
            description: '',
          },
          {
            ruleName: 'buttonFab',
            globalClass: '.RSFDrawerCloseButton-buttonFab',
            description: '',
          },
          { ruleName: 'hidden', globalClass: '.RSFDrawerCloseButton-hidden', description: '' },
        ],
        name: 'DrawerCloseButton',
      },
      type: 'component',
      import: "import DrawerCloseButton from 'react-storefront/drawer/DrawerCloseButton'",
    },
    'link/Link': {
      name: 'Link',
      filename: 'Link',
      importPath: 'link/Link',
      src:
        "import React, { useContext, useRef, useEffect } from 'react'\nimport NextLink from 'next/link'\nimport LinkContext from './LinkContext'\nimport PropTypes from 'prop-types'\nimport useIntersectionObserver from '../hooks/useIntersectionObserver'\nimport { prefetch as doPrefetch } from '../serviceWorker'\nimport withDefaultHandler from '../utils/withDefaultHandler'\n\n/**\n * Use this component for all Links in your React Storefront app.  You can\n * pass props to display on the next page while data is loading from the server\n * using the `pageData` prop. This component accepts all props that would\n * normally be passed to a Next.js `Link` component.  All other props are spread\n * to the underlying HTML anchor element.\n *\n * Example:\n *\n * ```js\n * import Link from 'react-storefront/link/Link'\n *\n * <Link href=\"/p/[productId]\" as={`/p/${product.id}`} pageData={{ product }}>\n *   {product.name}\n * </Link>\n * ```\n */\nconst Link = ({\n  as,\n  href,\n  prefetch,\n  prefetchURL,\n  pageData,\n  onClick,\n  anchorProps,\n  children,\n  ...other\n}) => {\n  const ref = useRef(null)\n  const linkPageData = useContext(LinkContext)\n\n  const handleClick = withDefaultHandler(onClick, () => {\n    if (linkPageData) {\n      linkPageData.current = pageData\n    }\n  })\n\n  useIntersectionObserver(\n    () => (as && prefetch === 'visible' ? ref : null),\n    (visible, disconnect) => {\n      if (visible) {\n        disconnect()\n        doPrefetch(prefetchURL || `/api${as}`)\n      }\n    },\n    [as, prefetch],\n  )\n\n  useEffect(() => {\n    if (prefetch === 'always') {\n      doPrefetch(`/api${as}`)\n    }\n  }, [as])\n\n  if (!children || typeof children === 'string') {\n    return (\n      <NextLink href={href} prefetch={false} as={as} passHref>\n        <a ref={ref} {...other} onClick={handleClick}>\n          {children}\n        </a>\n      </NextLink>\n    )\n  } else {\n    return (\n      <NextLink href={href} prefetch={false} as={as} passHref>\n        {React.cloneElement(children, { ref, onClick: handleClick, ...other })}\n      </NextLink>\n    )\n  }\n}\n\nLink.propTypes = {\n  /**\n   * The URL path for the underlying anchor element's href.  This is required for dynamic routes.\n   */\n  as: PropTypes.string,\n\n  /**\n   * The next.js route pattern\n   */\n  href: PropTypes.string.isRequired,\n\n  /**\n   * Set to `visible` to prefetch the JSON data for the destination page component when the link\n   * is scrolled into the viewport.  Set to `always` to prefetch the data immediately. Set to\n   * `false` to never prefetch.\n   */\n  prefetch: PropTypes.oneOf(['always', 'visible', false]),\n\n  /**\n   * The URL to prefetch.  If omitted, /api/{href} will be prefetched.\n   */\n  prefetchURL: PropTypes.string,\n\n  /**\n   * Data to be added to the `pageData` key returned by `react-storefront/hooks/useLazyStore` in the\n   * destination page component.  Use this to display partial data in the skeleton while the full dataset\n   * is fetched from the server.\n   */\n  pageData: PropTypes.object,\n}\n\nexport default Link\n",
      description:
        'Use this component for all Links in your React Storefront app.  You can\npass props to display on the next page while data is loading from the server\nusing the `pageData` prop. This component accepts all props that would\nnormally be passed to a Next.js `Link` component.  All other props are spread\nto the underlying HTML anchor element.\n\nExample:\n\n```js\nimport Link from \'react-storefront/link/Link\'\n\n<Link href="/p/[productId]" as={`/p/${product.id}`} pageData={{ product }}>\n  {product.name}\n</Link>\n```',
      displayName: 'Link',
      methods: [],
      props: [
        {
          name: 'as',
          type: { name: 'string' },
          required: false,
          description:
            "The URL path for the underlying anchor element's href.  This is required for dynamic routes.",
        },
        {
          name: 'href',
          type: { name: 'string' },
          required: true,
          description: 'The next.js route pattern',
        },
        {
          name: 'prefetch',
          type: {
            name: 'enum',
            value: [
              { value: "'always'", computed: false },
              { value: "'visible'", computed: false },
              { value: 'false', computed: false },
            ],
          },
          required: false,
          description:
            'Set to `visible` to prefetch the JSON data for the destination page component when the link\nis scrolled into the viewport.  Set to `always` to prefetch the data immediately. Set to\n`false` to never prefetch.',
        },
        {
          name: 'prefetchURL',
          type: { name: 'string' },
          required: false,
          description: 'The URL to prefetch.  If omitted, /api/{href} will be prefetched.',
        },
        {
          name: 'pageData',
          type: { name: 'object' },
          required: false,
          description:
            'Data to be added to the `pageData` key returned by `react-storefront/hooks/useLazyStore` in the\ndestination page component.  Use this to display partial data in the skeleton while the full dataset\nis fetched from the server.',
        },
      ],
      styles: { classes: [], name: null },
      type: 'component',
      import: "import Link from 'react-storefront/link/Link'",
    },
    'link/LinkContextProvider': {
      name: 'LinkContextProvider',
      filename: 'LinkContextProvider',
      importPath: 'link/LinkContextProvider',
      src:
        "import React, { useEffect, useRef } from 'react'\nimport LinkContext from './LinkContext'\nimport Router from 'next/router'\n\n/**\n * Provides a context that allows links to pass data directly to pages via the `pageData` prop.\n */\nexport default function LinkContextProvider({ children }) {\n  const linkPageData = useRef(null)\n\n  useEffect(() => {\n    const onRouteChangeComplete = () => (linkPageData.current = undefined)\n    Router.events.on('routeChangeComplete', onRouteChangeComplete)\n\n    return () => {\n      Router.events.off('routeChangeComplete', onRouteChangeComplete)\n    }\n  }, [])\n\n  return <LinkContext.Provider value={linkPageData}>{children}</LinkContext.Provider>\n}\n",
      description:
        'Provides a context that allows links to pass data directly to pages via the `pageData` prop.',
      displayName: 'LinkContextProvider',
      methods: [],
      styles: { classes: [], name: null },
      props: [],
      type: 'component',
      import: "import LinkContextProvider from 'react-storefront/link/LinkContextProvider'",
    },
    'menu/Menu': {
      name: 'Menu',
      filename: 'Menu',
      importPath: 'menu/Menu',
      src:
        "import React, { useMemo, useState, useRef, useEffect } from 'react'\nimport { makeStyles } from '@material-ui/core/styles'\nimport menuStyles from './menuStyles'\nimport MenuContext from './MenuContext'\nimport { Drawer } from '@material-ui/core'\nimport clsx from 'clsx'\nimport SEOLinks from './SEOLinks'\nimport MenuBody from './MenuBody'\nimport PropTypes from 'prop-types'\n\nexport const styles = menuStyles\n\nconst useStyles = makeStyles(styles, { name: 'RSFMenu' })\n\nconst Menu = React.memo(props => {\n  let {\n    classes,\n    className,\n    anchor,\n    drawerWidth,\n    persistent,\n    root,\n    open,\n    onClose,\n    renderFooter,\n    renderHeader,\n    renderItem,\n    renderItemContent,\n    renderDrawer,\n    ...others\n  } = props\n\n  classes = useStyles({ classes })\n\n  const [state, setState] = useState(() => {\n    return {\n      card: 0,\n      cards: [{ ...root, root: true }],\n    }\n  })\n\n  // this is needed so we can always update the *current* state, not the snapshot that\n  // was present when the callbacks were memoized\n  const stateRef = useRef(state)\n\n  useEffect(() => {\n    stateRef.current = state\n  }, [state])\n\n  // this ensures that the expanded state is reset when showing a new card\n  const nextKey = useRef(0)\n\n  const onItemClick = (item, depth) => {\n    const cards = [...stateRef.current.cards]\n    const card = depth + 1\n\n    item.key = nextKey.current++ // this ensures that the expanded state is reset when showing a new card\n\n    if (card >= cards.length) {\n      cards.push(item)\n    } else {\n      cards[card] = item\n    }\n\n    setState({\n      card,\n      cards: cards.slice(0, card + 1),\n    })\n  }\n\n  const goBack = card => {\n    setState({\n      card,\n      cards: stateRef.current.cards,\n    })\n  }\n\n  // it is implortant to memoize the context, otherwise it will cause all consumers rerender\n  // every time Menu rerenders\n  const context = useMemo(\n    () => ({\n      classes,\n      onItemClick,\n      goBack,\n      renderFooter,\n      renderHeader,\n      renderItem,\n      renderItemContent,\n      close: onClose,\n      drawerWidth,\n    }),\n    [classes],\n  )\n\n  return (\n    <>\n      <MenuContext.Provider value={context}>\n        {renderDrawer ? (\n          renderDrawer()\n        ) : (\n          <Drawer\n            variant={persistent ? 'persistent' : 'temporary'}\n            open={open || persistent}\n            onClose={onClose}\n            anchor={anchor}\n            ModalProps={{\n              keepMounted: true,\n            }}\n            PaperProps={{\n              style: { width: `${drawerWidth}px` },\n            }}\n            classes={{\n              root: className,\n              paper: clsx(classes.drawer, {\n                [classes.drawerFixed]: persistent,\n              }),\n              modal: classes.modal,\n            }}\n          >\n            <MenuBody\n              card={state.card}\n              cards={state.cards}\n              root={root}\n              drawerWidth={drawerWidth}\n              {...others}\n            />\n          </Drawer>\n        )}\n        <SEOLinks root={root} />\n      </MenuContext.Provider>\n    </>\n  )\n})\n\nMenu.propTypes = {\n  root: PropTypes.object,\n\n  /**\n   * The width of the drawer in pixels\n   */\n  drawerWidth: PropTypes.number,\n\n  /**\n   * An element to display at the top of the root of the menu\n   */\n  rootHeader: PropTypes.element,\n\n  /**\n   * An element to display at the bottom of the root of the menu\n   */\n  rootFooter: PropTypes.element,\n\n  /**\n   * A function to render a custom header in menu cards.  It is passed an object\n   * with:\n   *\n   * - item: The menu item record being rendered\n   *\n   * The function should return a React element or fragment.\n   */\n  renderHeader: PropTypes.func,\n\n  /**\n   * A function to render a custom footer menu cards.  It is passed an object\n   * with:\n   *\n   * - item: The menu item record being rendered\n   *\n   * The function should return a React element or fragment.\n   */\n  renderFooter: PropTypes.func,\n\n  /**\n   * Set to true to display the menu\n   */\n  open: PropTypes.bool,\n\n  /**\n   * Set to true to dock the menu so that it's always open and not modal\n   */\n  persistent: PropTypes.bool,\n\n  /**\n   * CSS classes for this component\n   */\n  classes: PropTypes.objectOf(PropTypes.string),\n\n  /**\n   * Called when the menu is closed\n   */\n  onClose: PropTypes.func,\n\n  /**\n   * The icon to use for collapsed groups\n   */\n  ExpandIcon: PropTypes.func,\n\n  /**\n   * The icon to use for expanded groups\n   */\n  CollapseIcon: PropTypes.func,\n\n  /**\n   * Sets the side of the screen from which the menu appears.\n   */\n  anchor: PropTypes.oneOf(['left', 'right']),\n\n  /**\n   * Overrides the default rendering of a menu item.  It is passed the following arguments:\n   *\n   * - item - the menu item record being rendered.\n   *\n   * Return undefined to render the default contents\n   *\n   * Example:\n   *\n   * ```js\n   *  renderItem={item => {\n   *    return item.text === 'My Special Item ? <MySpecialItem/> : null\n   *  }}\n   * ```\n   */\n  renderItem: PropTypes.func,\n\n  /**\n   * Overrides the content of a menu item.  It is passed the following arguments:\n   *\n   * - item - the menu item record being rendered.\n   *\n   * Return null to render the default contents\n   *\n   * Example:\n   *\n   * ```js\n   *  renderItemContent={item => {\n   *    return leaf ? <ListItemText primary={item.text}/> : null\n   *  }}\n   * ```\n   */\n  renderItemContent: PropTypes.func,\n\n  /**\n   * Set to `true` to show the item corresponding to the current URL as selected.\n   */\n  trackSelected: PropTypes.bool,\n\n  /**\n   * A function to override the rendering the drawer\n   */\n  renderDrawer: PropTypes.func,\n}\n\nMenu.defaultProps = {\n  drawerWidth: 330,\n  anchor: 'left',\n  trackSelected: false,\n  DrawerComponent: Drawer,\n}\n\nexport default Menu\n",
      description: '',
      displayName: 'Menu',
      methods: [],
      props: [
        { name: 'root', type: { name: 'object' }, required: false, description: '' },
        {
          name: 'drawerWidth',
          type: { name: 'number' },
          required: false,
          description: 'The width of the drawer in pixels',
          defaultValue: { value: '330', computed: false },
        },
        {
          name: 'rootHeader',
          type: { name: 'element' },
          required: false,
          description: 'An element to display at the top of the root of the menu',
        },
        {
          name: 'rootFooter',
          type: { name: 'element' },
          required: false,
          description: 'An element to display at the bottom of the root of the menu',
        },
        {
          name: 'renderHeader',
          type: { name: 'func' },
          required: false,
          description:
            'A function to render a custom header in menu cards.  It is passed an object\nwith:\n\n- item: The menu item record being rendered\n\nThe function should return a React element or fragment.',
        },
        {
          name: 'renderFooter',
          type: { name: 'func' },
          required: false,
          description:
            'A function to render a custom footer menu cards.  It is passed an object\nwith:\n\n- item: The menu item record being rendered\n\nThe function should return a React element or fragment.',
        },
        {
          name: 'open',
          type: { name: 'bool' },
          required: false,
          description: 'Set to true to display the menu',
        },
        {
          name: 'persistent',
          type: { name: 'bool' },
          required: false,
          description: "Set to true to dock the menu so that it's always open and not modal",
        },
        {
          name: 'classes',
          type: { name: 'objectOf', value: { name: 'string' } },
          required: false,
          description: 'CSS classes for this component',
        },
        {
          name: 'onClose',
          type: { name: 'func' },
          required: false,
          description: 'Called when the menu is closed',
        },
        {
          name: 'ExpandIcon',
          type: { name: 'func' },
          required: false,
          description: 'The icon to use for collapsed groups',
        },
        {
          name: 'CollapseIcon',
          type: { name: 'func' },
          required: false,
          description: 'The icon to use for expanded groups',
        },
        {
          name: 'anchor',
          type: {
            name: 'enum',
            value: [
              { value: "'left'", computed: false },
              { value: "'right'", computed: false },
            ],
          },
          required: false,
          description: 'Sets the side of the screen from which the menu appears.',
          defaultValue: { value: "'left'", computed: false },
        },
        {
          name: 'renderItem',
          type: { name: 'func' },
          required: false,
          description:
            "Overrides the default rendering of a menu item.  It is passed the following arguments:\n\n- item - the menu item record being rendered.\n\nReturn undefined to render the default contents\n\nExample:\n\n```js\n renderItem={item => {\n   return item.text === 'My Special Item ? <MySpecialItem/> : null\n }}\n```",
        },
        {
          name: 'renderItemContent',
          type: { name: 'func' },
          required: false,
          description:
            'Overrides the content of a menu item.  It is passed the following arguments:\n\n- item - the menu item record being rendered.\n\nReturn null to render the default contents\n\nExample:\n\n```js\n renderItemContent={item => {\n   return leaf ? <ListItemText primary={item.text}/> : null\n }}\n```',
        },
        {
          name: 'trackSelected',
          type: { name: 'bool' },
          required: false,
          description:
            'Set to `true` to show the item corresponding to the current URL as selected.',
          defaultValue: { value: 'false', computed: false },
        },
        {
          name: 'renderDrawer',
          type: { name: 'func' },
          required: false,
          description: 'A function to override the rendering the drawer',
        },
        {
          name: 'DrawerComponent',
          defaultValue: { value: 'Drawer', computed: true },
          required: false,
        },
      ],
      styles: {
        classes: [
          { ruleName: 'drawer', globalClass: '.RSFMenu-drawer', description: '' },
          { ruleName: 'list', globalClass: '.RSFMenu-list', description: '' },
          { ruleName: 'listPadding', globalClass: '.RSFMenu-listPadding', description: '' },
          { ruleName: 'header', globalClass: '.RSFMenu-header', description: '' },
          { ruleName: 'icon', globalClass: '.RSFMenu-icon', description: '' },
          { ruleName: 'headerText', globalClass: '.RSFMenu-headerText', description: '' },
          { ruleName: 'bodyWrap', globalClass: '.RSFMenu-bodyWrap', description: '' },
          { ruleName: 'hidden', globalClass: '.RSFMenu-hidden', description: '' },
          { ruleName: 'visible', globalClass: '.RSFMenu-visible', description: '' },
          { ruleName: 'link', globalClass: '.RSFMenu-link', description: '' },
          { ruleName: 'leaf', globalClass: '.RSFMenu-leaf', description: '' },
          { ruleName: 'drawerFixed', globalClass: '.RSFMenu-drawerFixed', description: '' },
        ],
      },
      type: 'component',
      import: "import Menu from 'react-storefront/menu/Menu'",
    },
    'menu/MenuBack': {
      name: 'MenuBack',
      filename: 'MenuBack',
      importPath: 'menu/MenuBack',
      src:
        "import React, { useContext } from 'react'\nimport MenuContext from './MenuContext'\nimport PropTypes from 'prop-types'\nimport { ListItem, ListItemIcon, ListItemText } from '@material-ui/core'\nimport { ChevronLeft } from '@material-ui/icons'\n\nexport default function MenuBack({ goBack, item, backButtonProps }) {\n  const { classes } = useContext(MenuContext)\n\n  return (\n    <ListItem divider button onClick={goBack} {...backButtonProps}>\n      <ListItemIcon classes={{ root: classes.header }}>\n        <ChevronLeft className={classes.icon} />\n      </ListItemIcon>\n      <ListItemText\n        classes={{ root: classes.headerText }}\n        primary={<div className={classes.headerText}>{item.text} </div>}\n      />\n    </ListItem>\n  )\n}\n\nMenuBack.propTypes = {\n  /**\n   * Goes back to the previous item in the menu hierarchy\n   */\n  goBack: PropTypes.func,\n  /**\n   * The menu item being rendered\n   */\n  item: PropTypes.shape({\n    text: PropTypes.string,\n  }).isRequired,\n}\n",
      description: '',
      displayName: 'MenuBack',
      methods: [],
      props: [
        {
          name: 'goBack',
          type: { name: 'func' },
          required: false,
          description: 'Goes back to the previous item in the menu hierarchy',
        },
        {
          name: 'item',
          type: { name: 'shape', value: { text: { name: 'string', required: false } } },
          required: true,
          description: 'The menu item being rendered',
        },
      ],
      styles: { classes: [], name: null },
      type: 'component',
      import: "import MenuBack from 'react-storefront/menu/MenuBack'",
    },
    'menu/MenuBody': {
      name: 'MenuBody',
      filename: 'MenuBody',
      importPath: 'menu/MenuBody',
      src:
        "import React, { useContext } from 'react'\nimport MenuContext from './MenuContext'\nimport PropTypes from 'prop-types'\nimport MenuCard from './MenuCard'\n\nconst MenuBody = React.memo(\n  ({ CardComponent, wrapProps, card, cards, rootHeader, rootFooter, children }) => {\n    const { classes, drawerWidth } = useContext(MenuContext)\n    const position = -drawerWidth * card\n\n    return (\n      <>\n        {children}\n        <div\n          className={classes.bodyWrap}\n          style={{ transform: `translateX(${position}px)` }}\n          {...wrapProps}\n        >\n          {cards.map((item, depth) => (\n            <CardComponent\n              card={card}\n              key={depth}\n              item={item}\n              depth={depth}\n              rootHeader={rootHeader}\n              rootFooter={rootFooter}\n            />\n          ))}\n        </div>\n      </>\n    )\n  },\n)\n\nMenuBody.propTypes = {\n  /**\n   * Additional props for the wrap element\n   */\n  wrapProps: PropTypes.object,\n\n  /**\n   * Overrides the default component used to display menu cards\n   */\n  CardComponent: PropTypes.func.isRequired,\n}\n\nMenuBody.defaultProps = {\n  wrapProps: {},\n  CardComponent: MenuCard,\n}\n\nexport default MenuBody\n",
      description: '',
      displayName: 'MenuBody',
      methods: [],
      props: [
        {
          name: 'wrapProps',
          type: { name: 'object' },
          required: false,
          description: 'Additional props for the wrap element',
          defaultValue: { value: '{}', computed: false },
        },
        {
          name: 'CardComponent',
          type: { name: 'func' },
          required: false,
          description: 'Overrides the default component used to display menu cards',
          defaultValue: { value: 'MenuCard', computed: true },
        },
      ],
      styles: { classes: [], name: null },
      type: 'component',
      import: "import MenuBody from 'react-storefront/menu/MenuBody'",
    },
    'menu/MenuBranch': {
      name: 'MenuBranch',
      filename: 'MenuBranch',
      importPath: 'menu/MenuBranch',
      src:
        "import React from 'react'\nimport MenuItemContent from './MenuItemContent'\nimport ExpandableSection from '../ExpandableSection'\nimport PropTypes from 'prop-types'\nimport makeStyles from '@material-ui/core/styles/makeStyles'\nimport MenuLeaf from './MenuLeaf'\n\nexport const styles = theme => ({\n  expander: {\n    borderBottom: 'none',\n  },\n\n  expanderMargins: {\n    padding: 0,\n  },\n\n  expanderSummary: {\n    textTransform: 'uppercase',\n    '&:first-child': {\n      padding: `10px ${theme.spacing(2)}px`,\n      borderBottom: `1px solid ${theme.palette.divider}`,\n    },\n  },\n\n  expanderSummaryExpanded: {\n    backgroundColor: theme.palette.secondary.main,\n    color: theme.palette.secondary.contrastText,\n  },\n\n  expanderIconExpanded: {\n    color: theme.palette.secondary.contrastText,\n  },\n\n  expanderDetails: {\n    '$expander &': {\n      paddingBottom: 0,\n    },\n  },\n\n  expanderContent: {\n    textTransform: 'none',\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFMenuBranch' })\n\nconst MenuBranch = React.memo(props => {\n  const { depth, item, ExpanderComponent, itemProps } = props\n  const isLeaf = !item.items.some(child => child.items && child.items.length > 0)\n  const classes = useStyles()\n\n  if (item.expanded != null && item.items && item.items.length && isLeaf) {\n    return (\n      <ExpanderComponent\n        title={item.text}\n        defaultExpanded={item.expanded}\n        classes={{\n          root: classes.expander,\n          margins: classes.expanderMargins,\n          summary: classes.expanderSummary,\n          summaryExpanded: classes.expanderSummaryExpanded,\n          expandIconExpanded: classes.expanderIconExpanded,\n          details: classes.expanderDetails,\n        }}\n      >\n        {item.items.map((child, i) => (\n          <MenuLeaf\n            key={i}\n            item={child}\n            depth={depth}\n            classes={{ listItem: classes.expanderContent }}\n          />\n        ))}\n      </ExpanderComponent>\n    )\n  } else {\n    return <MenuItemContent item={item} depth={depth} leaf={false} listItemProps={itemProps} />\n  }\n})\n\nexport default MenuBranch\n\nMenuBranch.propTypes = {\n  /**\n   * Overrides the default component for expandable items\n   */\n  ExpanderComponent: PropTypes.func.isRequired,\n  /**\n   * Additional props for the underlying ListItem\n   */\n  itemProps: PropTypes.object,\n}\n\nMenuBranch.defaultProps = {\n  ExpanderComponent: ExpandableSection,\n}\n",
      description: '',
      displayName: 'MenuBranch',
      methods: [],
      props: [
        {
          name: 'ExpanderComponent',
          type: { name: 'func' },
          required: false,
          description: 'Overrides the default component for expandable items',
          defaultValue: { value: 'ExpandableSection', computed: true },
        },
        {
          name: 'itemProps',
          type: { name: 'object' },
          required: false,
          description: 'Additional props for the underlying ListItem',
        },
      ],
      styles: {
        classes: [
          { ruleName: 'expander', globalClass: '.RSFMenuBranch-expander', description: '' },
          {
            ruleName: 'expanderMargins',
            globalClass: '.RSFMenuBranch-expanderMargins',
            description: '',
          },
          {
            ruleName: 'expanderSummary',
            globalClass: '.RSFMenuBranch-expanderSummary',
            description: '',
          },
          {
            ruleName: 'expanderSummaryExpanded',
            globalClass: '.RSFMenuBranch-expanderSummaryExpanded',
            description: '',
          },
          {
            ruleName: 'expanderIconExpanded',
            globalClass: '.RSFMenuBranch-expanderIconExpanded',
            description: '',
          },
          {
            ruleName: 'expanderDetails',
            globalClass: '.RSFMenuBranch-expanderDetails',
            description: '',
          },
          {
            ruleName: 'expanderContent',
            globalClass: '.RSFMenuBranch-expanderContent',
            description: '',
          },
        ],
      },
      type: 'component',
      import: "import MenuBranch from 'react-storefront/menu/MenuBranch'",
    },
    'menu/MenuButton': {
      name: 'MenuButton',
      filename: 'MenuButton',
      importPath: 'menu/MenuButton',
      src:
        "import React from 'react'\nimport { Hidden } from '@material-ui/core'\nimport { makeStyles } from '@material-ui/core/styles'\nimport ToolbarButton from '../ToolbarButton'\nimport MenuIcon from './MenuIcon'\nimport PropTypes from 'prop-types'\nimport clsx from 'clsx'\n\nexport const styles = theme => ({\n  link: {\n    textDecoration: 'none',\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFMenuButton' })\n\n/**\n * The button that controls that opens and closes the main app menu.\n */\nexport default function MenuButton({\n  MenuIcon,\n  menuIconProps,\n  open,\n  onClick,\n  classes,\n  className,\n  style,\n}) {\n  classes = useStyles({ classes })\n\n  return (\n    <Hidden mdUp implementation=\"css\" key=\"menuButton\">\n      <a\n        on=\"tap:AMP.setState({ rsfMenuState: { open: !rsfMenuState.open, list: '@' } }), rsfMenu.toggle\"\n        className={clsx(classes.link, className)}\n        style={style}\n      >\n        <ToolbarButton\n          aria-label=\"Menu\"\n          color=\"inherit\"\n          onClick={onClick}\n          icon={<MenuIcon open={open} {...menuIconProps} />}\n        />\n      </a>\n    </Hidden>\n  )\n}\n\nMenuButton.propTypes = {\n  /**\n   * A react component to use for the menu icon\n   */\n  MenuIcon: PropTypes.func,\n\n  /**\n   * Props for the menu icon\n   */\n  menuIconProps: PropTypes.object,\n}\n\nMenuButton.defaultProps = {\n  MenuIcon,\n  menuIconProps: {},\n}\n",
      description: 'The button that controls that opens and closes the main app menu.',
      displayName: 'MenuButton',
      methods: [],
      props: [
        {
          name: 'MenuIcon',
          type: { name: 'func' },
          required: false,
          description: 'A react component to use for the menu icon',
          defaultValue: { value: 'MenuIcon', computed: true },
        },
        {
          name: 'menuIconProps',
          type: { name: 'object' },
          required: false,
          description: 'Props for the menu icon',
          defaultValue: { value: '{}', computed: false },
        },
      ],
      styles: {
        classes: [{ ruleName: 'link', globalClass: '.RSFMenuButton-link', description: '' }],
        name: 'MenuButton',
      },
      type: 'component',
      import: "import MenuButton from 'react-storefront/menu/MenuButton'",
    },
    'menu/MenuCard': {
      name: 'MenuCard',
      filename: 'MenuCard',
      importPath: 'menu/MenuCard',
      src:
        "import React, { useContext } from 'react'\nimport { List } from '@material-ui/core'\nimport MenuItem from './MenuItem'\nimport MenuBack from './MenuBack'\nimport MenuHeader from './MenuHeader'\nimport MenuFooter from './MenuFooter'\nimport MenuContext from './MenuContext'\nimport PropTypes from 'prop-types'\n\nexport default function MenuCard({ item, depth, headerProps }) {\n  const { goBack, classes, expandFirstItem, drawerWidth } = useContext(MenuContext)\n\n  return (\n    <List\n      style={{ width: `${drawerWidth}px` }}\n      classes={{\n        root: classes.list,\n        padding: classes.padding,\n      }}\n      key={depth}\n    >\n      {!item.root && (\n        <MenuBack\n          classes={classes}\n          goBack={() => goBack(depth - 1)}\n          item={item}\n          card={depth}\n          {...headerProps}\n        />\n      )}\n\n      <MenuHeader item={item} />\n\n      {item.items &&\n        item.items.map((child, i) => (\n          <MenuItem\n            item={child}\n            key={item.key + '-' + i} // this ensures that the expanded state is after showing a new card\n            depth={depth}\n            defaultExpanded={i === 0 && expandFirstItem}\n          />\n        ))}\n\n      <MenuFooter item={item} />\n    </List>\n  )\n}\n\nMenuCard.propTypes = {\n  /**\n   * Addition props for the header element\n   */\n  headerProps: PropTypes.object,\n}\n\nMenuCard.defaultProps = {}\n",
      description: '',
      displayName: 'MenuCard',
      methods: [],
      props: [
        {
          name: 'headerProps',
          type: { name: 'object' },
          required: false,
          description: 'Addition props for the header element',
        },
      ],
      styles: { classes: [], name: null },
      type: 'component',
      import: "import MenuCard from 'react-storefront/menu/MenuCard'",
    },
    'menu/MenuExpanderIcon': {
      name: 'MenuExpanderIcon',
      filename: 'MenuExpanderIcon',
      importPath: 'menu/MenuExpanderIcon',
      src:
        "import React, { useContext } from 'react'\nimport { ChevronRight, ExpandLess, ExpandMore } from '@material-ui/icons'\nimport MenuContext from './MenuContext'\nimport { useAmp } from 'next/amp'\nimport clsx from 'clsx'\n\nexport default function ExpanderIcon({\n  ExpandIcon,\n  CollapseIcon,\n  showExpander,\n  sublist,\n  expanded,\n}) {\n  const { classes } = useContext(MenuContext)\n  const amp = useAmp()\n\n  ExpandIcon = ExpandIcon || ExpandMore\n  CollapseIcon = CollapseIcon || ExpandLess\n\n  if (!showExpander) return <ChevronRight className={classes.icon} />\n\n  if (amp) {\n    return (\n      <>\n        <CollapseIcon\n          className={clsx(classes.icon, classes.hidden)}\n          amp-bind={`class=>rsfMenuState.sublist == '${sublist}' ? '${classes.visible} ${classes.icon}' : '${classes.hidden} ${classes.icon}'`}\n        />\n        <ExpandIcon\n          className={clsx(classes.icon, classes.visible)}\n          amp-bind={`class=>rsfMenuState.sublist == '${sublist}' ? '${classes.hidden} ${classes.icon}' : '${classes.visible} ${classes.icon}'`}\n        />\n      </>\n    )\n  } else {\n    return expanded ? (\n      <CollapseIcon className={classes.icon} />\n    ) : (\n      <ExpandIcon className={classes.icon} />\n    )\n  }\n}\n",
      description: '',
      displayName: 'ExpanderIcon',
      methods: [],
      styles: { classes: [], name: null },
      props: [],
      type: 'component',
      import: "import MenuExpanderIcon from 'react-storefront/menu/MenuExpanderIcon'",
    },
    'menu/MenuFooter': {
      name: 'MenuFooter',
      filename: 'MenuFooter',
      importPath: 'menu/MenuFooter',
      src:
        "import React, { useState, useEffect, useContext } from 'react'\nimport makeStyles from '@material-ui/core/styles/makeStyles'\nimport PropTypes from 'prop-types'\nimport CmsSlot from '../CmsSlot'\n\nexport const styles = theme => ({\n  root: {\n    padding: theme.spacing(2),\n  },\n})\nconst useStyles = makeStyles(styles, { name: 'RSFMenuFooter' })\n\nexport default function MenuFooter({ classes, item }) {\n  classes = useStyles({ classes })\n\n  if (item.footer) {\n    return (\n      <div className={classes.root}>\n        <CmsSlot>{item.footer}</CmsSlot>\n      </div>\n    )\n  } else {\n    return null\n  }\n}\n\nMenuFooter.propTypes = {\n  /**\n   * The menu item record\n   */\n  item: PropTypes.object,\n}\n\nMenuFooter.defaultProps = {}\n",
      description: '',
      displayName: 'MenuFooter',
      methods: [],
      props: [
        {
          name: 'item',
          type: { name: 'object' },
          required: false,
          description: 'The menu item record',
        },
      ],
      styles: {
        classes: [{ ruleName: 'root', globalClass: '.RSFMenuFooter-root', description: '' }],
        name: 'MenuFooter',
      },
      type: 'component',
      import: "import MenuFooter from 'react-storefront/menu/MenuFooter'",
    },
    'menu/MenuHeader': {
      name: 'MenuHeader',
      filename: 'MenuHeader',
      importPath: 'menu/MenuHeader',
      src:
        "import React, { useState, useEffect, useContext } from 'react'\nimport makeStyles from '@material-ui/core/styles/makeStyles'\nimport PropTypes from 'prop-types'\nimport CmsSlot from '../CmsSlot'\n\nexport const styles = theme => ({\n  root: {\n    padding: theme.spacing(2),\n    borderBottom: `1px solid ${theme.palette.divider}`,\n  },\n})\nconst useStyles = makeStyles(styles, { name: 'RSFMenuHeader' })\n\nexport default function MenuHeader({ classes, item }) {\n  classes = useStyles({ classes })\n\n  if (item.header) {\n    return (\n      <div className={classes.root}>\n        <CmsSlot>{item.header}</CmsSlot>\n      </div>\n    )\n  } else {\n    return null\n  }\n}\n\nMenuHeader.propTypes = {\n  /**\n   * The menu item record\n   */\n  item: PropTypes.object,\n}\n\nMenuHeader.defaultProps = {}\n",
      description: '',
      displayName: 'MenuHeader',
      methods: [],
      props: [
        {
          name: 'item',
          type: { name: 'object' },
          required: false,
          description: 'The menu item record',
        },
      ],
      styles: {
        classes: [{ ruleName: 'root', globalClass: '.RSFMenuHeader-root', description: '' }],
        name: 'MenuHeader',
      },
      type: 'component',
      import: "import MenuHeader from 'react-storefront/menu/MenuHeader'",
    },
    'menu/MenuIcon': {
      name: 'MenuIcon',
      filename: 'MenuIcon',
      importPath: 'menu/MenuIcon',
      src:
        "import React from 'react'\nimport PropTypes from 'prop-types'\nimport clsx from 'clsx'\nimport { makeStyles } from '@material-ui/core/styles'\nimport { useAmp } from 'next/amp'\n\nexport const styles = theme => ({\n  root: {\n    position: 'relative',\n    height: '24px',\n    width: '24px',\n    boxSizing: 'border-box',\n    display: 'flex',\n    flexDirection: 'column',\n    alignItems: 'center',\n\n    '& .rsf-hamburger': {\n      display: 'block',\n      marginTop: '5px',\n    },\n\n    '& .rsf-hamburger-box': {\n      width: '20px',\n      height: '20px',\n      display: 'block',\n      position: 'relative',\n    },\n\n    '& .rsf-hamburger-inner': {\n      display: 'block',\n      top: '50%',\n      marginTop: '-4px',\n    },\n\n    '& .rsf-hamburger-inner, & .rsf-hamburger-inner::before, & .rsf-hamburger-inner::after': {\n      width: '20px',\n      height: '2px',\n      backgroundColor: theme.palette.text.secondary,\n      borderRadius: '4px',\n      position: 'absolute',\n      transitionProperty: 'transform',\n      transitionDuration: theme.transitions.duration.standard,\n      transitionTimingFunction: 'ease',\n    },\n\n    '& .rsf-hamburger-inner::before, & .rsf-hamburger-inner::after': {\n      content: '\"\"',\n      display: 'block',\n    },\n\n    '& .rsf-hamburger-inner::before': {\n      top: '-10px',\n    },\n\n    '& .rsf-hamburger-inner::after': {\n      bottom: '-10px',\n    },\n\n    '& .rsf-hamburger .rsf-hamburger-inner': {\n      top: '5px',\n    },\n\n    '& .rsf-hamburger .rsf-hamburger-inner::before': {\n      top: '5px',\n      transitionProperty: 'transform, opacity',\n      transitionTimingFunction: 'ease',\n      transitionDuration: theme.transitions.duration.standard,\n    },\n\n    '& .rsf-hamburger .rsf-hamburger-inner::after': {\n      top: '10px',\n    },\n  },\n\n  active: {\n    '& .rsf-hamburger .rsf-hamburger-inner': {\n      transform: 'translate3d(0, 5px, 0) rotate(45deg)',\n    },\n\n    '& .rsf-hamburger .rsf-hamburger-inner::before': {\n      transform: 'rotate(-45deg) translate3d(-5.71429px, -5px, 0)',\n      opacity: 0,\n    },\n\n    '& .rsf-hamburger .rsf-hamburger-inner::after': {\n      transform: 'translate3d(0, -10px, 0) rotate(-90deg)',\n    },\n  },\n\n  withLabel: {\n    '& .rsf-hamburger': {\n      marginTop: '0',\n    },\n  },\n\n  hidden: {\n    display: 'none',\n  },\n\n  visible: {\n    display: 'block',\n  },\n\n  label: {\n    fontSize: '9px',\n    lineHeight: '9px',\n    fontWeight: 'bold',\n    letterSpacing: '0px',\n    marginTop: '-3px',\n    color: theme.palette.text.secondary,\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFMenuIcon' })\n\n/**\n * A menu icon that animates transitions between open and closed states.\n */\nexport default function MenuIcon({ classes, label, open }) {\n  const amp = useAmp()\n  classes = useStyles({ classes })\n\n  const renderIcon = open => {\n    return (\n      <div\n        className={clsx({\n          [classes.root]: true,\n          [classes.active]: open,\n          [classes.withLabel]: label,\n        })}\n      >\n        <div className=\"rsf-hamburger\">\n          <span className=\"rsf-hamburger-box\">\n            <span className=\"rsf-hamburger-inner\" />\n          </span>\n        </div>\n        {label && <div className={classes.label}>menu</div>}\n      </div>\n    )\n  }\n\n  if (amp) {\n    return (\n      <>\n        <div\n          className={classes.visible}\n          amp-bind={`class=>!rsfMenuState.open ? '${classes.visible}' : '${classes.hidden}'`}\n        >\n          {renderIcon(false)}\n        </div>\n        <div\n          className={classes.hidden}\n          amp-bind={`class=>rsfMenuState.open ? '${classes.visible}' : '${classes.hidden}'`}\n        >\n          {renderIcon(true)}\n        </div>\n      </>\n    )\n  } else {\n    return renderIcon(open)\n  }\n}\n\nMenuIcon.propTypes = {\n  /**\n   * Set to true when the menu is open, otherwise false\n   */\n  open: PropTypes.bool,\n\n  /**\n   * Set to `false` to hide the text \"menu\" underneath the button when the menu is closed.\n   */\n  label: PropTypes.bool,\n}\n\nMenuIcon.defaultProps = {\n  open: false,\n  label: false,\n}\n",
      description: 'A menu icon that animates transitions between open and closed states.',
      displayName: 'MenuIcon',
      methods: [],
      props: [
        {
          name: 'open',
          type: { name: 'bool' },
          required: false,
          description: 'Set to true when the menu is open, otherwise false',
          defaultValue: { value: 'false', computed: false },
        },
        {
          name: 'label',
          type: { name: 'bool' },
          required: false,
          description:
            'Set to `false` to hide the text "menu" underneath the button when the menu is closed.',
          defaultValue: { value: 'false', computed: false },
        },
      ],
      styles: {
        classes: [
          { ruleName: 'root', globalClass: '.RSFMenuIcon-root', description: '' },
          { ruleName: 'active', globalClass: '.RSFMenuIcon-active', description: '' },
          { ruleName: 'withLabel', globalClass: '.RSFMenuIcon-withLabel', description: '' },
          { ruleName: 'hidden', globalClass: '.RSFMenuIcon-hidden', description: '' },
          { ruleName: 'visible', globalClass: '.RSFMenuIcon-visible', description: '' },
          { ruleName: 'label', globalClass: '.RSFMenuIcon-label', description: '' },
        ],
        name: 'MenuIcon',
      },
      type: 'component',
      import: "import MenuIcon from 'react-storefront/menu/MenuIcon'",
    },
    'menu/MenuItemContent': {
      name: 'MenuItemContent',
      filename: 'MenuItemContent',
      importPath: 'menu/MenuItemContent',
      src:
        "import React, { useContext } from 'react'\nimport { ListItem, ListItemText, ListItemIcon, CircularProgress } from '@material-ui/core'\nimport MenuContext from './MenuContext'\nimport MenuExpanderIcon from './MenuExpanderIcon'\nimport clsx from 'clsx'\nimport PropTypes from 'prop-types'\nimport makeStyles from '@material-ui/core/styles/makeStyles'\n\nexport const styles = theme => ({\n  listItem: {\n    textTransform: 'uppercase',\n    lineHeight: '1.5',\n    fontSize: theme.typography.body1.fontSize,\n  },\n\n  listItemImage: {\n    width: '40px',\n    height: '40px',\n    marginRight: 0,\n  },\n\n  listItemIcon: {\n    marginRight: 0,\n    minWidth: 0,\n  },\n\n  loadingIcon: {\n    display: 'block',\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFMenuItemContent' })\n\nexport default function MenuItemContent(props) {\n  const { renderItemContent, onItemClick } = useContext(MenuContext)\n  const classes = useStyles(props)\n\n  let { item, depth, leaf, listItemProps } = props\n  let contents\n\n  if (renderItemContent) {\n    contents = renderItemContent(item, leaf)\n  }\n\n  if (!contents) {\n    if (leaf) {\n      contents = (\n        <>\n          {item.image && (\n            <ListItemIcon>\n              <img className={classes.listItemImage} alt={item.text} src={item.image} />\n            </ListItemIcon>\n          )}\n          <ListItemText primary={item.text} disableTypography />\n        </>\n      )\n    } else {\n      contents = (\n        <>\n          {item.image && (\n            <ListItemIcon>\n              <img className={classes.listItemImage} alt={item.text} src={item.image} />\n            </ListItemIcon>\n          )}\n          <ListItemText className={classes.listItem} primary={item.text} disableTypography />\n          <ListItemIcon className={classes.listItemIcon}>\n            {item.loading ? (\n              <CircularProgress\n                style={{ height: 24, width: 24, padding: 4 }}\n                color=\"secondary\"\n                className={classes.loadingIcon}\n              />\n            ) : (\n              <MenuExpanderIcon {...props} />\n            )}\n          </ListItemIcon>\n        </>\n      )\n    }\n  }\n\n  return (\n    <ListItem\n      onClick={leaf ? null : onItemClick.bind(null, item, depth)}\n      button\n      divider\n      classes={{\n        root: clsx(classes.listItem, item.className),\n      }}\n      {...listItemProps}\n    >\n      {contents}\n    </ListItem>\n  )\n}\n\nMenuItemContent.propTypes = {\n  /**\n   * Additional props for the underlying ListItem\n   */\n  listItemProps: PropTypes.object,\n}\n",
      description: '',
      displayName: 'MenuItemContent',
      methods: [],
      props: [
        {
          name: 'listItemProps',
          type: { name: 'object' },
          required: false,
          description: 'Additional props for the underlying ListItem',
        },
      ],
      styles: {
        classes: [
          { ruleName: 'listItem', globalClass: '.RSFMenuItemContent-listItem', description: '' },
          {
            ruleName: 'listItemImage',
            globalClass: '.RSFMenuItemContent-listItemImage',
            description: '',
          },
          {
            ruleName: 'listItemIcon',
            globalClass: '.RSFMenuItemContent-listItemIcon',
            description: '',
          },
          {
            ruleName: 'loadingIcon',
            globalClass: '.RSFMenuItemContent-loadingIcon',
            description: '',
          },
        ],
        name: 'MenuItemContent',
      },
      type: 'component',
      import: "import MenuItemContent from 'react-storefront/menu/MenuItemContent'",
    },
    'menu/MenuLeaf': {
      name: 'MenuLeaf',
      filename: 'MenuLeaf',
      importPath: 'menu/MenuLeaf',
      src:
        "import React, { useContext } from 'react'\nimport MenuItemContent from './MenuItemContent'\nimport Link from '../link/Link'\nimport MenuContext from './MenuContext'\n\nfunction MenuLeaf({ item, trackSelected, ...others }) {\n  const { close, classes } = useContext(MenuContext)\n\n  return (\n    <Link\n      href={item.href}\n      as={item.as}\n      className={classes.link}\n      server={item.server}\n      state={item.state ? () => JSON.parse(item.state) : null}\n      onClick={close}\n    >\n      <a>\n        <MenuItemContent {...others} item={item} showExpander={false} leaf />\n      </a>\n    </Link>\n  )\n}\n\nexport default React.memo(MenuLeaf)\n",
      description: '',
      displayName: 'MenuLeaf',
      methods: [],
      styles: { classes: [], name: null },
      props: [],
      type: 'component',
      import: "import MenuLeaf from 'react-storefront/menu/MenuLeaf'",
    },
    'menu/SEOLinks': {
      name: 'SEOLinks',
      filename: 'SEOLinks',
      importPath: 'menu/SEOLinks',
      src:
        "import React from 'react'\nimport NoScript from '../NoScript'\n\nexport default function SEOLinks({ root }) {\n  if (!root) return null\n\n  let links = [],\n    key = 0\n\n  const findLinks = ({ items }) => {\n    for (let i = 0; i < items.length; i++) {\n      const item = items[i]\n\n      if (item.href) {\n        links.push(\n          <a key={key++} href={item.as}>\n            {item.text}\n          </a>,\n        )\n      }\n\n      if (item.items) {\n        findLinks(item)\n      }\n    }\n  }\n\n  findLinks(root)\n\n  return (\n    <NoScript>\n      <nav\n        style={{\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          height: '1px',\n          width: '1px',\n          overflow: 'hidden',\n        }}\n      >\n        {links}\n      </nav>\n    </NoScript>\n  )\n}\n",
      description: '',
      displayName: 'SEOLinks',
      methods: [],
      styles: { classes: [], name: null },
      props: [],
      type: 'component',
      import: "import SEOLinks from 'react-storefront/menu/SEOLinks'",
    },
    'nav/NavTab': {
      name: 'NavTab',
      filename: 'NavTab',
      importPath: 'nav/NavTab',
      src:
        "import React, { useState, useCallback, useRef, useEffect } from 'react'\nimport Link from '../link/Link'\nimport { makeStyles } from '@material-ui/core/styles'\nimport { Hidden, Fade, Tab, Popover, Paper } from '@material-ui/core'\nimport PropTypes from 'prop-types'\nimport Router from 'next/router'\n\nconst styles = theme => ({\n  popover: {\n    pointerEvents: 'none',\n  },\n  tab: {\n    paddingLeft: theme.spacing(2),\n    paddingRight: theme.spacing(2),\n  },\n  link: {\n    textDecoration: 'none',\n    color: 'inherit',\n    fontWeight: 100,\n  },\n  menu: {\n    zIndex: theme.zIndex.appBar,\n  },\n  ripple: {\n    zIndex: 2,\n  },\n  paper: {\n    pointerEvents: 'all',\n    paddingTop: 2, // we add 2 pixels of transparent padding and move the menu up two pixels to cover the tab indicator\n    marginTop: -2, // so that the user doesn't temporarily mouse over the indicator when moving between the tab and the menu, causing the menu to flicker.\n    background: 'transparent',\n    boxShadow: '0px 5px 5px -3px rgba(0,0,0,0.2), 0px 8px 10px 1px rgba(0,0,0,0.14)',\n  },\n  innerPaper: {\n    borderTop: `1px solid ${theme.palette.divider}`,\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFNavTab' })\n\n/**\n * A single navigational tab, which links to another page in the app based on the `as` and `href` props.\n * Children are displayed in a menu that is shown on mouse over on desktop devices.\n *\n * Example:\n *\n * ```js\n *  <NavTab href=\"/c/[categoryId]\" as=\"/c/shirts\" label=\"Shirts\">\n *    <div style={{ padding: 20 }}>\n *      <Link href=\"/s/[subcategoryId]\" as=\"/s/long-sleeve-shirts\">Long Sleeve Shirts</Link>\n *      <Link href=\"/s/[subcategoryId]\" as=\"/s/turtlenecks\">Turtlenecks</Link>\n *      <Link href=\"/s/[subcategoryId]\" as=\"/s/tees\">Tee Shirts</Link>\n *    </div>\n *  </NavTab>\n * ```\n *\n * Accessibility:\n *\n * This component supports keyboard navigation.  The user can open the menu by pressing the enter key when the NavTab is focused.\n */\nfunction NavTab({ classes, href, as, children, ...props }) {\n  classes = useStyles({ classes })\n\n  const [overTab, setOverTab] = useState(false)\n  const [overMenu, setOverMenu] = useState(false)\n  const [anchorEl, setAnchorEl] = useState(null)\n  const [focused, setFocused] = useState(false)\n\n  const showMenu = useCallback(event => {\n    setOverTab(true)\n    setAnchorEl(event.currentTarget)\n  }, [])\n\n  // We use setImmediate here to delay the tab and menu exit events give time for the user to enter\n  // the tab or menu so that the menu doesn't flash when the user is transitioning between tab and menu.\n  const hideMenu = useCallback(() => setImmediate(() => setOverTab(false)), [])\n  const leaveMenu = useCallback(() => setImmediate(() => setOverMenu(false)), [])\n  const enterMenu = useCallback(() => setOverMenu(true), [])\n  const menuItemBlurPending = useRef(false)\n\n  // accessibility: open the menu when the user presses enter with the tab focused\n  const handleTabKeyDown = useCallback(e => {\n    if (e.key === 'Enter') {\n      e.preventDefault()\n      setAnchorEl(e.currentTarget)\n      setFocused(true)\n    }\n  }, [])\n\n  // Keep track of when an item in the menu is focused.\n  const handleMenuItemFocus = useCallback(() => {\n    // When tabbing through menu items, the current one will blur before the next one focuses.\n    // So we need to let the event loop finish one cycle to see if another item in the menu receives focus before\n    // determining that the menu has lost focus and should be closed.\n    menuItemBlurPending.current = false\n\n    if (!focused) {\n      setFocused(true)\n    }\n  }, [focused])\n\n  // When a menu item loses focus, we close the menu if another menu item doesn't immediately gain focus\n  const handleMenuItemBlur = useCallback(() => {\n    menuItemBlurPending.current = true\n\n    setImmediate(() => {\n      if (menuItemBlurPending.current) {\n        setFocused(false)\n      }\n    })\n  }, [])\n\n  const open = overTab || overMenu || focused\n\n  // close the menu when the user navigates to a new page\n  useEffect(() => {\n    const onHistoryChange = () => handleMenuItemBlur()\n    const unsubscribe = () => Router.events.off('routeChangeStart', onHistoryChange)\n\n    if (open) {\n      Router.events.on('routeChangeStart', onHistoryChange)\n    } else {\n      unsubscribe()\n    }\n\n    return unsubscribe\n  }, [open])\n\n  return (\n    <>\n      <Link\n        className={classes.link}\n        href={href}\n        as={as}\n        onClick={hideMenu} // Does not work in dev, because next consumes focus in production everything is good\n        onMouseEnter={showMenu}\n        onMouseLeave={hideMenu}\n        prefetch=\"visible\"\n      >\n        <Tab\n          onKeyDown={handleTabKeyDown}\n          classes={{ root: classes.tab }}\n          aria-haspopup={children != null}\n          aria-expanded={open}\n          {...props}\n          TouchRippleProps={{\n            classes: {\n              root: classes.ripple,\n            },\n          }}\n        />\n      </Link>\n      {!children ? null : (\n        <Hidden xsDown>\n          <Popover\n            open={open}\n            className={classes.popover}\n            anchorEl={anchorEl}\n            anchorOrigin={{\n              vertical: 'bottom',\n              horizontal: 'center',\n            }}\n            TransitionComponent={Fade}\n            transformOrigin={{\n              vertical: 'top',\n              horizontal: 'center',\n            }}\n            PaperProps={{\n              onMouseEnter: enterMenu,\n              onMouseLeave: leaveMenu,\n              onClick: leaveMenu,\n              square: true,\n              className: classes.paper,\n            }}\n          >\n            <Paper\n              className={classes.innerPaper}\n              onBlurCapture={handleMenuItemBlur}\n              onFocusCapture={handleMenuItemFocus}\n              square\n            >\n              {children}\n            </Paper>\n          </Popover>\n        </Hidden>\n      )}\n    </>\n  )\n}\n\nNavTab.propTypes = {\n  /**\n   * The link path\n   */\n  as: PropTypes.string.isRequired,\n  /**\n   * The next.js route pattern\n   */\n  href: PropTypes.string.isRequired,\n  /**\n   * Override or extend the styles applied to the component. See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object,\n}\n\nexport default React.memo(NavTab)\n",
      description:
        'A single navigational tab, which links to another page in the app based on the `as` and `href` props.\nChildren are displayed in a menu that is shown on mouse over on desktop devices.\n\nExample:\n\n```js\n <NavTab href="/c/[categoryId]" as="/c/shirts" label="Shirts">\n   <div style={{ padding: 20 }}>\n     <Link href="/s/[subcategoryId]" as="/s/long-sleeve-shirts">Long Sleeve Shirts</Link>\n     <Link href="/s/[subcategoryId]" as="/s/turtlenecks">Turtlenecks</Link>\n     <Link href="/s/[subcategoryId]" as="/s/tees">Tee Shirts</Link>\n   </div>\n </NavTab>\n```\n\nAccessibility:\n\nThis component supports keyboard navigation.  The user can open the menu by pressing the enter key when the NavTab is focused.',
      displayName: 'NavTab',
      methods: [],
      props: [
        { name: 'as', type: { name: 'string' }, required: true, description: 'The link path' },
        {
          name: 'href',
          type: { name: 'string' },
          required: true,
          description: 'The next.js route pattern',
        },
        {
          name: 'classes',
          type: { name: 'object' },
          required: false,
          description:
            'Override or extend the styles applied to the component. See [CSS API](#css) below for more details.',
        },
      ],
      styles: { classes: [], name: null },
      type: 'component',
      import: "import NavTab from 'react-storefront/nav/NavTab'",
    },
    'nav/NavTabs': {
      name: 'NavTabs',
      filename: 'NavTabs',
      importPath: 'nav/NavTabs',
      src:
        "import React, { useMemo } from 'react'\nimport clsx from 'clsx'\nimport { makeStyles } from '@material-ui/core/styles'\nimport { Tabs } from '@material-ui/core'\nimport MuiTabScrollButton from '@material-ui/core/Tabs/TabScrollButton'\nimport { useRouter } from 'next/router'\n\nexport const styles = theme => ({\n  indicatorNoSelection: {\n    display: 'none',\n  },\n  scrollButtons: {\n    position: 'absolute',\n    height: '100%',\n    right: 0,\n    '&:first-child': {\n      left: 0,\n    },\n    '& svg': {\n      zIndex: 1,\n      width: theme.spacing(5),\n      background: theme.palette.background.paper,\n    },\n  },\n  root: {\n    maxWidth: theme.breakpoints.values.lg,\n    flex: 1,\n    position: 'relative',\n    '&::before, &::after': {\n      content: \"''\",\n      top: 0,\n      width: '15px',\n      height: 'calc(100% - 3px)',\n      position: 'absolute',\n      zIndex: 1,\n    },\n    '&::before': {\n      left: 0,\n      background:\n        'linear-gradient(to right, rgba(255, 255, 255, 1.0) 0%, rgba(255, 255, 255, 0.0) 100%)',\n    },\n    '&::after': {\n      right: 0,\n      background:\n        'linear-gradient(to left, rgba(255, 255, 255, 1.0) 0%, rgba(255, 255, 255, 0.0) 100%)',\n    },\n  },\n  ripple: {\n    zIndex: 2,\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFNavTabs' })\n\n/**\n * Scrollable navigation tabs for the top of the app. All extra props are spread to the\n * underlying Material UI Tabs element.  When a tab is clicked, the \"top_nav_clicked\" analytics\n * event is fired.\n */\nexport default function NavTabs({ classes = {}, children, ...others }) {\n  const { paper, indicator, indicatorNoSelection, ripple, ...classNames } = classes\n  classes = useStyles({ classes: { paper, indicator, indicatorNoSelection, ripple } })\n\n  const { asPath } = useRouter()\n  const value = children && children.findIndex(tab => tab.props.as === asPath.split('?')[0])\n\n  const TabScrollButton = useMemo(() => {\n    return props => (\n      <MuiTabScrollButton {...props} TouchRippleProps={{ classes: { root: classes.ripple } }} />\n    )\n  }, [classes])\n\n  return (\n    <Tabs\n      ScrollButtonComponent={TabScrollButton}\n      variant=\"scrollable\"\n      classes={{\n        ...classNames,\n        indicator: clsx(classes.indicator, {\n          [classes.indicatorNoSelection]: value === -1, // To cancel wierd animation when going from plp to pdp\n        }),\n      }}\n      value={value === -1 ? false : value}\n      {...others}\n    >\n      {children}\n    </Tabs>\n  )\n}\n\nNavTabs.propTypes = {}\n\nNavTabs.defaultProps = {}\n",
      description:
        'Scrollable navigation tabs for the top of the app. All extra props are spread to the\nunderlying Material UI Tabs element.  When a tab is clicked, the "top_nav_clicked" analytics\nevent is fired.',
      displayName: 'NavTabs',
      methods: [],
      props: [{ name: 'classes', defaultValue: { value: '{}', computed: false }, required: false }],
      styles: {
        classes: [
          {
            ruleName: 'indicatorNoSelection',
            globalClass: '.RSFNavTabs-indicatorNoSelection',
            description: '',
          },
          { ruleName: 'scrollButtons', globalClass: '.RSFNavTabs-scrollButtons', description: '' },
          { ruleName: 'root', globalClass: '.RSFNavTabs-root', description: '' },
          { ruleName: 'ripple', globalClass: '.RSFNavTabs-ripple', description: '' },
        ],
        name: 'NavTabs',
      },
      type: 'component',
      import: "import NavTabs from 'react-storefront/nav/NavTabs'",
    },
    'option/ProductOption': {
      name: 'ProductOption',
      filename: 'ProductOption',
      importPath: 'option/ProductOption',
      src:
        "import React from 'react'\nimport PropTypes from 'prop-types'\nimport TextProductOption from './TextProductOption'\nimport SwatchProductOption from './SwatchProductOption'\nimport withDefaultHandler from '../utils/withDefaultHandler'\nimport get from 'lodash/get'\n\nexport default function ProductOption(props) {\n  let {\n    value,\n    selected,\n    options,\n    selectedOption,\n    onSelectedOptionChange,\n    onClick,\n    variant,\n    showLabel,\n    onOptionsChange,\n    wrapperProps,\n    optionProps,\n    index,\n    selectedClassName,\n    ...others\n  } = props\n\n  if (selectedOption) {\n    selected = get(value, 'id') == get(selectedOption, 'id')\n  }\n\n  const handleClick = withDefaultHandler(onClick, _e => {\n    if (onSelectedOptionChange) {\n      onSelectedOptionChange(value === selectedOption ? null : value)\n    }\n  })\n\n  const Variant = variant === 'text' ? TextProductOption : SwatchProductOption\n  const propArgs = { selected, ...props }\n\n  return (\n    <div className={selected ? selectedClassName : ''} {...wrapperProps(propArgs)}>\n      <Variant\n        {...others}\n        {...optionProps(propArgs)}\n        label={showLabel ? value && value.text : undefined}\n        selected={selected}\n        onClick={handleClick}\n      />\n    </div>\n  )\n}\n\nProductOption.propTypes = {\n  /**\n   * The ui variant that controls how the option is displayed\n   */\n  variant: PropTypes.oneOf(['text', 'swatch']).isRequired,\n  /**\n   * Set to `false` to hide the label text\n   */\n  showLabel: PropTypes.bool,\n  /**\n   * The css class name applied to a selected option\n   */\n  selectedClassName: PropTypes.string,\n}\n\nProductOption.defaultProps = {\n  showLabel: true,\n  wrapperProps: Function.prototype,\n  optionProps: Function.prototype,\n  selectedClassName: 'rsf-po-selected',\n}\n",
      description: '',
      displayName: 'ProductOption',
      methods: [],
      props: [
        {
          name: 'variant',
          type: {
            name: 'enum',
            value: [
              { value: "'text'", computed: false },
              { value: "'swatch'", computed: false },
            ],
          },
          required: true,
          description: 'The ui variant that controls how the option is displayed',
        },
        {
          name: 'showLabel',
          type: { name: 'bool' },
          required: false,
          description: 'Set to `false` to hide the label text',
          defaultValue: { value: 'true', computed: false },
        },
        {
          name: 'selectedClassName',
          type: { name: 'string' },
          required: false,
          description: 'The css class name applied to a selected option',
          defaultValue: { value: "'rsf-po-selected'", computed: false },
        },
        {
          name: 'wrapperProps',
          defaultValue: { value: 'Function.prototype', computed: true },
          required: false,
        },
        {
          name: 'optionProps',
          defaultValue: { value: 'Function.prototype', computed: true },
          required: false,
        },
      ],
      styles: { classes: [], name: null },
      type: 'component',
      import: "import ProductOption from 'react-storefront/option/ProductOption'",
    },
    'option/ProductOptionSelector': {
      name: 'ProductOptionSelector',
      filename: 'ProductOptionSelector',
      importPath: 'option/ProductOptionSelector',
      src:
        "import React from 'react'\nimport PropTypes from 'prop-types'\nimport { makeStyles } from '@material-ui/core/styles'\nimport clsx from 'clsx'\nimport ProductOption from './ProductOption'\n\nexport const styles = theme => ({\n  root: {\n    display: 'flex',\n    flexWrap: 'wrap',\n  },\n  button: {\n    margin: theme.spacing(0, 0.5, 0.5, 0),\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFProductOptionSelector' })\n\n/**\n * A selector for product options rendered as a set of buttons. Buttons can either have\n * text or an image. The text for the selected option can optionally be displayed below\n * the buttons.\n *\n * This component supports AMP.\n */\nexport default function ProductOptionSelector({\n  options,\n  name,\n  classes,\n  optionProps,\n  skeleton,\n  value,\n  onChange,\n  variant,\n  OptionComponent,\n}) {\n  classes = useStyles({ classes })\n\n  if (skeleton) {\n    options = new Array(skeleton).fill(0).map((_item, i) => ({ id: i, text: '' }))\n  }\n\n  if (!options) return null\n\n  const onSelectedOptionChange = newValue => {\n    if (onChange) {\n      onChange(newValue)\n    }\n  }\n\n  return (\n    <div data-id=\"ProductOptionSelector\" className={classes.root}>\n      {options.map((option, i) => {\n        return (\n          <OptionComponent\n            selectedOption={value}\n            onSelectedOptionChange={onSelectedOptionChange}\n            {...optionProps}\n            variant={variant || (option.image || option.color ? 'swatch' : 'text')}\n            name={name}\n            key={option.id}\n            className={clsx(classes.button, optionProps.className)}\n            index={i}\n            imageProps={option.image}\n            value={option}\n            skeleton={skeleton != null}\n          />\n        )\n      })}\n    </div>\n  )\n}\n\nProductOptionSelector.propTypes = {\n  /**\n   * Overridable classes object to allow customization of component\n   */\n  classes: PropTypes.objectOf(PropTypes.string),\n\n  /**\n   * Props for displayed images. See <Image /> component for details\n   */\n  imageProps: PropTypes.object,\n\n  /**\n   * The name of property in amp state to bind to\n   */\n  name: PropTypes.string,\n\n  /**\n   * Function to call when a new option is selected. Called with the new selected\n   * option or `null` when a selected option is deselected.\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * Props to apply to each `SwatchProductOption` or `TextProductOption` element.\n   */\n  optionProps: PropTypes.object,\n\n  /**\n   * If specified, this number of skeleton buttons will be displayed instead of\n   * displaying the actual buttons.\n   */\n  skeleton: PropTypes.number,\n\n  /**\n   * Current selected value among provided options or `null` when no option is selected.\n   */\n  value: PropTypes.object,\n\n  /**\n   * Allows you to override the default component which is used to render a product option.\n   */\n  OptionComponent: PropTypes.func,\n}\n\nProductOptionSelector.defaultProps = {\n  items: [],\n  optionProps: {},\n  imageProps: {},\n  OptionComponent: ProductOption,\n}\n",
      description:
        'A selector for product options rendered as a set of buttons. Buttons can either have\ntext or an image. The text for the selected option can optionally be displayed below\nthe buttons.\n\nThis component supports AMP.',
      displayName: 'ProductOptionSelector',
      methods: [],
      props: [
        {
          name: 'classes',
          type: { name: 'objectOf', value: { name: 'string' } },
          required: false,
          description: 'Overridable classes object to allow customization of component',
        },
        {
          name: 'imageProps',
          type: { name: 'object' },
          required: false,
          description: 'Props for displayed images. See <Image /> component for details',
          defaultValue: { value: '{}', computed: false },
        },
        {
          name: 'name',
          type: { name: 'string' },
          required: false,
          description: 'The name of property in amp state to bind to',
        },
        {
          name: 'onChange',
          type: { name: 'func' },
          required: false,
          description:
            'Function to call when a new option is selected. Called with the new selected\noption or `null` when a selected option is deselected.',
        },
        {
          name: 'optionProps',
          type: { name: 'object' },
          required: false,
          description:
            'Props to apply to each `SwatchProductOption` or `TextProductOption` element.',
          defaultValue: { value: '{}', computed: false },
        },
        {
          name: 'skeleton',
          type: { name: 'number' },
          required: false,
          description:
            'If specified, this number of skeleton buttons will be displayed instead of\ndisplaying the actual buttons.',
        },
        {
          name: 'value',
          type: { name: 'object' },
          required: false,
          description:
            'Current selected value among provided options or `null` when no option is selected.',
        },
        {
          name: 'OptionComponent',
          type: { name: 'func' },
          required: false,
          description:
            'Allows you to override the default component which is used to render a product option.',
          defaultValue: { value: 'ProductOption', computed: true },
        },
        { name: 'items', defaultValue: { value: '[]', computed: false }, required: false },
      ],
      styles: {
        classes: [
          { ruleName: 'root', globalClass: '.RSFProductOptionSelector-root', description: '' },
          { ruleName: 'button', globalClass: '.RSFProductOptionSelector-button', description: '' },
        ],
        name: 'ProductOptionSelector',
      },
      type: 'component',
      import: "import ProductOptionSelector from 'react-storefront/option/ProductOptionSelector'",
    },
    'option/SwatchProductOption': {
      name: 'SwatchProductOption',
      filename: 'SwatchProductOption',
      importPath: 'option/SwatchProductOption',
      src:
        "import React from 'react'\nimport clsx from 'clsx'\nimport { Vbox } from '../Box'\nimport { Typography } from '@material-ui/core'\nimport { makeStyles } from '@material-ui/core/styles'\nimport { Check as CheckedIcon } from '@material-ui/icons'\nimport Image from '../Image'\nimport PropTypes from 'prop-types'\nimport { Skeleton } from '@material-ui/lab'\n\nexport const styles = theme => ({\n  root: {},\n  button: {\n    position: 'relative',\n    marginBottom: theme.spacing(0.5),\n    padding: 2,\n    borderRadius: '50%',\n    backgroundColor: 'transparent',\n    minWidth: 0,\n    borderWidth: 1,\n    borderStyle: 'solid',\n    borderColor: theme.palette.grey[500],\n    cursor: 'pointer',\n    '&:focus': {\n      outline: 0,\n    },\n  },\n  image: {\n    height: '100%',\n    width: '100%',\n    borderRadius: '50%',\n  },\n  '@media (hover: none)': {\n    SwatchButton: {\n      '&:hover': {\n        backgroundColor: 'transparent',\n      },\n    },\n  },\n  checkMark: {\n    transition: 'opacity 0.1s linear',\n    opacity: 0,\n    position: 'absolute',\n    zIndex: 1,\n    color: 'white',\n    top: 2,\n    left: 2,\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'center',\n    backgroundColor: 'rgba(0,0,0,0.2)',\n    padding: 2,\n    height: 'calc(100% - 4px)',\n    width: 'calc(100% - 4px)',\n    boxSizing: 'border-box',\n    borderRadius: '50%',\n    '.rsf-po-selected &': {\n      opacity: 1,\n    },\n  },\n  selected: {\n    opacity: 1,\n  },\n  selectedLabel: {\n    fontWeight: 'bold',\n  },\n  default: {\n    height: 48,\n    width: 48,\n    '& svg': {\n      height: 24,\n      width: 24,\n    },\n  },\n  small: {\n    height: 32,\n    width: 32,\n    '& svg': {\n      height: 16,\n      width: 16,\n    },\n  },\n  tiny: {\n    height: 24,\n    width: 24,\n    '& svg': {\n      height: 12,\n      width: 12,\n    },\n  },\n})\nconst useStyles = makeStyles(styles, { name: 'RSFSwatchProductOption' })\n\nexport default function SwatchProductOption({\n  selected,\n  label,\n  classes,\n  imageProps,\n  onClick,\n  SelectedIcon,\n  size,\n  skeleton,\n  ImageComponent,\n  className,\n  buttonProps,\n}) {\n  classes = useStyles({ classes })\n\n  if (skeleton) {\n    return (\n      <Skeleton\n        variant=\"circle\"\n        style={{ marginTop: 0, marginBottom: 4, margintLeft: 4, marginRight: 4 }}\n        className={clsx({\n          [buttonProps.className]: true,\n          [classes[size]]: true,\n        })}\n      />\n    )\n  }\n\n  return (\n    <Vbox className={classes.root}>\n      <button\n        {...buttonProps}\n        type=\"button\"\n        onClick={onClick}\n        className={clsx({\n          [className]: className != null,\n          [classes.button]: true,\n          [classes[size]]: true,\n        })}\n      >\n        <div\n          className={clsx({\n            [classes.checkMark]: true,\n            [classes.selected]: selected,\n          })}\n        >\n          <SelectedIcon className={classes.icon} />\n        </div>\n        <ImageComponent classes={{ image: classes.image }} fill aspectRatio={1} {...imageProps} />\n      </button>\n      {label && (\n        <Typography variant=\"caption\" className={clsx({ [classes.selectedLabel]: selected })}>\n          {label}\n        </Typography>\n      )}\n    </Vbox>\n  )\n}\n\nSwatchProductOption.propTypes = {\n  /**\n   * Text to display below the button\n   */\n  label: PropTypes.oneOfType([PropTypes.string, PropTypes.element]),\n  /**\n   * Props for the `Image` element\n   */\n  imageProps: PropTypes.shape(Image.propTypes),\n  /**\n   * Controls the size of the button\n   */\n  size: PropTypes.oneOf(['default', 'small', 'tiny']),\n  /**\n   * The component to use to display images\n   */\n  ImageComponent: PropTypes.func,\n}\n\nSwatchProductOption.defaultProps = {\n  imageProps: {},\n  SelectedIcon: CheckedIcon,\n  ImageComponent: Image,\n  size: 'default',\n  buttonProps: {},\n}\n",
      description: '',
      displayName: 'SwatchProductOption',
      methods: [],
      props: [
        {
          name: 'label',
          type: { name: 'union', value: [{ name: 'string' }, { name: 'element' }] },
          required: false,
          description: 'Text to display below the button',
        },
        {
          name: 'imageProps',
          type: { name: 'shape', value: 'Image.propTypes', computed: true },
          required: false,
          description: 'Props for the `Image` element',
          defaultValue: { value: '{}', computed: false },
        },
        {
          name: 'size',
          type: {
            name: 'enum',
            value: [
              { value: "'default'", computed: false },
              { value: "'small'", computed: false },
              { value: "'tiny'", computed: false },
            ],
          },
          required: false,
          description: 'Controls the size of the button',
          defaultValue: { value: "'default'", computed: false },
        },
        {
          name: 'ImageComponent',
          type: { name: 'func' },
          required: false,
          description: 'The component to use to display images',
          defaultValue: { value: 'Image', computed: true },
        },
        {
          name: 'SelectedIcon',
          defaultValue: { value: 'CheckedIcon', computed: true },
          required: false,
        },
        { name: 'buttonProps', defaultValue: { value: '{}', computed: false }, required: false },
      ],
      styles: {
        classes: [
          { ruleName: 'root', globalClass: '.RSFSwatchProductOption-root', description: '' },
          { ruleName: 'button', globalClass: '.RSFSwatchProductOption-button', description: '' },
          { ruleName: 'image', globalClass: '.RSFSwatchProductOption-image', description: '' },
          {
            ruleName: 'checkMark',
            globalClass: '.RSFSwatchProductOption-checkMark',
            description: '',
          },
          {
            ruleName: 'selected',
            globalClass: '.RSFSwatchProductOption-selected',
            description: '',
          },
          {
            ruleName: 'selectedLabel',
            globalClass: '.RSFSwatchProductOption-selectedLabel',
            description: '',
          },
          { ruleName: 'default', globalClass: '.RSFSwatchProductOption-default', description: '' },
          { ruleName: 'small', globalClass: '.RSFSwatchProductOption-small', description: '' },
          { ruleName: 'tiny', globalClass: '.RSFSwatchProductOption-tiny', description: '' },
        ],
        name: 'SwatchProductOption',
      },
      type: 'component',
      import: "import SwatchProductOption from 'react-storefront/option/SwatchProductOption'",
    },
    'option/TextProductOption': {
      name: 'TextProductOption',
      filename: 'TextProductOption',
      importPath: 'option/TextProductOption',
      src:
        "import React, { useState, useEffect, useContext } from 'react'\nimport makeStyles from '@material-ui/core/styles/makeStyles'\nimport PropTypes from 'prop-types'\nimport clsx from 'clsx'\nimport { Button } from '@material-ui/core'\nimport { Skeleton } from '@material-ui/lab'\n\nexport const styles = theme => ({\n  root: {\n    '.rsf-po-selected &': {\n      borderColor: theme.palette.primary.main,\n      backgroundColor: theme.palette.primary.main,\n      color: theme.palette.primary.contrastText,\n\n      '&:hover': {\n        borderColor: theme.palette.primary.main,\n        backgroundColor: theme.palette.primary.main,\n        color: theme.palette.primary.contrastText,\n      },\n    },\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFTextProductOption' })\n\n/**\n * Represents a single product option value as a button with text. All additional\n * props are spread to the underlying Material UI Button component.\n *\n * Example:\n *\n * ```js\n * <TextProductOption label=\"SM\" selected/>\n * ```\n */\nexport default function TextProductOption({\n  classes,\n  className,\n  selected,\n  label,\n  skeleton,\n  buttonProps,\n  onClick,\n}) {\n  classes = useStyles({ classes })\n\n  if (skeleton) {\n    return <Skeleton className={className} width={64} height={36} />\n  }\n\n  return (\n    <Button\n      {...buttonProps}\n      className={clsx(className, classes.root)}\n      variant={selected ? 'contained' : 'outlined'}\n      color={selected ? 'primary' : 'default'}\n      onClick={onClick}\n    >\n      {label}\n    </Button>\n  )\n}\n\nTextProductOption.propTypes = {\n  /**\n   * Set to true to display a skeleton instead of the actual button\n   */\n  skeleton: PropTypes.bool,\n  /**\n   * The text for the button\n   */\n  label: PropTypes.oneOfType([PropTypes.string, PropTypes.element]).isRequired,\n  /**\n   * Set to `true` to mark the option as selected.\n   */\n  selected: PropTypes.bool,\n  /**\n   * This prop is intentionally ignored so that TextProductOption can be used interchangably with\n   * SwatchProductOption without displaying a warning.\n   */\n  imageProps: PropTypes.object,\n}\n\nTextProductOption.defaultProps = {\n  selected: false,\n}\n",
      description:
        'Represents a single product option value as a button with text. All additional\nprops are spread to the underlying Material UI Button component.\n\nExample:\n\n```js\n<TextProductOption label="SM" selected/>\n```',
      displayName: 'TextProductOption',
      methods: [],
      props: [
        {
          name: 'skeleton',
          type: { name: 'bool' },
          required: false,
          description: 'Set to true to display a skeleton instead of the actual button',
        },
        {
          name: 'label',
          type: { name: 'union', value: [{ name: 'string' }, { name: 'element' }] },
          required: true,
          description: 'The text for the button',
        },
        {
          name: 'selected',
          type: { name: 'bool' },
          required: false,
          description: 'Set to `true` to mark the option as selected.',
          defaultValue: { value: 'false', computed: false },
        },
        {
          name: 'imageProps',
          type: { name: 'object' },
          required: false,
          description:
            'This prop is intentionally ignored so that TextProductOption can be used interchangably with\nSwatchProductOption without displaying a warning.',
        },
      ],
      styles: {
        classes: [{ ruleName: 'root', globalClass: '.RSFTextProductOption-root', description: '' }],
        name: 'TextProductOption',
      },
      type: 'component',
      import: "import TextProductOption from 'react-storefront/option/TextProductOption'",
    },
    'plp/Filter': {
      name: 'Filter',
      filename: 'Filter',
      importPath: 'plp/Filter',
      src:
        "import React, { useContext, memo } from 'react'\nimport PropTypes from 'prop-types'\nimport { makeStyles } from '@material-ui/core/styles'\nimport FacetGroup from './FacetGroup'\nimport FilterHeader from './FilterHeader'\nimport FilterFooter from './FilterFooter'\nimport SearchResultsContext from './SearchResultsContext'\n\n/**\n * UI for filtering an instance of SearchResultModelBase.  This component can be used on its own, or you can use\n * FilterButton to automatically display this component in a drawer that slides up from the bottom of the viewport.\n */\nexport const styles = theme => ({\n  root: {\n    height: '100%',\n    display: 'flex',\n    flexDirection: 'column',\n    alignItems: 'stretch',\n  },\n  facetGroups: {\n    overflow: 'auto',\n    overflowX: 'hidden',\n    flex: '1',\n    position: 'relative',\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFFilter' })\n\nfunction Filter({\n  expandAll,\n  hideClearLink,\n  clearLinkText,\n  submitOnChange,\n  style,\n  classes,\n  title,\n  onViewResultsClick,\n}) {\n  classes = useStyles({ classes })\n\n  const {\n    pageData: { facets },\n  } = useContext(SearchResultsContext)\n\n  return (\n    <div style={style} className={classes.root}>\n      <FilterHeader\n        hideClearLink={hideClearLink}\n        clearLinkText={clearLinkText}\n        title={title}\n        submitOnChange={submitOnChange}\n      />\n      <div className={classes.facetGroups}>\n        {facets &&\n          facets.map((group, i) => (\n            <FacetGroup\n              group={group}\n              key={i}\n              defaultExpanded={expandAll}\n              submitOnChange={submitOnChange}\n            />\n          ))}\n      </div>\n      <FilterFooter onViewResultsClick={onViewResultsClick} submitOnChange={submitOnChange} />\n    </div>\n  )\n}\n\nFilter.propTypes = {\n  /**\n   * Override or extend the styles applied to the component. See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object,\n\n  /**\n   * A function to call when the user clicks the button to view updated results.  The default behavior can be\n   * canceled by calling `preventDefault` on the passed in event.  The event is passed as the only argument.\n   */\n  onViewResultsClick: PropTypes.func,\n\n  /**\n   * The query string parameter that should be updated when filters are changed.  The value will be an array\n   * of codes for each selected facet.  Defaults to \"filters\"\n   */\n  queryParam: PropTypes.string,\n\n  /**\n   * An optional title to display at the top of the component.\n   */\n  title: PropTypes.string,\n\n  /**\n   * Set to `true` to expand all groups on initial render\n   */\n  expandAll: PropTypes.bool,\n\n  /**\n   * Set to `true` to refresh the results when the user toggles a filter\n   */\n  submitOnChange: PropTypes.bool,\n}\n\nFilter.defaultProps = {\n  onViewResultsClick: Function.prototype,\n  submitOnChange: false,\n}\n\nexport default memo(Filter)\n",
      description: '',
      displayName: 'Filter',
      methods: [],
      props: [
        {
          name: 'classes',
          type: { name: 'object' },
          required: false,
          description:
            'Override or extend the styles applied to the component. See [CSS API](#css) below for more details.',
        },
        {
          name: 'onViewResultsClick',
          type: { name: 'func' },
          required: false,
          description:
            'A function to call when the user clicks the button to view updated results.  The default behavior can be\ncanceled by calling `preventDefault` on the passed in event.  The event is passed as the only argument.',
          defaultValue: { value: 'Function.prototype', computed: true },
        },
        {
          name: 'queryParam',
          type: { name: 'string' },
          required: false,
          description:
            'The query string parameter that should be updated when filters are changed.  The value will be an array\nof codes for each selected facet.  Defaults to "filters"',
        },
        {
          name: 'title',
          type: { name: 'string' },
          required: false,
          description: 'An optional title to display at the top of the component.',
        },
        {
          name: 'expandAll',
          type: { name: 'bool' },
          required: false,
          description: 'Set to `true` to expand all groups on initial render',
        },
        {
          name: 'submitOnChange',
          type: { name: 'bool' },
          required: false,
          description: 'Set to `true` to refresh the results when the user toggles a filter',
          defaultValue: { value: 'false', computed: false },
        },
      ],
      styles: {
        classes: [
          { ruleName: 'root', globalClass: '.RSFFilter-root', description: '' },
          { ruleName: 'facetGroups', globalClass: '.RSFFilter-facetGroups', description: '' },
        ],
      },
      type: 'component',
      import: "import Filter from 'react-storefront/plp/Filter'",
    },
    'plp/FilterButton': {
      name: 'FilterButton',
      filename: 'FilterButton',
      importPath: 'plp/FilterButton',
      src:
        "import React, { useEffect, useState, useCallback, memo, useContext } from 'react'\nimport ActionButton from '../ActionButton'\nimport SearchResultsContext from './SearchResultsContext'\nimport Filter from './Filter'\nimport PropTypes from 'prop-types'\nimport Drawer from '../drawer/Drawer'\nimport { makeStyles } from '@material-ui/core/styles'\nimport { useRouter } from 'next/router'\n\nexport const styles = theme => ({\n  drawer: {\n    height: '75vh',\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFFilterButton' })\n\n/**\n * A button that when clicked, opens a drawer containing the `Filter` view. Current filters\n * are displayed in the button text.\n */\nfunction FilterButton({ classes, title, drawerProps, onClick, href, ...props }) {\n  classes = useStyles({ classes })\n\n  const {\n    pageData: { filters, facets },\n    actions,\n  } = useContext(SearchResultsContext)\n\n  const openFilter = useRouter().query.openFilter === '1'\n  const [state, setState] = useState({ open: openFilter, loading: false, mountDrawer: openFilter })\n  const { open, mountDrawer, loading } = state\n  const { clear, clearDisabled, drawer, ...buttonClasses } = useStyles(classes)\n\n  const toggleOpen = open => {\n    setState({ ...state, open, mountDrawer: mountDrawer || true })\n  }\n\n  const handleClick = e => {\n    if (onClick) {\n      onClick(e)\n    }\n\n    if (!e.defaultPrevented) {\n      toggleOpen(true)\n    }\n  }\n\n  const handleViewResultsClick = useCallback(() => {\n    toggleOpen(false)\n    actions.applyFilters()\n  }, [actions])\n\n  const getFilterList = () => {\n    if (!filters || !facets || filters.length === 0) return null\n    if (filters.length > 1) return `${filters.length} selected`\n\n    const selected = filters[0]\n\n    for (let group of facets) {\n      for (let option of group.options) {\n        if (selected === option.code) {\n          return option.name\n        }\n      }\n    }\n\n    return null\n  }\n\n  return (\n    <>\n      <ActionButton\n        label={title}\n        href={href}\n        value={getFilterList()}\n        classes={buttonClasses}\n        onClick={handleClick}\n        {...props}\n      />\n      {!href && (\n        <Drawer\n          classes={{ paper: classes.drawer }}\n          anchor=\"bottom\"\n          open={open}\n          onClose={toggleOpen.bind(null, false)}\n          ModalProps={{\n            keepMounted: true,\n          }}\n        >\n          {mountDrawer && <Filter onViewResultsClick={handleViewResultsClick} {...drawerProps} />}\n        </Drawer>\n      )}\n    </>\n  )\n}\n\nFilterButton.propTypes = {\n  /**\n   * Override or extend the styles applied to the component. See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object,\n\n  /**\n   * Props for the underlying `Filter` component\n   */\n  drawerProps: PropTypes.object,\n\n  /**\n   * The label for the button and the drawer header.  Defaults to \"Filter\".\n   */\n  title: PropTypes.string,\n\n  /**\n   * When specified, clicking the button will navigate to the specified URL with a full page reload.\n   */\n  href: PropTypes.string,\n}\n\nFilterButton.defaultProps = {\n  title: 'Filter',\n  drawerProps: {},\n}\n\nexport default memo(FilterButton)\n",
      description:
        'A button that when clicked, opens a drawer containing the `Filter` view. Current filters\nare displayed in the button text.',
      displayName: 'FilterButton',
      methods: [],
      props: [
        {
          name: 'classes',
          type: { name: 'object' },
          required: false,
          description:
            'Override or extend the styles applied to the component. See [CSS API](#css) below for more details.',
        },
        {
          name: 'drawerProps',
          type: { name: 'object' },
          required: false,
          description: 'Props for the underlying `Filter` component',
          defaultValue: { value: '{}', computed: false },
        },
        {
          name: 'title',
          type: { name: 'string' },
          required: false,
          description: 'The label for the button and the drawer header.  Defaults to "Filter".',
          defaultValue: { value: "'Filter'", computed: false },
        },
        {
          name: 'href',
          type: { name: 'string' },
          required: false,
          description:
            'When specified, clicking the button will navigate to the specified URL with a full page reload.',
        },
      ],
      styles: {
        classes: [{ ruleName: 'drawer', globalClass: '.RSFFilterButton-drawer', description: '' }],
      },
      type: 'component',
      import: "import FilterButton from 'react-storefront/plp/FilterButton'",
    },
    'plp/FilterFooter': {
      name: 'FilterFooter',
      filename: 'FilterFooter',
      importPath: 'plp/FilterFooter',
      src:
        "import React, { useContext } from 'react'\nimport { makeStyles } from '@material-ui/core/styles'\nimport { Button, Typography } from '@material-ui/core'\nimport { Hbox } from '../Box'\nimport SearchResultsContext from './SearchResultsContext'\n\nexport const styles = theme => ({\n  root: {\n    backgroundColor: theme.palette.secondary.main,\n    padding: '12px 20px',\n    color: 'white',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n  },\n  itemsFound: {\n    color: theme.palette.secondary.contrastText,\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFFilterFooter' })\n\nexport default function FilterFooter(props) {\n  let { classes, submitOnChange, onViewResultsClick } = props\n  classes = useStyles({ classes })\n\n  const {\n    pageData: { filters, filtersChanged },\n  } = useContext(SearchResultsContext)\n\n  if (!filters || !filtersChanged || submitOnChange) return null\n\n  return (\n    <Hbox className={classes.root} justify=\"space-between\">\n      <Typography variant=\"subtitle1\" className={classes.itemsFound}>\n        {filters.length || 'No'} filter\n        {filters.length === 1 ? '' : 's'} selected\n      </Typography>\n      <Button variant=\"contained\" size=\"large\" color=\"default\" onClick={onViewResultsClick}>\n        View Results\n      </Button>\n    </Hbox>\n  )\n}\n",
      description: '',
      displayName: 'FilterFooter',
      methods: [],
      styles: {
        classes: [
          { ruleName: 'root', globalClass: '.RSFFilterFooter-root', description: '' },
          { ruleName: 'itemsFound', globalClass: '.RSFFilterFooter-itemsFound', description: '' },
        ],
        name: 'FilterFooter',
      },
      props: [],
      type: 'component',
      import: "import FilterFooter from 'react-storefront/plp/FilterFooter'",
    },
    'plp/SearchResultsProvider': {
      name: 'SearchResultsProvider',
      filename: 'SearchResultsProvider',
      importPath: 'plp/SearchResultsProvider',
      src:
        "import React, { useEffect } from 'react'\nimport SearchResultsContext from './SearchResultsContext'\nimport PropTypes from 'prop-types'\nimport qs from 'qs'\nimport replaceState from '../router/replaceState'\n\n/**\n * Provides context to filter, sorting, and pagination components.\n *\n * ```js\n *  import useSearchResultsStore from 'react-storefront/plp/useSearchResultsStore'\n *  import SearchResultsProvider from 'react-storefront/plp/SearchResultsProvider'\n *  import FilterButton from 'react-storefront/plp/FilterButton'\n *\n *  function Subcategory(lazyProps) {\n *    const [store, updateStore] = useSearchResultsStore(lazyProps)\n *\n *    return (\n *      <SearchResultsProvider store={store}>\n *        <FilterButton/>\n *      </SearchResultsProvider>\n *    )\n *  }\n * ```\n */\nexport default function SearchResultsProvider({ store, updateStore, children }) {\n  useEffect(() => {\n    setState({\n      pageData: {\n        ...store.pageData,\n        appliedFilters: store.pageData.filters,\n      },\n    })\n  }, [])\n\n  const setState = state => {\n    store = { ...store, ...state }\n    updateStore(store)\n  }\n\n  /**\n   * Fetches the next page of results\n   */\n  const fetchMore = () => {\n    setState({\n      pageData: {\n        ...store.pageData,\n        page: store.pageData.page + 1,\n      },\n    })\n\n    return refresh()\n  }\n\n  /**\n   * Removes all filters\n   * @param {Boolean} submit If true, fetches new results from the server\n   */\n  const clearFilters = submit => {\n    setFilters([], submit)\n  }\n\n  /**\n   * Switches the state of a filter\n   * @param {Object} facet\n   * @param {Boolean} submit If true, fetches new results from the server\n   */\n  const toggleFilter = (facet, submit) => {\n    const { code } = facet\n    const { filters } = store.pageData\n    const nextFilters = [...filters]\n    const index = nextFilters.indexOf(code)\n\n    if (index === -1) {\n      nextFilters.push(code)\n    } else {\n      nextFilters.splice(index, 1)\n    }\n\n    setFilters(nextFilters, submit)\n  }\n\n  /**\n   * Updates the set of selected filters\n   * @param {Object[]} filters\n   * @param {Boolean} submit If true, fetches new results from the server\n   */\n  const setFilters = (filters, submit) => {\n    const { appliedFilters } = store.pageData\n    const filtersChanged =\n      JSON.stringify(filters.map(v => v.toLowerCase()).sort()) !==\n      JSON.stringify(appliedFilters.map(v => v.toLowerCase()).sort())\n\n    setState({\n      pageData: {\n        ...store.pageData,\n        filters,\n        filtersChanged,\n      },\n    })\n\n    if (submit) {\n      applyFilters()\n    }\n  }\n\n  /**\n   * Applies the selected filters, resets the page to 0 and fetches new results from the server.\n   */\n  const applyFilters = () => {\n    setState({\n      pageData: {\n        ...store.pageData,\n        filtersChanged: false,\n        appliedFilters: [...store.pageData.filters],\n        page: 0,\n      },\n    })\n\n    refresh()\n  }\n\n  /**\n   * Computes the query for the current state of the search controls\n   */\n  const getQueryForState = () => {\n    const { filters, page, sort } = store.pageData\n    const { search } = window.location\n    const query = qs.parse(search, { ignoreQueryPrefix: true })\n\n    if (filters.length) {\n      query.filters = JSON.stringify(filters)\n    } else {\n      delete query.filters\n    }\n\n    if (query.more) {\n      delete query.more\n    }\n\n    if (page > 0) {\n      query.page = page\n    } else {\n      delete query.page\n    }\n\n    if (sort) {\n      query.sort = sort\n    } else {\n      delete query.sort\n    }\n\n    return query\n  }\n\n  /**\n   * Computes the URL for the current query of the search controls\n   */\n  const getURLForState = query => {\n    const { pathname, hash } = window.location\n\n    return pathname + qs.stringify(query, { addQueryPrefix: true }) + hash\n  }\n\n  /**\n   * Fetches new results from the server\n   * @param {Object} options\n   */\n  const refresh = async () => {\n    const query = getQueryForState()\n    const apiUrl = getURLForState(query)\n\n    // Don't show page for user\n    delete query.page\n    replaceState(null, null, getURLForState(query))\n\n    if (store.pageData.page === 0) {\n      setState({ reloading: true })\n    }\n\n    const {\n      pageData: { products },\n    } = await fetch(`/api${apiUrl}`).then(res => res.json())\n\n    setState({\n      reloading: false,\n      pageData: {\n        ...store.pageData,\n        products: store.pageData.page === 0 ? products : store.pageData.products.concat(products),\n      },\n    })\n  }\n\n  const setSort = option => {\n    setState({\n      pageData: {\n        ...store.pageData,\n        sort: option.code,\n        page: 0,\n      },\n    })\n\n    refresh()\n  }\n\n  return (\n    <SearchResultsContext.Provider\n      value={{\n        ...store,\n        actions: {\n          fetchMore,\n          toggleFilter,\n          clearFilters,\n          applyFilters,\n          setSort,\n        },\n      }}\n    >\n      {children}\n    </SearchResultsContext.Provider>\n  )\n}\n\nSearchResultsProvider.propTypes = {\n  /**\n   * A store returned from `react-storefront/plp/useSearchResultsStore`.\n   */\n  store: PropTypes.object.isRequired,\n\n  /**\n   * The update function returned from `react-storefront/plp/useSearchResultsStore`.\n   */\n  updateStore: PropTypes.func.isRequired,\n}\n",
      description:
        "Provides context to filter, sorting, and pagination components.\n\n```js\n import useSearchResultsStore from 'react-storefront/plp/useSearchResultsStore'\n import SearchResultsProvider from 'react-storefront/plp/SearchResultsProvider'\n import FilterButton from 'react-storefront/plp/FilterButton'\n\n function Subcategory(lazyProps) {\n   const [store, updateStore] = useSearchResultsStore(lazyProps)\n\n   return (\n     <SearchResultsProvider store={store}>\n       <FilterButton/>\n     </SearchResultsProvider>\n   )\n }\n```",
      displayName: 'SearchResultsProvider',
      methods: [],
      props: [
        {
          name: 'store',
          type: { name: 'object' },
          required: true,
          description: 'A store returned from `react-storefront/plp/useSearchResultsStore`.',
        },
        {
          name: 'updateStore',
          type: { name: 'func' },
          required: true,
          description:
            'The update function returned from `react-storefront/plp/useSearchResultsStore`.',
        },
      ],
      styles: { classes: [], name: null },
      type: 'component',
      import: "import SearchResultsProvider from 'react-storefront/plp/SearchResultsProvider'",
    },
    'plp/ShowMore': {
      name: 'ShowMore',
      filename: 'ShowMore',
      importPath: 'plp/ShowMore',
      src:
        "import React, { useState, useContext } from 'react'\nimport PropTypes from 'prop-types'\nimport { makeStyles } from '@material-ui/core/styles'\nimport { CircularProgress, Button } from '@material-ui/core'\nimport clsx from 'clsx'\nimport SearchResultsContext from './SearchResultsContext'\nimport VisibilitySensor from 'react-visibility-sensor'\n\nexport const styles = theme => ({\n  root: {\n    margin: '15px 0',\n    width: '100%',\n    display: 'flex',\n    justifyContent: 'center',\n  },\n  button: {\n    [theme.breakpoints.down('xs')]: {\n      flex: 1,\n    },\n  },\n  loading: {\n    display: 'flex',\n    height: 45,\n    justifyContent: 'center',\n  },\n})\n\nconst VARIANTS = {\n  BUTTON: 'button',\n  INFINITE: 'infinite',\n}\n\nconst useStyles = makeStyles(styles, { name: 'RSFShowMore' })\n\n/**\n * A control that handles loading the next page of results in a search results\n * page or PLP.  This component can either display a \"Show More\" button:\n *\n * ```js\n * <ShowMore variant=\"button\"/>\n * ```\n * ... or can produce an \"infinite scroll\" effect that loads more records when the user\n * scrolls within a configured offset from the bottom of the page:\n *\n * ```js\n * <ShowMore variant=\"infinite\" infiniteLoadOffset={200}/>\n * ```\n *\n * This component should always be used inside a `<SearchResultsProvider/>`.\n *\n * This component relies on the following properties being defined in `pageData` in the page store:\n *\n * * `page` - The current page number\n * * `totalPages` - The total number of pages\n */\nexport default function ShowMore({\n  className,\n  style,\n  children,\n  variant,\n  href,\n  infiniteLoadOffset,\n  renderLoadingIcon,\n  ...others\n}) {\n  const classes = useStyles(others)\n  const [loading, setLoading] = useState(false)\n  const { actions, pageData } = useContext(SearchResultsContext)\n\n  if (pageData && pageData.page >= pageData.totalPages - 1) return null\n\n  async function fetchMore() {\n    if (!loading) {\n      setLoading(true)\n\n      try {\n        await actions.fetchMore()\n      } finally {\n        setLoading(false)\n      }\n    }\n  }\n\n  function handleVisible(isVisible) {\n    if (isVisible) {\n      fetchMore()\n    }\n  }\n\n  if (variant === VARIANTS.INFINITE) {\n    return (\n      <VisibilitySensor\n        onChange={handleVisible}\n        partialVisibility\n        offset={{ bottom: -infiniteLoadOffset }}\n      >\n        <div className={clsx(classes.loading, className)} style={style}>\n          {renderLoadingIcon()}\n        </div>\n      </VisibilitySensor>\n    )\n  } else {\n    return (\n      <div className={clsx(classes.root, className)} style={style}>\n        {loading ? (\n          <div className={classes.loading}>{renderLoadingIcon()}</div>\n        ) : (\n          <Button\n            variant=\"contained\"\n            color=\"primary\"\n            href={href}\n            className={classes.button}\n            onClick={fetchMore}\n            {...others}\n          >\n            {children || 'Show More'}\n          </Button>\n        )}\n      </div>\n    )\n  }\n}\n\nShowMore.propTypes = {\n  /**\n   * A renderer for the loading icon.  Uses CircularPropgress by default.\n   */\n  renderLoadingIcon: PropTypes.func,\n  /**\n   * Which variant to use. One of 'button' or 'infinite'.\n   *\n   * When variant is set to 'button':\n   *   A button is rendered with contents of {props.children} or 'Show More'.\n   *\n   * When variant is set to 'infinite':\n   *   The loading icon is rendered and contents of next page loaded when user\n   *   scrolls to the end of the page.\n   *\n   * In AMP the 'button' variant is always used.\n   */\n  variant: PropTypes.oneOf([VARIANTS.BUTTON, VARIANTS.INFINITE]),\n  /**\n   * Minimum amount of pixels from the bottom of the page to where the user has\n   * scrolled before the new page is loaded. Used in conjunction with 'infinite'\n   * variant. Defaults to 200.\n   */\n  infiniteLoadOffset: PropTypes.number,\n  /**\n   * When specified, clicking the button will navigate to the specified URL with a full page reload.\n   */\n  href: PropTypes.string,\n}\n\nShowMore.defaultProps = {\n  renderLoadingIcon: () => <CircularProgress />,\n  variant: VARIANTS.BUTTON,\n  infiniteLoadOffset: 200,\n}\n",
      description:
        'A control that handles loading the next page of results in a search results\npage or PLP.  This component can either display a "Show More" button:\n\n```js\n<ShowMore variant="button"/>\n```\n... or can produce an "infinite scroll" effect that loads more records when the user\nscrolls within a configured offset from the bottom of the page:\n\n```js\n<ShowMore variant="infinite" infiniteLoadOffset={200}/>\n```\n\nThis component should always be used inside a `<SearchResultsProvider/>`.\n\nThis component relies on the following properties being defined in `pageData` in the page store:\n\n* `page` - The current page number\n* `totalPages` - The total number of pages',
      displayName: 'ShowMore',
      methods: [],
      props: [
        {
          name: 'renderLoadingIcon',
          type: { name: 'func' },
          required: false,
          description: 'A renderer for the loading icon.  Uses CircularPropgress by default.',
          defaultValue: { value: '() => <CircularProgress />', computed: false },
        },
        {
          name: 'variant',
          type: {
            name: 'enum',
            value: [
              { value: "'button'", computed: false },
              { value: "'infinite'", computed: false },
            ],
          },
          required: false,
          description:
            "Which variant to use. One of 'button' or 'infinite'.\n\nWhen variant is set to 'button':\n  A button is rendered with contents of {props.children} or 'Show More'.\n\nWhen variant is set to 'infinite':\n  The loading icon is rendered and contents of next page loaded when user\n  scrolls to the end of the page.\n\nIn AMP the 'button' variant is always used.",
          defaultValue: { value: "'button'", computed: false },
        },
        {
          name: 'infiniteLoadOffset',
          type: { name: 'number' },
          required: false,
          description:
            "Minimum amount of pixels from the bottom of the page to where the user has\nscrolled before the new page is loaded. Used in conjunction with 'infinite'\nvariant. Defaults to 200.",
          defaultValue: { value: '200', computed: false },
        },
        {
          name: 'href',
          type: { name: 'string' },
          required: false,
          description:
            'When specified, clicking the button will navigate to the specified URL with a full page reload.',
        },
      ],
      styles: {
        classes: [
          { ruleName: 'root', globalClass: '.RSFShowMore-root', description: '' },
          { ruleName: 'button', globalClass: '.RSFShowMore-button', description: '' },
          { ruleName: 'loading', globalClass: '.RSFShowMore-loading', description: '' },
        ],
        name: 'ShowMore',
      },
      type: 'component',
      import: "import ShowMore from 'react-storefront/plp/ShowMore'",
    },
    'plp/Sort': {
      name: 'Sort',
      filename: 'Sort',
      importPath: 'plp/Sort',
      src:
        "import React, { memo, forwardRef, useContext } from 'react'\nimport { makeStyles } from '@material-ui/core/styles'\nimport { Button, MenuItem } from '@material-ui/core'\nimport PropTypes from 'prop-types'\nimport SearchResultsContext from './SearchResultsContext'\n\n/**\n * UI for sorting an instance of SearchResultModelBase.  This component can be used on its own, or you can use\n * SortButton to automatically display this component in a drawer that slides up from the bottom of the viewport.\n */\nexport const styles = theme => ({\n  container: {\n    padding: '15px 0 0 15px',\n  },\n  option: {\n    boxShadow: 'none',\n    width: 'calc(50% - 15px)',\n    margin: '0 15px 15px 0',\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFSort' })\n\nfunction Sort({ variant, classes, onSelect }) {\n  classes = useStyles({ classes })\n\n  const {\n    pageData: { sort, sortOptions },\n    actions: { setSort },\n  } = useContext(SearchResultsContext)\n\n  const handleClick = (option, e) => {\n    onSelect(option, e)\n\n    if (!e.defaultPrevented) {\n      setSort(option)\n    }\n  }\n\n  const renderButtons = () => (\n    <div className={classes.container}>\n      {sortOptions &&\n        sortOptions.map((option, i) => (\n          <Button\n            className={classes.option}\n            color={sort === option.code ? 'primary' : 'default'}\n            variant=\"contained\"\n            onClick={e => handleClick(option, e)}\n            key={i}\n          >\n            {option.name}\n          </Button>\n        ))}\n    </div>\n  )\n\n  const renderMenu = () => (\n    <>\n      {sortOptions &&\n        sortOptions.map((option, i) => (\n          <MenuItem key={i} onClick={e => handleClick(option, e)}>\n            {option.name}\n          </MenuItem>\n        ))}\n    </>\n  )\n\n  if (variant === 'buttons') {\n    return renderButtons()\n  } else if (variant === 'menu-items') {\n    return renderMenu()\n  } else {\n    return null\n  }\n}\n\nSort.propTypes = {\n  /**\n   * A function to call when a sort option is selected.  The option and event are passed.\n   * The default behavior can be prevented by called `preventDefault()` on the passed in event.\n   */\n  onSelect: PropTypes.func,\n\n  /**\n   * Controls how sort options are displayed.  Can be \"menu-items\" or \"buttons\".  Defaults to \"buttons\"\n   */\n  variant: PropTypes.oneOf(['menu-items', 'buttons']),\n}\n\nSort.defaultProps = {\n  onSelect: Function.prototype,\n  variant: 'buttons',\n}\n\nexport default memo(forwardRef((props, ref) => <Sort {...props} />))\n",
      description: '',
      displayName: 'Sort',
      methods: [],
      props: [
        {
          name: 'onSelect',
          type: { name: 'func' },
          required: false,
          description:
            'A function to call when a sort option is selected.  The option and event are passed.\nThe default behavior can be prevented by called `preventDefault()` on the passed in event.',
          defaultValue: { value: 'Function.prototype', computed: true },
        },
        {
          name: 'variant',
          type: {
            name: 'enum',
            value: [
              { value: "'menu-items'", computed: false },
              { value: "'buttons'", computed: false },
            ],
          },
          required: false,
          description:
            'Controls how sort options are displayed.  Can be "menu-items" or "buttons".  Defaults to "buttons"',
          defaultValue: { value: "'buttons'", computed: false },
        },
      ],
      styles: {
        classes: [
          { ruleName: 'container', globalClass: '.RSFSort-container', description: '' },
          { ruleName: 'option', globalClass: '.RSFSort-option', description: '' },
        ],
      },
      type: 'component',
      import: "import Sort from 'react-storefront/plp/Sort'",
    },
    'plp/SortButton': {
      name: 'SortButton',
      filename: 'SortButton',
      importPath: 'plp/SortButton',
      src:
        "import React, { memo, useState, useEffect, useContext, useRef } from 'react'\nimport ActionButton from '../ActionButton'\nimport Sort from './Sort'\nimport PropTypes from 'prop-types'\nimport Drawer from '../drawer/Drawer'\nimport { Menu, useMediaQuery } from '@material-ui/core'\nimport { useTheme } from '@material-ui/core/styles'\nimport { useRouter } from 'next/router'\nimport SearchResultsContext from './SearchResultsContext'\n\n/**\n * A button that when clicked, opens a drawer containing the `Sort` view. The name of the currently\n * selected sortOption is display in the button text.\n */\nfunction SortButton({\n  variant,\n  title,\n  drawerProps,\n  onClick,\n  sortProps,\n  drawerBreakpoint,\n  href,\n  ...props\n}) {\n  const theme = useTheme()\n  const openSort = useRouter().query.openSort === '1'\n  const [state, setState] = useState({\n    open: false,\n    mountDrawer: false,\n    anchorEl: null,\n  })\n  const { open, mountDrawer, anchorEl } = state\n  const {\n    pageData: { sort, sortOptions },\n  } = useContext(SearchResultsContext)\n  const buttonRef = useRef()\n  const selectedOption = sortOptions.find(o => sort === o.code)\n\n  useEffect(() => {\n    if (location.search.indexOf('openSort') !== -1) {\n      setState({ open: true, mountDrawer: true, anchorEl: buttonRef.current })\n    }\n  }, [])\n\n  const handleClick = e => {\n    if (onClick) {\n      onClick(e)\n    }\n\n    if (!e.defaultPrevented) {\n      toggleOpen(true, e.currentTarget)\n    }\n  }\n\n  const close = () => {\n    toggleOpen(false)\n  }\n\n  const toggleOpen = (open, anchorEl) => {\n    if (open) {\n      setState({ mountDrawer: true, open: true, anchorEl: anchorEl })\n    } else {\n      setState({ open: false, anchorEl: null })\n    }\n  }\n\n  const useDrawer = useMediaQuery(theme.breakpoints.down(drawerBreakpoint))\n\n  return (\n    <>\n      <ActionButton\n        key=\"button\"\n        label={title}\n        ref={buttonRef}\n        value={selectedOption && selectedOption.name}\n        href={href}\n        {...props}\n        onClick={e => handleClick(e)}\n      />\n      {!href && useDrawer && (\n        <Drawer\n          ModalProps={{\n            keepMounted: true,\n          }}\n          key=\"drawer\"\n          anchor=\"bottom\"\n          title={title}\n          open={open}\n          onClose={close}\n          {...drawerProps}\n        >\n          {mountDrawer && <Sort onSelect={close} {...sortProps} />}\n        </Drawer>\n      )}\n      {!href && !useDrawer && (\n        <Menu open={open} anchorEl={anchorEl} onClose={close}>\n          <Sort variant=\"menu-items\" onSelect={close} {...sortProps} />\n        </Menu>\n      )}\n    </>\n  )\n}\n\nSortButton.propTypes = {\n  /**\n   * Override or extend the styles applied to the component. See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object,\n\n  /**\n   * Props to pass to the underlying `Drawer` component.\n   */\n  drawerProps: PropTypes.object,\n\n  /**\n   * Props to pass to the underlying `Sort` component.\n   */\n  sortProps: PropTypes.object,\n\n  /**\n   * Text for the button label and the drawer header.  Defaults to \"Sort\".\n   */\n  title: PropTypes.string,\n\n  /**\n   * The breakpoint in your theme below which a drawer UI should be used in favor of the menu UI.\n   */\n  drawerBreakpoint: PropTypes.string,\n\n  /**\n   * When specified, clicking the button will navigate to the specified URL with a full page reload.\n   */\n  href: PropTypes.string,\n}\n\nSortButton.defaultProps = {\n  title: 'Sort',\n  drawerProps: {},\n  sortProps: {},\n  drawerBreakpoint: 'xs',\n}\n\nexport default memo(SortButton)\n",
      description:
        'A button that when clicked, opens a drawer containing the `Sort` view. The name of the currently\nselected sortOption is display in the button text.',
      displayName: 'SortButton',
      methods: [],
      props: [
        {
          name: 'classes',
          type: { name: 'object' },
          required: false,
          description:
            'Override or extend the styles applied to the component. See [CSS API](#css) below for more details.',
        },
        {
          name: 'drawerProps',
          type: { name: 'object' },
          required: false,
          description: 'Props to pass to the underlying `Drawer` component.',
          defaultValue: { value: '{}', computed: false },
        },
        {
          name: 'sortProps',
          type: { name: 'object' },
          required: false,
          description: 'Props to pass to the underlying `Sort` component.',
          defaultValue: { value: '{}', computed: false },
        },
        {
          name: 'title',
          type: { name: 'string' },
          required: false,
          description: 'Text for the button label and the drawer header.  Defaults to "Sort".',
          defaultValue: { value: "'Sort'", computed: false },
        },
        {
          name: 'drawerBreakpoint',
          type: { name: 'string' },
          required: false,
          description:
            'The breakpoint in your theme below which a drawer UI should be used in favor of the menu UI.',
          defaultValue: { value: "'xs'", computed: false },
        },
        {
          name: 'href',
          type: { name: 'string' },
          required: false,
          description:
            'When specified, clicking the button will navigate to the specified URL with a full page reload.',
        },
      ],
      styles: { classes: [], name: null },
      type: 'component',
      import: "import SortButton from 'react-storefront/plp/SortButton'",
    },
    'search/SearchButton': {
      name: 'SearchButton',
      filename: 'SearchButton',
      importPath: 'search/SearchButton',
      src:
        "import React from 'react'\nimport { IconButton } from '@material-ui/core'\nimport { Search } from '@material-ui/icons'\nimport { makeStyles } from '@material-ui/core/styles'\n\nexport const styles = theme => ({\n  icon: {\n    color: theme.palette.action.active,\n  },\n  large: {\n    fontSize: '28px',\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFSearchButton' })\n\nexport default function SearchButton({ children, classes, search, ...other }) {\n  classes = useStyles({ classes })\n\n  return (\n    <IconButton aria-label=\"Search\" color=\"inherit\" classes={{ label: classes.large }} {...other}>\n      {children || <Search className={classes.icon} />}\n    </IconButton>\n  )\n}\n",
      description: '',
      displayName: 'SearchButton',
      methods: [],
      styles: {
        classes: [
          { ruleName: 'icon', globalClass: '.RSFSearchButton-icon', description: '' },
          { ruleName: 'large', globalClass: '.RSFSearchButton-large', description: '' },
        ],
        name: 'SearchButton',
      },
      props: [],
      type: 'component',
      import: "import SearchButton from 'react-storefront/search/SearchButton'",
    },
    'search/SearchDrawer': {
      name: 'SearchDrawer',
      filename: 'SearchDrawer',
      importPath: 'search/SearchDrawer',
      src:
        "import React from 'react'\nimport Drawer from '../drawer/Drawer'\nimport { makeStyles } from '@material-ui/core/styles'\nimport PropTypes from 'prop-types'\nimport SearchProvider from './SearchProvider'\n\nexport const styles = theme => ({\n  paper: {\n    display: 'flex',\n  },\n  closeButton: {\n    color: theme.palette.primary.contrastText,\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFSearch' })\n\nexport default function SearchDrawer({ DrawerComponent, classes, open, onClose, children }) {\n  classes = useStyles({ classes })\n\n  return (\n    <SearchProvider onClose={onClose}>\n      <DrawerComponent classes={classes} open={open} anchor=\"bottom\" onClose={onClose} fullscreen>\n        {children}\n      </DrawerComponent>\n    </SearchProvider>\n  )\n}\n\nSearchDrawer.propTypes = {\n  DrawerComponent: PropTypes.func,\n}\n\nSearchDrawer.defaultProps = {\n  DrawerComponent: Drawer,\n}\n",
      description: '',
      displayName: 'SearchDrawer',
      methods: [],
      props: [
        {
          name: 'DrawerComponent',
          type: { name: 'func' },
          required: false,
          description: '',
          defaultValue: { value: 'Drawer', computed: true },
        },
      ],
      styles: {
        classes: [
          { ruleName: 'paper', globalClass: '.RSFSearch-paper', description: '' },
          { ruleName: 'closeButton', globalClass: '.RSFSearch-closeButton', description: '' },
        ],
        name: 'SearchDrawer',
      },
      type: 'component',
      import: "import SearchDrawer from 'react-storefront/search/SearchDrawer'",
    },
    'search/SearchField': {
      name: 'SearchField',
      filename: 'SearchField',
      importPath: 'search/SearchField',
      src:
        "import React, { useState, useRef, useContext } from 'react'\nimport makeStyles from '@material-ui/core/styles/makeStyles'\nimport PropTypes from 'prop-types'\nimport withDefaultHandler from '../utils/withDefaultHandler'\nimport SearchContext from './SearchContext'\nimport { IconButton } from '@material-ui/core'\nimport ClearIcon from '@material-ui/icons/Clear'\nimport SearchSubmitButton from './SearchSubmitButton'\nimport { Fab, Button } from '@material-ui/core'\nimport clsx from 'clsx'\n\nexport const styles = theme => ({\n  root: {\n    display: 'flex',\n    alignItems: 'center',\n  },\n  inputWrap: {\n    display: 'flex',\n    flexGrow: 1,\n    border: 0,\n    borderRadius: '35px',\n    backgroundColor: theme.palette.background.paper,\n    margin: 0,\n    height: '48px',\n  },\n  input: {\n    border: 'none',\n    background: 'none',\n    flex: 1,\n    padding: '0 0 0 20px',\n    ...theme.typography.body1,\n    '&:focus': {\n      outline: 'none',\n    },\n  },\n  searchFab: {\n    height: '48px',\n    width: '48px',\n    marginLeft: '10px',\n    backgroundColor: theme.palette.background.paper,\n    color: theme.palette.text.secondary,\n  },\n  hidden: {\n    display: 'none',\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFSearchField' })\n\n/**\n * A search text field. Additional props are spread to the underlying input.\n */\nexport default function SearchField({\n  classes,\n  onChange,\n  submitButtonVariant,\n  showClearButton,\n  SubmitButtonComponent,\n  clearButtonProps,\n  inputProps,\n  submitButtonProps,\n  ...others\n}) {\n  classes = useStyles({ classes })\n  const inputRef = useRef(null)\n  const { fetchSuggestions } = useContext(SearchContext)\n  const [text, setText] = useState('')\n  const empty = text.trim().length === 0\n\n  const handleInputFocus = () => {\n    inputRef.current.setSelectionRange(0, inputRef.current.value.length)\n  }\n\n  const handleChange = withDefaultHandler(onChange, e => {\n    const text = e.target.value\n    setText(text)\n    fetchSuggestions(text)\n  })\n\n  const handleClearClick = () => {\n    const text = ''\n    setText(text)\n    fetchSuggestions(text)\n  }\n\n  return (\n    <div className={classes.root} data-empty={text.trim().length === 0 ? 'on' : 'off'}>\n      <div className={classes.inputWrap}>\n        <input\n          {...others}\n          type=\"text\"\n          value={text}\n          onChange={handleChange}\n          onFocus={handleInputFocus}\n          ref={inputRef}\n          className={classes.input}\n          {...inputProps}\n        />\n        {showClearButton ? (\n          <IconButton\n            {...clearButtonProps}\n            onClick={handleClearClick}\n            rel=\"clear\"\n            className={clsx({\n              [classes.searchReset]: true,\n              [classes.hidden]: empty,\n            })}\n          >\n            <ClearIcon rel=\"clear\" />\n          </IconButton>\n        ) : (\n          submitButtonVariant === 'icon' && (\n            <SubmitButtonComponent\n              Component={Button}\n              className={clsx({\n                [classes.searchButton]: true,\n                [classes.hidden]: empty,\n              })}\n              text={text}\n              {...submitButtonProps}\n            />\n          )\n        )}\n      </div>\n      {submitButtonVariant === 'fab' && (\n        <SubmitButtonComponent\n          Component={Fab}\n          className={clsx({\n            [classes.searchFab]: true,\n            [classes.hidden]: empty,\n          })}\n          text={text}\n          {...submitButtonProps}\n        />\n      )}\n    </div>\n  )\n}\n\nSearchField.propTypes = {\n  /**\n   * The component to use for the submit button\n   */\n  SubmitButtonComponent: PropTypes.func,\n  /**\n   * The type of submit button to display\n   */\n  submitButtonVariant: PropTypes.oneOf(['icon', 'fab']),\n  /**\n   * `true` to show the clear button when text is entered.\n   */\n  showClearButton: PropTypes.bool,\n  /**\n   * Additional props for the clearButton\n   */\n  clearButtonProps: PropTypes.object,\n  /**\n   * Additional props for the Material UI Input\n   */\n  inputProps: PropTypes.object,\n  /**\n   * Additional props for the submit button\n   */\n  submitButtonProps: PropTypes.object,\n}\n\nSearchField.defaultProps = {\n  SubmitButtonComponent: SearchSubmitButton,\n  submitButtonVariant: 'fab',\n  showClearButton: true,\n  placeholder: 'Search...',\n  name: 'q',\n}\n",
      description: 'A search text field. Additional props are spread to the underlying input.',
      displayName: 'SearchField',
      methods: [],
      props: [
        {
          name: 'SubmitButtonComponent',
          type: { name: 'func' },
          required: false,
          description: 'The component to use for the submit button',
          defaultValue: { value: 'SearchSubmitButton', computed: true },
        },
        {
          name: 'submitButtonVariant',
          type: {
            name: 'enum',
            value: [
              { value: "'icon'", computed: false },
              { value: "'fab'", computed: false },
            ],
          },
          required: false,
          description: 'The type of submit button to display',
          defaultValue: { value: "'fab'", computed: false },
        },
        {
          name: 'showClearButton',
          type: { name: 'bool' },
          required: false,
          description: '`true` to show the clear button when text is entered.',
          defaultValue: { value: 'true', computed: false },
        },
        {
          name: 'clearButtonProps',
          type: { name: 'object' },
          required: false,
          description: 'Additional props for the clearButton',
        },
        {
          name: 'inputProps',
          type: { name: 'object' },
          required: false,
          description: 'Additional props for the Material UI Input',
        },
        {
          name: 'submitButtonProps',
          type: { name: 'object' },
          required: false,
          description: 'Additional props for the submit button',
        },
        {
          name: 'placeholder',
          defaultValue: { value: "'Search...'", computed: false },
          required: false,
        },
        { name: 'name', defaultValue: { value: "'q'", computed: false }, required: false },
      ],
      styles: {
        classes: [
          { ruleName: 'root', globalClass: '.RSFSearchField-root', description: '' },
          { ruleName: 'inputWrap', globalClass: '.RSFSearchField-inputWrap', description: '' },
          { ruleName: 'input', globalClass: '.RSFSearchField-input', description: '' },
          { ruleName: 'searchFab', globalClass: '.RSFSearchField-searchFab', description: '' },
          { ruleName: 'hidden', globalClass: '.RSFSearchField-hidden', description: '' },
        ],
        name: 'SearchField',
      },
      type: 'component',
      import: "import SearchField from 'react-storefront/search/SearchField'",
    },
    'search/SearchForm': {
      name: 'SearchForm',
      filename: 'SearchForm',
      importPath: 'search/SearchForm',
      src:
        "import React, { useRef, useState } from 'react'\nimport makeStyles from '@material-ui/core/styles/makeStyles'\nimport { useRouter } from 'next/router'\nimport qs from 'qs'\n\nexport const styles = theme => ({\n  root: {\n    position: 'relative',\n    height: '100%',\n    display: 'flex',\n    flexDirection: 'column',\n  },\n})\nconst useStyles = makeStyles(styles, { name: 'RSFSearchForm' })\n\nexport default function SearchForm({ classes, children, action }) {\n  classes = useStyles({ classes })\n\n  const ref = useRef()\n  const router = useRouter()\n\n  const handleSubmit = async e => {\n    e.preventDefault()\n\n    const data = new FormData(ref.current)\n    const query = {}\n\n    for (let [name, value] of data.entries()) {\n      query[name] = value\n    }\n\n    const url = `${action}${action.includes('?') ? '&' : '?'}${qs.stringify(query)}`\n    router.push(action.split(/\\?/)[0], url)\n    return false\n  }\n\n  return (\n    <form ref={ref} action={action} onSubmit={handleSubmit} className={classes.root} target=\"_top\">\n      {children}\n    </form>\n  )\n}\n\nSearchForm.propTypes = {}\n\nSearchForm.defaultProps = {\n  action: '/search',\n}\n",
      description: '',
      displayName: 'SearchForm',
      methods: [],
      props: [
        { name: 'action', defaultValue: { value: "'/search'", computed: false }, required: false },
      ],
      styles: {
        classes: [{ ruleName: 'root', globalClass: '.RSFSearchForm-root', description: '' }],
        name: 'SearchForm',
      },
      type: 'component',
      import: "import SearchForm from 'react-storefront/search/SearchForm'",
    },
    'search/SearchHeader': {
      name: 'SearchHeader',
      filename: 'SearchHeader',
      importPath: 'search/SearchHeader',
      src:
        "import React from 'react'\nimport { makeStyles } from '@material-ui/core/styles'\nimport PropTypes from 'prop-types'\n\nexport const styles = theme => ({\n  root: {\n    backgroundColor: theme.palette.primary.main,\n    padding: theme.spacing(6, 2, 2, 2),\n    display: 'flex',\n    flexDirection: 'column',\n    alignItems: 'stretch',\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFSearchHeader' })\n\nexport default function SearchHeader({ classes, children }) {\n  classes = useStyles({ classes })\n  return <div className={classes.root}>{children}</div>\n}\n\nSearchHeader.propTypes = {}\n\nSearchHeader.defaultProps = {}\n",
      description: '',
      displayName: 'SearchHeader',
      methods: [],
      styles: {
        classes: [{ ruleName: 'root', globalClass: '.RSFSearchHeader-root', description: '' }],
        name: 'SearchHeader',
      },
      props: [],
      type: 'component',
      import: "import SearchHeader from 'react-storefront/search/SearchHeader'",
    },
    'search/SearchProvider': {
      name: 'SearchProvider',
      filename: 'SearchProvider',
      importPath: 'search/SearchProvider',
      src:
        "import React, { useMemo, useState, useEffect } from 'react'\nimport PropTypes from 'prop-types'\nimport SearchContext from './SearchContext'\nimport _fetch from 'isomorphic-unfetch'\nimport debounce from 'lodash/debounce'\nimport { fetchLatest, StaleResponseError } from '../utils/fetchLatest'\nimport useNavigationEvent from '../hooks/useNavigationEvent'\n\nconst fetch = fetchLatest(_fetch)\n\nexport default function SearchProvider({ children, initialGroups, onClose }) {\n  const [state, setState] = useState({\n    groups: initialGroups,\n    loading: true,\n  })\n\n  useEffect(() => {\n    if (state.groups == null) {\n      fetchSuggestions('')\n    }\n  }, [])\n\n  useNavigationEvent(onClose)\n\n  const fetchSuggestions = debounce(async text => {\n    try {\n      setState(state => ({\n        ...state,\n        loading: true,\n      }))\n\n      const url = `/api/suggestions?q=${encodeURIComponent(text.trim())}`\n      const { groups } = await fetch(url, { credentials: 'include' }).then(res => res.json())\n\n      setState(state => ({\n        ...state,\n        loading: false,\n        groups,\n      }))\n    } catch (e) {\n      if (!StaleResponseError.is(e)) {\n        setState(state => ({\n          ...state,\n          loading: false,\n        }))\n      }\n    }\n  }, 250)\n\n  // const context = useMemo(\n  //   () => ({\n  //     state,\n  //     setState,\n  //     fetchSuggestions,\n  //     onClose,\n  //     submit\n  //   }),\n  //   [state]\n  // )\n\n  const context = {\n    state,\n    setState,\n    fetchSuggestions,\n    onClose,\n  }\n\n  return <SearchContext.Provider value={context}>{children}</SearchContext.Provider>\n}\n\nSearchProvider.propTypes = {\n  initialGroups: PropTypes.array,\n  onClose: PropTypes.func,\n}\n",
      description: '',
      displayName: 'SearchProvider',
      methods: [],
      props: [
        { name: 'initialGroups', type: { name: 'array' }, required: false, description: '' },
        { name: 'onClose', type: { name: 'func' }, required: false, description: '' },
      ],
      styles: { classes: [], name: null },
      type: 'component',
      import: "import SearchProvider from 'react-storefront/search/SearchProvider'",
    },
    'search/SearchSubmitButton': {
      name: 'SearchSubmitButton',
      filename: 'SearchSubmitButton',
      importPath: 'search/SearchSubmitButton',
      src:
        "import React from 'react'\nimport makeStyles from '@material-ui/core/styles/makeStyles'\nimport PropTypes from 'prop-types'\nimport SearchIcon from '@material-ui/icons/Search'\n\nexport const styles = theme => ({\n  root: {},\n  label: {\n    display: 'flex',\n  },\n})\nconst useStyles = makeStyles(styles, { name: 'RSFSearchSubmitButton' })\n\n/**\n * A button to submit the search.  All other props are spread to the provided `Component`.\n */\nexport default function SearchSubmitButton({ Component, classes, text, ...others }) {\n  classes = useStyles({ classes })\n\n  return (\n    <Component\n      rel=\"search\"\n      type=\"submit\"\n      className={classes.root}\n      classes={{ label: classes.label }}\n      disabled={text.trim().length === 0}\n      {...others}\n    >\n      <SearchIcon />\n    </Component>\n  )\n}\n\nSearchSubmitButton.propTypes = {\n  /**\n   * A Material UI button component to display.\n   */\n  Component: PropTypes.elementType.isRequired,\n  /**\n   * The current search text\n   */\n  text: PropTypes.string.isRequired,\n}\n\nSearchSubmitButton.defaultProps = {}\n",
      description:
        'A button to submit the search.  All other props are spread to the provided `Component`.',
      displayName: 'SearchSubmitButton',
      methods: [],
      props: [
        {
          name: 'Component',
          type: { name: 'elementType' },
          required: true,
          description: 'A Material UI button component to display.',
        },
        {
          name: 'text',
          type: { name: 'string' },
          required: true,
          description: 'The current search text',
        },
      ],
      styles: {
        classes: [
          { ruleName: 'root', globalClass: '.RSFSearchSubmitButton-root', description: '' },
          { ruleName: 'label', globalClass: '.RSFSearchSubmitButton-label', description: '' },
        ],
        name: 'SearchSubmitButton',
      },
      type: 'component',
      import: "import SearchSubmitButton from 'react-storefront/search/SearchSubmitButton'",
    },
    'search/SearchSuggestionGroup': {
      name: 'SearchSuggestionGroup',
      filename: 'SearchSuggestionGroup',
      importPath: 'search/SearchSuggestionGroup',
      src:
        "import React, { useState, useEffect, useContext } from 'react'\nimport makeStyles from '@material-ui/core/styles/makeStyles'\nimport Typography from '@material-ui/core/Typography'\nimport PropTypes from 'prop-types'\nimport clsx from 'clsx'\nimport SearchSuggestionItem from './SearchSuggestionItem'\n\nexport const styles = theme => ({\n  root: {\n    listStyle: 'none',\n    margin: theme.spacing(2),\n    '& a strong': {\n      fontWeight: 'bold',\n      color: 'inherit',\n    },\n  },\n  caption: {\n    textTransform: 'uppercase',\n    fontWeight: 'bold',\n    paddingBottom: 5,\n    borderBottom: `1px solid ${theme.palette.divider}`,\n    margin: theme.spacing(0, 0, 1, 0),\n  },\n  list: {\n    '&[data-ui=list]': {\n      padding: 0,\n      margin: theme.spacing(0, 0, 4, 0),\n    },\n    '&[data-ui=thumbnails]': {\n      display: 'flex',\n      listStyle: 'none',\n      margin: '0 -15px',\n      padding: '0 10px',\n      overflowX: 'auto',\n      '& > li': {\n        margin: '5px',\n      },\n    },\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFSearchSuggestionGroup' })\n\nexport default function SearchSuggestionGroup({ classes, ui, caption, links, children }) {\n  classes = useStyles({ classes })\n\n  return (\n    <div className={classes.root}>\n      <Typography className={classes.caption}>{caption}</Typography>\n      <ul className={classes.list} data-ui={ui}>\n        {children\n          ? children\n          : links.map((item, i) => <SearchSuggestionItem item={item} ui={ui} key={i} />)}\n      </ul>\n    </div>\n  )\n}\n\nSearchSuggestionGroup.propTypes = {\n  /**\n   * An array of links to suggested searches.\n   */\n  links: PropTypes.array,\n  /**\n   * A title for the list\n   */\n  caption: PropTypes.string.isRequired,\n}\n\nSearchSuggestionGroup.defaultProps = {}\n",
      description: '',
      displayName: 'SearchSuggestionGroup',
      methods: [],
      props: [
        {
          name: 'links',
          type: { name: 'array' },
          required: false,
          description: 'An array of links to suggested searches.',
        },
        {
          name: 'caption',
          type: { name: 'string' },
          required: true,
          description: 'A title for the list',
        },
      ],
      styles: {
        classes: [
          { ruleName: 'root', globalClass: '.RSFSearchSuggestionGroup-root', description: '' },
          {
            ruleName: 'caption',
            globalClass: '.RSFSearchSuggestionGroup-caption',
            description: '',
          },
          { ruleName: 'list', globalClass: '.RSFSearchSuggestionGroup-list', description: '' },
        ],
        name: 'SearchSuggestionGroup',
      },
      type: 'component',
      import: "import SearchSuggestionGroup from 'react-storefront/search/SearchSuggestionGroup'",
    },
    'search/SearchSuggestionItem': {
      name: 'SearchSuggestionItem',
      filename: 'SearchSuggestionItem',
      importPath: 'search/SearchSuggestionItem',
      src:
        "import React from 'react'\nimport makeStyles from '@material-ui/core/styles/makeStyles'\nimport Link from '../link/Link'\nimport { Typography } from '@material-ui/core'\nimport PropTypes from 'prop-types'\nimport Image from '../Image'\n\nexport const styles = theme => ({\n  root: {\n    margin: theme.spacing(2, 0),\n    listStyle: 'none',\n    padding: 0,\n    '& [data-ui=thumbnails]': {\n      display: 'flex',\n      flexDirection: 'column',\n      alignItems: 'flex-start',\n    },\n  },\n  thumbnail: {\n    marginBottom: '10px',\n    display: 'none',\n    '[data-ui=thumbnails] &': {\n      display: 'block',\n      '& img': {\n        height: 120,\n        width: 120,\n        minWidth: 120,\n      },\n    },\n  },\n})\n\nconst useStyles = makeStyles(styles, { name: 'RSFSearchSuggestionItem' })\n\nexport default function SearchSuggestionItem({\n  ImageComponent,\n  classes,\n  item,\n  ui,\n  thumbnailProps,\n  children,\n}) {\n  classes = useStyles({ classes })\n\n  return (\n    <li className={classes.root}>\n      <Link as={item.as} href={item.href} pageData={item.pageData}>\n        {children ? (\n          children\n        ) : (\n          <a>\n            <div data-ui={ui}>\n              <ImageComponent\n                className={classes.thumbnail}\n                {...thumbnailProps}\n                {...item.thumbnail}\n              />\n              <Typography>{item.text}</Typography>\n            </div>\n          </a>\n        )}\n      </Link>\n    </li>\n  )\n}\n\nSearchSuggestionItem.propTypes = {\n  /**\n   * The component to use to display images.\n   */\n  ImageComponent: PropTypes.func,\n}\n\nSearchSuggestionItem.defaultProps = {\n  ImageComponent: Image,\n}\n",
      description: '',
      displayName: 'SearchSuggestionItem',
      methods: [],
      props: [
        {
          name: 'ImageComponent',
          type: { name: 'func' },
          required: false,
          description: 'The component to use to display images.',
          defaultValue: { value: 'Image', computed: true },
        },
      ],
      styles: {
        classes: [
          { ruleName: 'root', globalClass: '.RSFSearchSuggestionItem-root', description: '' },
          {
            ruleName: 'thumbnail',
            globalClass: '.RSFSearchSuggestionItem-thumbnail',
            description: '',
          },
        ],
        name: 'SearchSuggestionItem',
      },
      type: 'component',
      import: "import SearchSuggestionItem from 'react-storefront/search/SearchSuggestionItem'",
    },
    'search/SearchSuggestions': {
      name: 'SearchSuggestions',
      filename: 'SearchSuggestions',
      importPath: 'search/SearchSuggestions',
      src:
        "import React, { useContext } from 'react'\nimport { makeStyles } from '@material-ui/core/styles'\nimport PropTypes from 'prop-types'\nimport SearchSuggestionGroup from './SearchSuggestionGroup'\nimport SearchContext from './SearchContext'\nimport LoadMask from '../LoadMask'\n\nexport const styles = theme => ({\n  root: {\n    flex: 1,\n    overflowY: 'auto',\n  },\n  group: {\n    margin: theme.spacing(0, 0, 2, 0),\n  },\n})\nconst useStyles = makeStyles(styles, { name: 'RSFSearchSuggestions' })\n\nexport default function SearchSuggestions({ classes }) {\n  classes = useStyles({ classes })\n  const { state } = useContext(SearchContext)\n\n  return (\n    <div className={classes.root}>\n      <LoadMask show={state.loading} transparent />\n\n      {state.groups &&\n        state.groups.map((group, i) => (\n          <div key={i} className={classes.group}>\n            <SearchSuggestionGroup {...group} />\n          </div>\n        ))}\n    </div>\n  )\n}\n\nSearchSuggestions.propTypes = {}\n\nSearchSuggestions.defaultProps = {}\n",
      description: '',
      displayName: 'SearchSuggestions',
      methods: [],
      styles: {
        classes: [
          { ruleName: 'root', globalClass: '.RSFSearchSuggestions-root', description: '' },
          { ruleName: 'group', globalClass: '.RSFSearchSuggestions-group', description: '' },
        ],
        name: 'SearchSuggestions',
      },
      props: [],
      type: 'component',
      import: "import SearchSuggestions from 'react-storefront/search/SearchSuggestions'",
    },
    'session/SessionProvider': {
      name: 'SessionProvider',
      filename: 'SessionProvider',
      importPath: 'session/SessionProvider',
      src:
        "import React, { useState, useEffect, useMemo } from 'react'\nimport SessionContext from './SessionContext'\nimport PropTypes from 'prop-types'\nimport fetch from 'isomorphic-unfetch'\n\n/**\n * Fetches user session data from a specific URL and provides it to descendant components via `SessionContext`.\n *\n * User and session data such as the number of items in the cart, the user's name, and email should always be\n * fetched when the app mounts, not in `getInitialProps`, otherwise the SSR result would not be cacheable\n * since it would contain user-specific data.\n */\nexport default function SessionProvider({ url, children }) {\n  const [session, setSession] = useState(null)\n\n  const context = useMemo(() => {\n    return {\n      session,\n      actions: {\n        updateCartCount(quantity) {\n          setSession({\n            ...session,\n            itemsInCart: quantity,\n          })\n        },\n      },\n    }\n  }, [session])\n\n  useEffect(() => {\n    async function fetchSession() {\n      setSession(await fetch(url).then(res => res.json()))\n    }\n\n    if (url) fetchSession()\n  }, [url])\n\n  return <SessionContext.Provider value={context}>{children}</SessionContext.Provider>\n}\n\nSessionProvider.propTypes = {\n  /**\n   * A URL to fetch when the app mounts which establishes a user session and returns user and cart data\n   * to be made available via `react-storefront/session/SessionContext`.\n   */\n  url: PropTypes.string,\n}\n\nSessionProvider.defaultProps = {}\n",
      description:
        "Fetches user session data from a specific URL and provides it to descendant components via `SessionContext`.\n\nUser and session data such as the number of items in the cart, the user's name, and email should always be\nfetched when the app mounts, not in `getInitialProps`, otherwise the SSR result would not be cacheable\nsince it would contain user-specific data.",
      displayName: 'SessionProvider',
      methods: [],
      props: [
        {
          name: 'url',
          type: { name: 'string' },
          required: false,
          description:
            'A URL to fetch when the app mounts which establishes a user session and returns user and cart data\nto be made available via `react-storefront/session/SessionContext`.',
        },
      ],
      styles: { classes: [], name: null },
      type: 'component',
      import: "import SessionProvider from 'react-storefront/session/SessionProvider'",
    },
    profile: {
      name: 'profile',
      type: 'function',
      async: false,
      generator: false,
      comments:
        'Executes the callback and returns its result while logging the execution time to the console.',
      examples: [],
      params: [
        { name: 'label', type: 'String', text: 'A string to preface the console.log' },
        { name: 'cb', type: 'Function', text: 'A function to execute' },
      ],
      returns: [{ type: 'Object', text: 'The result of the function' }],
      import: "import profile from 'react-storefront/profile'",
    },
    'serviceWorker/prefetch': {
      name: 'prefetch',
      type: 'function',
      async: true,
      generator: false,
      comments: 'Prefetch a URL using the service worker.',
      examples: [],
      params: [{ name: 'url', type: 'String', text: 'The URL to prefetch' }],
      returns: [],
      import: "import { prefetch } from 'react-storefront/serviceWorker'",
    },
    'serviceWorker/prefetchJsonFor': {
      name: 'prefetchJsonFor',
      type: 'function',
      async: false,
      generator: false,
      comments: 'Prefetches the JSON API results for a given page',
      examples: [],
      params: [{ name: 'url', type: 'String', text: 'The page URL.' }],
      returns: [],
      import: "import { prefetchJsonFor } from 'react-storefront/serviceWorker'",
    },
    'hooks/useAppStore': {
      name: 'useAppStore',
      type: 'function',
      async: false,
      generator: false,
      comments:
        'Provides a store for app-level data that is shared by all pages, such as\nthe main menu, nav, and footer items.',
      examples: [],
      params: [
        {
          name: 'props',
          type: 'Object',
          text: 'Data fetched from getInitialProps, which should include an `appData` key.',
        },
      ],
      returns: [
        {
          type: 'Array',
          text:
            "A state and an updater function, similar to the result of React's `useState` hook.  The state will contain the value of appData returned by getInitialProps",
        },
      ],
      import: "import useAppStore from 'react-storefront/hooks/useAppStore'",
    },
    'hooks/useIntersectionObserver': {
      name: 'useIntersectionObserver',
      type: 'function',
      async: false,
      generator: false,
      comments:
        "Calls a provided callback when the provided element moves into or out of the viewport.\n\nExample:\n\n```js\n import React, { useRef, useCallback } from 'react'\n import useIntersectionObserver from 'react-storefront/hooks/useIntersectionObserver'\n\n function MyComponent() {\n   const ref = useRef(null)\n\n   const onVisibilityChange = useCallback((visible, disconnect) => {\n     if (visible) {\n       // do some side effect here\n       // and optionally stop observing by calling: disconnect()\n     }\n   }, [])\n\n   useIntersectionObserver(() => ref, onVisibilityChange, [])\n   return <div ref={ref}></div>\n }\n\n```",
      examples: [],
      params: [
        {
          name: 'getRef',
          type: 'Function',
          text: 'A function that returns a ref pointing to the element to observe',
        },
        { name: 'cb', type: 'Function', text: 'A callback to call when visibility changes' },
        {
          name: 'deps',
          type: 'Object',
          extendedType: 'Array',
          text:
            'The IntersectionObserver will be updated to observe a new ref whenever any of these change',
        },
      ],
      returns: [],
      import:
        "import useIntersectionObserver from 'react-storefront/hooks/useIntersectionObserver'",
    },
    'hooks/useStateFromProp': {
      name: 'useStateFromProp',
      type: 'function',
      async: false,
      generator: false,
      comments:
        "The same as React's useState, but automatically updated when the specified prop value changes.",
      examples: [],
      params: [{ name: 'prop', type: 'Object' }],
      returns: [{ type: 'Array', text: "The same as what's returned from React's useState hook." }],
      import: "import useStateFromProp from 'react-storefront/hooks/useStateFromProp'",
    },
    'middlewares/withAmpFormParser': {
      name: 'withAmpFormParser',
      type: 'function',
      async: false,
      generator: false,
      comments:
        "Wraps the provided handler in a middleware that parses AMP form submissions correctly.  By\ndefault, next.js's body parser doesn't handle multipart form posts properly, so you\nwon't be able to receive data posted from a form in AMP.\n\nWhen using this middleware, you should always disable next's default body parser by adding\nthe following to your api endpoint:\n\n```js\nexport const config = {\n  api: {\n    bodyParser: false\n  }\n}\n```",
      examples: [],
      params: [{ name: 'handler', type: 'Function', text: 'An API endpoint' }],
      returns: [
        { type: 'Function', text: 'Your API function with body parsing middleware added.' },
      ],
      import: "import withAmpFormParser from 'react-storefront/middlewares/withAmpFormParser'",
    },
    'props/fetchProps': {
      name: 'fetchProps',
      type: 'function',
      async: false,
      generator: false,
      comments:
        "Creates a `getInitialProps` props function that fetches props from an API endpoint. Use this\nin conjunction with `react-storefront/hooks/useLazyStore` to display a skeleton with partial\ndata while fetching the full data for the page from the server.\n\nThe returned function will skip displaying the skeleton if the API response can be served from\nthe browser's cache.\n\nExample:\n\n```js\nimport useLazyStore from 'react-storefront/hooks/useLazyStore'\nimport fetchProps from 'react-storefront/props/fetchProps'\n\nfunction Product(lazyProps) {\n  const [store, updateStore] = useLazyStore(lazyProps)\n  const { product } = store.pageData\n\n  // store.loading will be true while fetching product data from the server\n\n  // store.pageData will be populated with the `pageData` prop provided to the <Link> element\n  // that was clicked.  In this way you can provide partial data to a page.  For example:\n  //\n  // <Link href=\"/p/[productId]\" as={`/p/${product.id}`} pageData={{ product }}>{product.name}</Link>\n\n  return (\n    <Grid container spacing={4}>\n      <Grid item xs={12}>\n        { product.name ? <Typography variant=\"h1\">{product.name}</Typography> : <Skeleton style={{ height: 16 }}/> }\n      </Grid>\n      // render the rest of the PDP\n    </Grid>\n  )\n}\n\nProduct.getInitialProps = withCaching({\n  browser: true\n  edge: {\n    maxAgeSeconds: 1000,\n    key: createCustomCacheKey().addCookie('currency')\n  }\n})(fetchProps(({ query }) => `/api/p/${encodeURIComponent(query.productId)}`))\n```",
      examples: [],
      params: [{ name: 'createApiUrl', type: 'Function' }],
      returns: [],
      import: "import fetchProps from 'react-storefront/props/fetchProps'",
    },
    'props/fulfillAPIRequest': {
      name: 'fulfillAPIRequest',
      type: 'function',
      async: true,
      generator: false,
      comments:
        'Creates an API response that contains app level data only when ?_includeAppData=1 is present in the query string.\nOtherwise the appData promise provided will not be resolved.',
      examples: [],
      params: [
        { name: 'req', type: 'Request', text: 'The request being served' },
        {
          name: 'options',
          default: '{}',
          type: 'Object',
          properties: [
            {
              name: 'appData',
              type: 'Function',
              text:
                'An async function that returns a data for shared component in the app such as menu, nav, and footer',
            },
            {
              name: 'pageData',
              type: 'Function',
              text: 'An async function that return data for the page component',
            },
          ],
        },
      ],
      returns: [
        { type: 'Object', text: 'the result of appData and pageData merged into a single object.' },
      ],
      import: "import fulfillAPIRequest from 'react-storefront/props/fulfillAPIRequest'",
    },
    'router/replaceState': {
      name: 'replaceState',
      type: 'function',
      async: false,
      generator: false,
      comments:
        "Replaces the history state in a way that is compatible with next.js. Use this function\ninstead of history.replaceState to ensure that next.js uses your new state's URL when going back.",
      examples: [],
      params: [
        {
          name: 'state',
          type: 'Object',
          text: 'A new state.  If null, the existing state will be preserved.',
        },
        {
          name: 'title',
          type: 'String',
          text: 'A new title for the document, if null, the existing title will be preserved.',
        },
        { name: 'url', type: 'String', text: 'The new URL' },
      ],
      returns: [],
      import: "import replaceState from 'react-storefront/router/replaceState'",
    },
    'router/storeInitialPropsInHistory': {
      name: 'storeInitialPropsInHistory',
      type: 'function',
      async: false,
      generator: false,
      comments:
        'Patches history.pushState and history.replaceState to stores the props of the\ncurrent main component in history.state before navigating.  This allows us to instantly\nrender the main component when the user goes back',
      examples: [],
      params: [],
      returns: [],
      import:
        "import storeInitialPropsInHistory from 'react-storefront/router/storeInitialPropsInHistory'",
    },
    'utils/fetchLatest/default': {
      name: 'fetchLatest',
      type: 'function',
      async: false,
      generator: false,
      comments:
        "Creates a fetch function with an internal incrementing request counter that ensures that out of order\nresponses result in a `StaleResponseError`.\n\nExample usage:\n\n```js\nimport { fetchLatest, StaleResponseError } from 'react-storefront/fetchLatest'\nimport originalFetch from 'fetch'\n\nconst fetch = fetchLatest(originalFetch)\n\ntry {\n  const response = await fetch('/some/url')\n} catch (e) {\n  if (!StaleResponseError.is(e)) {\n    throw e // just ignore stale responses, rethrow all other errors\n  }\n}\n```",
      examples: [],
      params: [
        {
          name: 'fetch',
          type: 'Function',
          text: 'An implementation of the standard browser fetch.',
        },
      ],
      returns: [{ type: 'Function' }],
      import: "import fetchLatest from 'react-storefront/utils/fetchLatest'",
    },
    'utils/fetchLatest/StaleResponseError': {
      name: 'StaleResponseError',
      type: 'class',
      async: false,
      generator: false,
      comments: 'Thrown when an out of order response is received from `fetchLatest`.',
      examples: [],
      params: [],
      returns: [],
      import: "import { StaleResponseError } from 'react-storefront/utils/fetchLatest'",
      members: [],
    },
    'utils/format/price': {
      name: 'price',
      type: 'function',
      async: false,
      generator: false,
      comments: 'Formats a price for display.',
      examples: [],
      params: [
        { name: 'price', type: 'Number', text: 'The price as a floating point number' },
        {
          name: 'options',
          default: '{}',
          type: 'Object',
          properties: [
            { name: 'currency', default: "'USD'", type: 'String', text: 'The currency code' },
            {
              name: 'decimals',
              default: '2',
              type: 'Number',
              text: 'The number of decimal places to display',
            },
            { name: 'locale', default: "'en-US'", type: 'String', text: 'The locale code' },
          ],
        },
      ],
      returns: [{ type: 'String' }],
      import: "import { price } from 'react-storefront/utils/format'",
    },
    'utils/lazyLoadImages': {
      name: 'lazyLoadImages',
      type: 'function',
      async: false,
      generator: false,
      comments:
        'Observes the visibility of all img elements inside the specified element\nthat match the specified selector. When an image becomes visible, the `data-src`\nattribute is copied to `src`.\n\nSee https://developers.google.com/web/fundamentals/performance/lazy-loading-guidance/images-and-video/',
      examples: [],
      params: [
        { name: 'element' },
        {
          name: '$1',
          default: '{}',
          type: 'Object',
          properties: [{ name: 'selector', default: "'img[data-rsf-lazy]'" }],
        },
      ],
      returns: [],
      import: "import lazyLoadImages from 'react-storefront/utils/lazyLoadImages'",
    },
    'utils/merge': {
      name: 'merge',
      type: 'function',
      async: false,
      generator: false,
      comments:
        'Deep merges sources onto object.  The same as lodash/merge, except arrays are not concatenated.  When a source\nobject provides an array, it replaces the value on the target.',
      examples: [],
      params: [{ name: 'object' }, { name: 'sources', type: 'any' }],
      returns: [],
      import: "import merge from 'react-storefront/utils/merge'",
    },
    'utils/withDefaultHandler': {
      name: 'withDefaultHandler',
      type: 'function',
      async: false,
      generator: false,
      comments:
        'Creates a cancelable event handler that will run unless the provided\nhandler calls `e.preventDefault()`.',
      examples: [],
      params: [
        {
          name: 'handler',
          type: 'Function',
          text: 'The original event handle supplied to the component',
        },
        {
          name: 'defaultHandler',
          type: 'Function',
          text: 'A handler to run unless `e.preventDefault()` was called.',
        },
      ],
      returns: [{ type: 'Function' }],
      import: "import withDefaultHandler from 'react-storefront/utils/withDefaultHandler'",
    },
  },
}
export default data
